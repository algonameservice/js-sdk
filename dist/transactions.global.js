(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + x + '" is not supported');
  });
  var __objRest = (source, exclude) => {
    var target = {};
    for (var prop in source)
      if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
        target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(source)) {
        if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
          target[prop] = source[prop];
      }
    return target;
  };
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // node_modules/tweetnacl/nacl-fast.js
  var require_nacl_fast = __commonJS({
    "node_modules/tweetnacl/nacl-fast.js"(exports2, module2) {
      (function(nacl2) {
        "use strict";
        var gf = function(init) {
          var i, r = new Float64Array(16);
          if (init)
            for (i = 0; i < init.length; i++)
              r[i] = init[i];
          return r;
        };
        var randombytes = function() {
          throw new Error("no PRNG");
        };
        var _0 = new Uint8Array(16);
        var _9 = new Uint8Array(32);
        _9[0] = 9;
        var gf0 = gf(), gf1 = gf([1]), _121665 = gf([56129, 1]), D = gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), D2 = gf([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), X = gf([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), Y = gf([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), I = gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
        function ts64(x, i, h, l) {
          x[i] = h >> 24 & 255;
          x[i + 1] = h >> 16 & 255;
          x[i + 2] = h >> 8 & 255;
          x[i + 3] = h & 255;
          x[i + 4] = l >> 24 & 255;
          x[i + 5] = l >> 16 & 255;
          x[i + 6] = l >> 8 & 255;
          x[i + 7] = l & 255;
        }
        function vn(x, xi, y, yi, n) {
          var i, d = 0;
          for (i = 0; i < n; i++)
            d |= x[xi + i] ^ y[yi + i];
          return (1 & d - 1 >>> 8) - 1;
        }
        function crypto_verify_16(x, xi, y, yi) {
          return vn(x, xi, y, yi, 16);
        }
        function crypto_verify_32(x, xi, y, yi) {
          return vn(x, xi, y, yi, 32);
        }
        function core_salsa20(o, p, k, c) {
          var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
          var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
          for (var i = 0; i < 20; i += 2) {
            u = x0 + x12 | 0;
            x4 ^= u << 7 | u >>> 32 - 7;
            u = x4 + x0 | 0;
            x8 ^= u << 9 | u >>> 32 - 9;
            u = x8 + x4 | 0;
            x12 ^= u << 13 | u >>> 32 - 13;
            u = x12 + x8 | 0;
            x0 ^= u << 18 | u >>> 32 - 18;
            u = x5 + x1 | 0;
            x9 ^= u << 7 | u >>> 32 - 7;
            u = x9 + x5 | 0;
            x13 ^= u << 9 | u >>> 32 - 9;
            u = x13 + x9 | 0;
            x1 ^= u << 13 | u >>> 32 - 13;
            u = x1 + x13 | 0;
            x5 ^= u << 18 | u >>> 32 - 18;
            u = x10 + x6 | 0;
            x14 ^= u << 7 | u >>> 32 - 7;
            u = x14 + x10 | 0;
            x2 ^= u << 9 | u >>> 32 - 9;
            u = x2 + x14 | 0;
            x6 ^= u << 13 | u >>> 32 - 13;
            u = x6 + x2 | 0;
            x10 ^= u << 18 | u >>> 32 - 18;
            u = x15 + x11 | 0;
            x3 ^= u << 7 | u >>> 32 - 7;
            u = x3 + x15 | 0;
            x7 ^= u << 9 | u >>> 32 - 9;
            u = x7 + x3 | 0;
            x11 ^= u << 13 | u >>> 32 - 13;
            u = x11 + x7 | 0;
            x15 ^= u << 18 | u >>> 32 - 18;
            u = x0 + x3 | 0;
            x1 ^= u << 7 | u >>> 32 - 7;
            u = x1 + x0 | 0;
            x2 ^= u << 9 | u >>> 32 - 9;
            u = x2 + x1 | 0;
            x3 ^= u << 13 | u >>> 32 - 13;
            u = x3 + x2 | 0;
            x0 ^= u << 18 | u >>> 32 - 18;
            u = x5 + x4 | 0;
            x6 ^= u << 7 | u >>> 32 - 7;
            u = x6 + x5 | 0;
            x7 ^= u << 9 | u >>> 32 - 9;
            u = x7 + x6 | 0;
            x4 ^= u << 13 | u >>> 32 - 13;
            u = x4 + x7 | 0;
            x5 ^= u << 18 | u >>> 32 - 18;
            u = x10 + x9 | 0;
            x11 ^= u << 7 | u >>> 32 - 7;
            u = x11 + x10 | 0;
            x8 ^= u << 9 | u >>> 32 - 9;
            u = x8 + x11 | 0;
            x9 ^= u << 13 | u >>> 32 - 13;
            u = x9 + x8 | 0;
            x10 ^= u << 18 | u >>> 32 - 18;
            u = x15 + x14 | 0;
            x12 ^= u << 7 | u >>> 32 - 7;
            u = x12 + x15 | 0;
            x13 ^= u << 9 | u >>> 32 - 9;
            u = x13 + x12 | 0;
            x14 ^= u << 13 | u >>> 32 - 13;
            u = x14 + x13 | 0;
            x15 ^= u << 18 | u >>> 32 - 18;
          }
          x0 = x0 + j0 | 0;
          x1 = x1 + j1 | 0;
          x2 = x2 + j2 | 0;
          x3 = x3 + j3 | 0;
          x4 = x4 + j4 | 0;
          x5 = x5 + j5 | 0;
          x6 = x6 + j6 | 0;
          x7 = x7 + j7 | 0;
          x8 = x8 + j8 | 0;
          x9 = x9 + j9 | 0;
          x10 = x10 + j10 | 0;
          x11 = x11 + j11 | 0;
          x12 = x12 + j12 | 0;
          x13 = x13 + j13 | 0;
          x14 = x14 + j14 | 0;
          x15 = x15 + j15 | 0;
          o[0] = x0 >>> 0 & 255;
          o[1] = x0 >>> 8 & 255;
          o[2] = x0 >>> 16 & 255;
          o[3] = x0 >>> 24 & 255;
          o[4] = x1 >>> 0 & 255;
          o[5] = x1 >>> 8 & 255;
          o[6] = x1 >>> 16 & 255;
          o[7] = x1 >>> 24 & 255;
          o[8] = x2 >>> 0 & 255;
          o[9] = x2 >>> 8 & 255;
          o[10] = x2 >>> 16 & 255;
          o[11] = x2 >>> 24 & 255;
          o[12] = x3 >>> 0 & 255;
          o[13] = x3 >>> 8 & 255;
          o[14] = x3 >>> 16 & 255;
          o[15] = x3 >>> 24 & 255;
          o[16] = x4 >>> 0 & 255;
          o[17] = x4 >>> 8 & 255;
          o[18] = x4 >>> 16 & 255;
          o[19] = x4 >>> 24 & 255;
          o[20] = x5 >>> 0 & 255;
          o[21] = x5 >>> 8 & 255;
          o[22] = x5 >>> 16 & 255;
          o[23] = x5 >>> 24 & 255;
          o[24] = x6 >>> 0 & 255;
          o[25] = x6 >>> 8 & 255;
          o[26] = x6 >>> 16 & 255;
          o[27] = x6 >>> 24 & 255;
          o[28] = x7 >>> 0 & 255;
          o[29] = x7 >>> 8 & 255;
          o[30] = x7 >>> 16 & 255;
          o[31] = x7 >>> 24 & 255;
          o[32] = x8 >>> 0 & 255;
          o[33] = x8 >>> 8 & 255;
          o[34] = x8 >>> 16 & 255;
          o[35] = x8 >>> 24 & 255;
          o[36] = x9 >>> 0 & 255;
          o[37] = x9 >>> 8 & 255;
          o[38] = x9 >>> 16 & 255;
          o[39] = x9 >>> 24 & 255;
          o[40] = x10 >>> 0 & 255;
          o[41] = x10 >>> 8 & 255;
          o[42] = x10 >>> 16 & 255;
          o[43] = x10 >>> 24 & 255;
          o[44] = x11 >>> 0 & 255;
          o[45] = x11 >>> 8 & 255;
          o[46] = x11 >>> 16 & 255;
          o[47] = x11 >>> 24 & 255;
          o[48] = x12 >>> 0 & 255;
          o[49] = x12 >>> 8 & 255;
          o[50] = x12 >>> 16 & 255;
          o[51] = x12 >>> 24 & 255;
          o[52] = x13 >>> 0 & 255;
          o[53] = x13 >>> 8 & 255;
          o[54] = x13 >>> 16 & 255;
          o[55] = x13 >>> 24 & 255;
          o[56] = x14 >>> 0 & 255;
          o[57] = x14 >>> 8 & 255;
          o[58] = x14 >>> 16 & 255;
          o[59] = x14 >>> 24 & 255;
          o[60] = x15 >>> 0 & 255;
          o[61] = x15 >>> 8 & 255;
          o[62] = x15 >>> 16 & 255;
          o[63] = x15 >>> 24 & 255;
        }
        function core_hsalsa20(o, p, k, c) {
          var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
          var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
          for (var i = 0; i < 20; i += 2) {
            u = x0 + x12 | 0;
            x4 ^= u << 7 | u >>> 32 - 7;
            u = x4 + x0 | 0;
            x8 ^= u << 9 | u >>> 32 - 9;
            u = x8 + x4 | 0;
            x12 ^= u << 13 | u >>> 32 - 13;
            u = x12 + x8 | 0;
            x0 ^= u << 18 | u >>> 32 - 18;
            u = x5 + x1 | 0;
            x9 ^= u << 7 | u >>> 32 - 7;
            u = x9 + x5 | 0;
            x13 ^= u << 9 | u >>> 32 - 9;
            u = x13 + x9 | 0;
            x1 ^= u << 13 | u >>> 32 - 13;
            u = x1 + x13 | 0;
            x5 ^= u << 18 | u >>> 32 - 18;
            u = x10 + x6 | 0;
            x14 ^= u << 7 | u >>> 32 - 7;
            u = x14 + x10 | 0;
            x2 ^= u << 9 | u >>> 32 - 9;
            u = x2 + x14 | 0;
            x6 ^= u << 13 | u >>> 32 - 13;
            u = x6 + x2 | 0;
            x10 ^= u << 18 | u >>> 32 - 18;
            u = x15 + x11 | 0;
            x3 ^= u << 7 | u >>> 32 - 7;
            u = x3 + x15 | 0;
            x7 ^= u << 9 | u >>> 32 - 9;
            u = x7 + x3 | 0;
            x11 ^= u << 13 | u >>> 32 - 13;
            u = x11 + x7 | 0;
            x15 ^= u << 18 | u >>> 32 - 18;
            u = x0 + x3 | 0;
            x1 ^= u << 7 | u >>> 32 - 7;
            u = x1 + x0 | 0;
            x2 ^= u << 9 | u >>> 32 - 9;
            u = x2 + x1 | 0;
            x3 ^= u << 13 | u >>> 32 - 13;
            u = x3 + x2 | 0;
            x0 ^= u << 18 | u >>> 32 - 18;
            u = x5 + x4 | 0;
            x6 ^= u << 7 | u >>> 32 - 7;
            u = x6 + x5 | 0;
            x7 ^= u << 9 | u >>> 32 - 9;
            u = x7 + x6 | 0;
            x4 ^= u << 13 | u >>> 32 - 13;
            u = x4 + x7 | 0;
            x5 ^= u << 18 | u >>> 32 - 18;
            u = x10 + x9 | 0;
            x11 ^= u << 7 | u >>> 32 - 7;
            u = x11 + x10 | 0;
            x8 ^= u << 9 | u >>> 32 - 9;
            u = x8 + x11 | 0;
            x9 ^= u << 13 | u >>> 32 - 13;
            u = x9 + x8 | 0;
            x10 ^= u << 18 | u >>> 32 - 18;
            u = x15 + x14 | 0;
            x12 ^= u << 7 | u >>> 32 - 7;
            u = x12 + x15 | 0;
            x13 ^= u << 9 | u >>> 32 - 9;
            u = x13 + x12 | 0;
            x14 ^= u << 13 | u >>> 32 - 13;
            u = x14 + x13 | 0;
            x15 ^= u << 18 | u >>> 32 - 18;
          }
          o[0] = x0 >>> 0 & 255;
          o[1] = x0 >>> 8 & 255;
          o[2] = x0 >>> 16 & 255;
          o[3] = x0 >>> 24 & 255;
          o[4] = x5 >>> 0 & 255;
          o[5] = x5 >>> 8 & 255;
          o[6] = x5 >>> 16 & 255;
          o[7] = x5 >>> 24 & 255;
          o[8] = x10 >>> 0 & 255;
          o[9] = x10 >>> 8 & 255;
          o[10] = x10 >>> 16 & 255;
          o[11] = x10 >>> 24 & 255;
          o[12] = x15 >>> 0 & 255;
          o[13] = x15 >>> 8 & 255;
          o[14] = x15 >>> 16 & 255;
          o[15] = x15 >>> 24 & 255;
          o[16] = x6 >>> 0 & 255;
          o[17] = x6 >>> 8 & 255;
          o[18] = x6 >>> 16 & 255;
          o[19] = x6 >>> 24 & 255;
          o[20] = x7 >>> 0 & 255;
          o[21] = x7 >>> 8 & 255;
          o[22] = x7 >>> 16 & 255;
          o[23] = x7 >>> 24 & 255;
          o[24] = x8 >>> 0 & 255;
          o[25] = x8 >>> 8 & 255;
          o[26] = x8 >>> 16 & 255;
          o[27] = x8 >>> 24 & 255;
          o[28] = x9 >>> 0 & 255;
          o[29] = x9 >>> 8 & 255;
          o[30] = x9 >>> 16 & 255;
          o[31] = x9 >>> 24 & 255;
        }
        function crypto_core_salsa20(out, inp, k, c) {
          core_salsa20(out, inp, k, c);
        }
        function crypto_core_hsalsa20(out, inp, k, c) {
          core_hsalsa20(out, inp, k, c);
        }
        var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
        function crypto_stream_salsa20_xor(c, cpos, m, mpos, b, n, k) {
          var z = new Uint8Array(16), x = new Uint8Array(64);
          var u, i;
          for (i = 0; i < 16; i++)
            z[i] = 0;
          for (i = 0; i < 8; i++)
            z[i] = n[i];
          while (b >= 64) {
            crypto_core_salsa20(x, z, k, sigma);
            for (i = 0; i < 64; i++)
              c[cpos + i] = m[mpos + i] ^ x[i];
            u = 1;
            for (i = 8; i < 16; i++) {
              u = u + (z[i] & 255) | 0;
              z[i] = u & 255;
              u >>>= 8;
            }
            b -= 64;
            cpos += 64;
            mpos += 64;
          }
          if (b > 0) {
            crypto_core_salsa20(x, z, k, sigma);
            for (i = 0; i < b; i++)
              c[cpos + i] = m[mpos + i] ^ x[i];
          }
          return 0;
        }
        function crypto_stream_salsa20(c, cpos, b, n, k) {
          var z = new Uint8Array(16), x = new Uint8Array(64);
          var u, i;
          for (i = 0; i < 16; i++)
            z[i] = 0;
          for (i = 0; i < 8; i++)
            z[i] = n[i];
          while (b >= 64) {
            crypto_core_salsa20(x, z, k, sigma);
            for (i = 0; i < 64; i++)
              c[cpos + i] = x[i];
            u = 1;
            for (i = 8; i < 16; i++) {
              u = u + (z[i] & 255) | 0;
              z[i] = u & 255;
              u >>>= 8;
            }
            b -= 64;
            cpos += 64;
          }
          if (b > 0) {
            crypto_core_salsa20(x, z, k, sigma);
            for (i = 0; i < b; i++)
              c[cpos + i] = x[i];
          }
          return 0;
        }
        function crypto_stream(c, cpos, d, n, k) {
          var s = new Uint8Array(32);
          crypto_core_hsalsa20(s, n, k, sigma);
          var sn = new Uint8Array(8);
          for (var i = 0; i < 8; i++)
            sn[i] = n[i + 16];
          return crypto_stream_salsa20(c, cpos, d, sn, s);
        }
        function crypto_stream_xor(c, cpos, m, mpos, d, n, k) {
          var s = new Uint8Array(32);
          crypto_core_hsalsa20(s, n, k, sigma);
          var sn = new Uint8Array(8);
          for (var i = 0; i < 8; i++)
            sn[i] = n[i + 16];
          return crypto_stream_salsa20_xor(c, cpos, m, mpos, d, sn, s);
        }
        var poly1305 = function(key) {
          this.buffer = new Uint8Array(16);
          this.r = new Uint16Array(10);
          this.h = new Uint16Array(10);
          this.pad = new Uint16Array(8);
          this.leftover = 0;
          this.fin = 0;
          var t0, t1, t2, t3, t4, t5, t6, t7;
          t0 = key[0] & 255 | (key[1] & 255) << 8;
          this.r[0] = t0 & 8191;
          t1 = key[2] & 255 | (key[3] & 255) << 8;
          this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
          t2 = key[4] & 255 | (key[5] & 255) << 8;
          this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
          t3 = key[6] & 255 | (key[7] & 255) << 8;
          this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
          t4 = key[8] & 255 | (key[9] & 255) << 8;
          this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
          this.r[5] = t4 >>> 1 & 8190;
          t5 = key[10] & 255 | (key[11] & 255) << 8;
          this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
          t6 = key[12] & 255 | (key[13] & 255) << 8;
          this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
          t7 = key[14] & 255 | (key[15] & 255) << 8;
          this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
          this.r[9] = t7 >>> 5 & 127;
          this.pad[0] = key[16] & 255 | (key[17] & 255) << 8;
          this.pad[1] = key[18] & 255 | (key[19] & 255) << 8;
          this.pad[2] = key[20] & 255 | (key[21] & 255) << 8;
          this.pad[3] = key[22] & 255 | (key[23] & 255) << 8;
          this.pad[4] = key[24] & 255 | (key[25] & 255) << 8;
          this.pad[5] = key[26] & 255 | (key[27] & 255) << 8;
          this.pad[6] = key[28] & 255 | (key[29] & 255) << 8;
          this.pad[7] = key[30] & 255 | (key[31] & 255) << 8;
        };
        poly1305.prototype.blocks = function(m, mpos, bytes) {
          var hibit = this.fin ? 0 : 1 << 11;
          var t0, t1, t2, t3, t4, t5, t6, t7, c;
          var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
          var h0 = this.h[0], h1 = this.h[1], h2 = this.h[2], h3 = this.h[3], h4 = this.h[4], h5 = this.h[5], h6 = this.h[6], h7 = this.h[7], h8 = this.h[8], h9 = this.h[9];
          var r0 = this.r[0], r1 = this.r[1], r2 = this.r[2], r3 = this.r[3], r4 = this.r[4], r5 = this.r[5], r6 = this.r[6], r7 = this.r[7], r8 = this.r[8], r9 = this.r[9];
          while (bytes >= 16) {
            t0 = m[mpos + 0] & 255 | (m[mpos + 1] & 255) << 8;
            h0 += t0 & 8191;
            t1 = m[mpos + 2] & 255 | (m[mpos + 3] & 255) << 8;
            h1 += (t0 >>> 13 | t1 << 3) & 8191;
            t2 = m[mpos + 4] & 255 | (m[mpos + 5] & 255) << 8;
            h2 += (t1 >>> 10 | t2 << 6) & 8191;
            t3 = m[mpos + 6] & 255 | (m[mpos + 7] & 255) << 8;
            h3 += (t2 >>> 7 | t3 << 9) & 8191;
            t4 = m[mpos + 8] & 255 | (m[mpos + 9] & 255) << 8;
            h4 += (t3 >>> 4 | t4 << 12) & 8191;
            h5 += t4 >>> 1 & 8191;
            t5 = m[mpos + 10] & 255 | (m[mpos + 11] & 255) << 8;
            h6 += (t4 >>> 14 | t5 << 2) & 8191;
            t6 = m[mpos + 12] & 255 | (m[mpos + 13] & 255) << 8;
            h7 += (t5 >>> 11 | t6 << 5) & 8191;
            t7 = m[mpos + 14] & 255 | (m[mpos + 15] & 255) << 8;
            h8 += (t6 >>> 8 | t7 << 8) & 8191;
            h9 += t7 >>> 5 | hibit;
            c = 0;
            d0 = c;
            d0 += h0 * r0;
            d0 += h1 * (5 * r9);
            d0 += h2 * (5 * r8);
            d0 += h3 * (5 * r7);
            d0 += h4 * (5 * r6);
            c = d0 >>> 13;
            d0 &= 8191;
            d0 += h5 * (5 * r5);
            d0 += h6 * (5 * r4);
            d0 += h7 * (5 * r3);
            d0 += h8 * (5 * r2);
            d0 += h9 * (5 * r1);
            c += d0 >>> 13;
            d0 &= 8191;
            d1 = c;
            d1 += h0 * r1;
            d1 += h1 * r0;
            d1 += h2 * (5 * r9);
            d1 += h3 * (5 * r8);
            d1 += h4 * (5 * r7);
            c = d1 >>> 13;
            d1 &= 8191;
            d1 += h5 * (5 * r6);
            d1 += h6 * (5 * r5);
            d1 += h7 * (5 * r4);
            d1 += h8 * (5 * r3);
            d1 += h9 * (5 * r2);
            c += d1 >>> 13;
            d1 &= 8191;
            d2 = c;
            d2 += h0 * r2;
            d2 += h1 * r1;
            d2 += h2 * r0;
            d2 += h3 * (5 * r9);
            d2 += h4 * (5 * r8);
            c = d2 >>> 13;
            d2 &= 8191;
            d2 += h5 * (5 * r7);
            d2 += h6 * (5 * r6);
            d2 += h7 * (5 * r5);
            d2 += h8 * (5 * r4);
            d2 += h9 * (5 * r3);
            c += d2 >>> 13;
            d2 &= 8191;
            d3 = c;
            d3 += h0 * r3;
            d3 += h1 * r2;
            d3 += h2 * r1;
            d3 += h3 * r0;
            d3 += h4 * (5 * r9);
            c = d3 >>> 13;
            d3 &= 8191;
            d3 += h5 * (5 * r8);
            d3 += h6 * (5 * r7);
            d3 += h7 * (5 * r6);
            d3 += h8 * (5 * r5);
            d3 += h9 * (5 * r4);
            c += d3 >>> 13;
            d3 &= 8191;
            d4 = c;
            d4 += h0 * r4;
            d4 += h1 * r3;
            d4 += h2 * r2;
            d4 += h3 * r1;
            d4 += h4 * r0;
            c = d4 >>> 13;
            d4 &= 8191;
            d4 += h5 * (5 * r9);
            d4 += h6 * (5 * r8);
            d4 += h7 * (5 * r7);
            d4 += h8 * (5 * r6);
            d4 += h9 * (5 * r5);
            c += d4 >>> 13;
            d4 &= 8191;
            d5 = c;
            d5 += h0 * r5;
            d5 += h1 * r4;
            d5 += h2 * r3;
            d5 += h3 * r2;
            d5 += h4 * r1;
            c = d5 >>> 13;
            d5 &= 8191;
            d5 += h5 * r0;
            d5 += h6 * (5 * r9);
            d5 += h7 * (5 * r8);
            d5 += h8 * (5 * r7);
            d5 += h9 * (5 * r6);
            c += d5 >>> 13;
            d5 &= 8191;
            d6 = c;
            d6 += h0 * r6;
            d6 += h1 * r5;
            d6 += h2 * r4;
            d6 += h3 * r3;
            d6 += h4 * r2;
            c = d6 >>> 13;
            d6 &= 8191;
            d6 += h5 * r1;
            d6 += h6 * r0;
            d6 += h7 * (5 * r9);
            d6 += h8 * (5 * r8);
            d6 += h9 * (5 * r7);
            c += d6 >>> 13;
            d6 &= 8191;
            d7 = c;
            d7 += h0 * r7;
            d7 += h1 * r6;
            d7 += h2 * r5;
            d7 += h3 * r4;
            d7 += h4 * r3;
            c = d7 >>> 13;
            d7 &= 8191;
            d7 += h5 * r2;
            d7 += h6 * r1;
            d7 += h7 * r0;
            d7 += h8 * (5 * r9);
            d7 += h9 * (5 * r8);
            c += d7 >>> 13;
            d7 &= 8191;
            d8 = c;
            d8 += h0 * r8;
            d8 += h1 * r7;
            d8 += h2 * r6;
            d8 += h3 * r5;
            d8 += h4 * r4;
            c = d8 >>> 13;
            d8 &= 8191;
            d8 += h5 * r3;
            d8 += h6 * r2;
            d8 += h7 * r1;
            d8 += h8 * r0;
            d8 += h9 * (5 * r9);
            c += d8 >>> 13;
            d8 &= 8191;
            d9 = c;
            d9 += h0 * r9;
            d9 += h1 * r8;
            d9 += h2 * r7;
            d9 += h3 * r6;
            d9 += h4 * r5;
            c = d9 >>> 13;
            d9 &= 8191;
            d9 += h5 * r4;
            d9 += h6 * r3;
            d9 += h7 * r2;
            d9 += h8 * r1;
            d9 += h9 * r0;
            c += d9 >>> 13;
            d9 &= 8191;
            c = (c << 2) + c | 0;
            c = c + d0 | 0;
            d0 = c & 8191;
            c = c >>> 13;
            d1 += c;
            h0 = d0;
            h1 = d1;
            h2 = d2;
            h3 = d3;
            h4 = d4;
            h5 = d5;
            h6 = d6;
            h7 = d7;
            h8 = d8;
            h9 = d9;
            mpos += 16;
            bytes -= 16;
          }
          this.h[0] = h0;
          this.h[1] = h1;
          this.h[2] = h2;
          this.h[3] = h3;
          this.h[4] = h4;
          this.h[5] = h5;
          this.h[6] = h6;
          this.h[7] = h7;
          this.h[8] = h8;
          this.h[9] = h9;
        };
        poly1305.prototype.finish = function(mac, macpos) {
          var g = new Uint16Array(10);
          var c, mask, f, i;
          if (this.leftover) {
            i = this.leftover;
            this.buffer[i++] = 1;
            for (; i < 16; i++)
              this.buffer[i] = 0;
            this.fin = 1;
            this.blocks(this.buffer, 0, 16);
          }
          c = this.h[1] >>> 13;
          this.h[1] &= 8191;
          for (i = 2; i < 10; i++) {
            this.h[i] += c;
            c = this.h[i] >>> 13;
            this.h[i] &= 8191;
          }
          this.h[0] += c * 5;
          c = this.h[0] >>> 13;
          this.h[0] &= 8191;
          this.h[1] += c;
          c = this.h[1] >>> 13;
          this.h[1] &= 8191;
          this.h[2] += c;
          g[0] = this.h[0] + 5;
          c = g[0] >>> 13;
          g[0] &= 8191;
          for (i = 1; i < 10; i++) {
            g[i] = this.h[i] + c;
            c = g[i] >>> 13;
            g[i] &= 8191;
          }
          g[9] -= 1 << 13;
          mask = (c ^ 1) - 1;
          for (i = 0; i < 10; i++)
            g[i] &= mask;
          mask = ~mask;
          for (i = 0; i < 10; i++)
            this.h[i] = this.h[i] & mask | g[i];
          this.h[0] = (this.h[0] | this.h[1] << 13) & 65535;
          this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535;
          this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535;
          this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535;
          this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535;
          this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535;
          this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535;
          this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
          f = this.h[0] + this.pad[0];
          this.h[0] = f & 65535;
          for (i = 1; i < 8; i++) {
            f = (this.h[i] + this.pad[i] | 0) + (f >>> 16) | 0;
            this.h[i] = f & 65535;
          }
          mac[macpos + 0] = this.h[0] >>> 0 & 255;
          mac[macpos + 1] = this.h[0] >>> 8 & 255;
          mac[macpos + 2] = this.h[1] >>> 0 & 255;
          mac[macpos + 3] = this.h[1] >>> 8 & 255;
          mac[macpos + 4] = this.h[2] >>> 0 & 255;
          mac[macpos + 5] = this.h[2] >>> 8 & 255;
          mac[macpos + 6] = this.h[3] >>> 0 & 255;
          mac[macpos + 7] = this.h[3] >>> 8 & 255;
          mac[macpos + 8] = this.h[4] >>> 0 & 255;
          mac[macpos + 9] = this.h[4] >>> 8 & 255;
          mac[macpos + 10] = this.h[5] >>> 0 & 255;
          mac[macpos + 11] = this.h[5] >>> 8 & 255;
          mac[macpos + 12] = this.h[6] >>> 0 & 255;
          mac[macpos + 13] = this.h[6] >>> 8 & 255;
          mac[macpos + 14] = this.h[7] >>> 0 & 255;
          mac[macpos + 15] = this.h[7] >>> 8 & 255;
        };
        poly1305.prototype.update = function(m, mpos, bytes) {
          var i, want;
          if (this.leftover) {
            want = 16 - this.leftover;
            if (want > bytes)
              want = bytes;
            for (i = 0; i < want; i++)
              this.buffer[this.leftover + i] = m[mpos + i];
            bytes -= want;
            mpos += want;
            this.leftover += want;
            if (this.leftover < 16)
              return;
            this.blocks(this.buffer, 0, 16);
            this.leftover = 0;
          }
          if (bytes >= 16) {
            want = bytes - bytes % 16;
            this.blocks(m, mpos, want);
            mpos += want;
            bytes -= want;
          }
          if (bytes) {
            for (i = 0; i < bytes; i++)
              this.buffer[this.leftover + i] = m[mpos + i];
            this.leftover += bytes;
          }
        };
        function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
          var s = new poly1305(k);
          s.update(m, mpos, n);
          s.finish(out, outpos);
          return 0;
        }
        function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
          var x = new Uint8Array(16);
          crypto_onetimeauth(x, 0, m, mpos, n, k);
          return crypto_verify_16(h, hpos, x, 0);
        }
        function crypto_secretbox(c, m, d, n, k) {
          var i;
          if (d < 32)
            return -1;
          crypto_stream_xor(c, 0, m, 0, d, n, k);
          crypto_onetimeauth(c, 16, c, 32, d - 32, c);
          for (i = 0; i < 16; i++)
            c[i] = 0;
          return 0;
        }
        function crypto_secretbox_open(m, c, d, n, k) {
          var i;
          var x = new Uint8Array(32);
          if (d < 32)
            return -1;
          crypto_stream(x, 0, 32, n, k);
          if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x) !== 0)
            return -1;
          crypto_stream_xor(m, 0, c, 0, d, n, k);
          for (i = 0; i < 32; i++)
            m[i] = 0;
          return 0;
        }
        function set25519(r, a) {
          var i;
          for (i = 0; i < 16; i++)
            r[i] = a[i] | 0;
        }
        function car25519(o) {
          var i, v, c = 1;
          for (i = 0; i < 16; i++) {
            v = o[i] + c + 65535;
            c = Math.floor(v / 65536);
            o[i] = v - c * 65536;
          }
          o[0] += c - 1 + 37 * (c - 1);
        }
        function sel25519(p, q, b) {
          var t, c = ~(b - 1);
          for (var i = 0; i < 16; i++) {
            t = c & (p[i] ^ q[i]);
            p[i] ^= t;
            q[i] ^= t;
          }
        }
        function pack25519(o, n) {
          var i, j, b;
          var m = gf(), t = gf();
          for (i = 0; i < 16; i++)
            t[i] = n[i];
          car25519(t);
          car25519(t);
          car25519(t);
          for (j = 0; j < 2; j++) {
            m[0] = t[0] - 65517;
            for (i = 1; i < 15; i++) {
              m[i] = t[i] - 65535 - (m[i - 1] >> 16 & 1);
              m[i - 1] &= 65535;
            }
            m[15] = t[15] - 32767 - (m[14] >> 16 & 1);
            b = m[15] >> 16 & 1;
            m[14] &= 65535;
            sel25519(t, m, 1 - b);
          }
          for (i = 0; i < 16; i++) {
            o[2 * i] = t[i] & 255;
            o[2 * i + 1] = t[i] >> 8;
          }
        }
        function neq25519(a, b) {
          var c = new Uint8Array(32), d = new Uint8Array(32);
          pack25519(c, a);
          pack25519(d, b);
          return crypto_verify_32(c, 0, d, 0);
        }
        function par25519(a) {
          var d = new Uint8Array(32);
          pack25519(d, a);
          return d[0] & 1;
        }
        function unpack25519(o, n) {
          var i;
          for (i = 0; i < 16; i++)
            o[i] = n[2 * i] + (n[2 * i + 1] << 8);
          o[15] &= 32767;
        }
        function A(o, a, b) {
          for (var i = 0; i < 16; i++)
            o[i] = a[i] + b[i];
        }
        function Z(o, a, b) {
          for (var i = 0; i < 16; i++)
            o[i] = a[i] - b[i];
        }
        function M(o, a, b) {
          var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
          v = a[0];
          t0 += v * b0;
          t1 += v * b1;
          t2 += v * b2;
          t3 += v * b3;
          t4 += v * b4;
          t5 += v * b5;
          t6 += v * b6;
          t7 += v * b7;
          t8 += v * b8;
          t9 += v * b9;
          t10 += v * b10;
          t11 += v * b11;
          t12 += v * b12;
          t13 += v * b13;
          t14 += v * b14;
          t15 += v * b15;
          v = a[1];
          t1 += v * b0;
          t2 += v * b1;
          t3 += v * b2;
          t4 += v * b3;
          t5 += v * b4;
          t6 += v * b5;
          t7 += v * b6;
          t8 += v * b7;
          t9 += v * b8;
          t10 += v * b9;
          t11 += v * b10;
          t12 += v * b11;
          t13 += v * b12;
          t14 += v * b13;
          t15 += v * b14;
          t16 += v * b15;
          v = a[2];
          t2 += v * b0;
          t3 += v * b1;
          t4 += v * b2;
          t5 += v * b3;
          t6 += v * b4;
          t7 += v * b5;
          t8 += v * b6;
          t9 += v * b7;
          t10 += v * b8;
          t11 += v * b9;
          t12 += v * b10;
          t13 += v * b11;
          t14 += v * b12;
          t15 += v * b13;
          t16 += v * b14;
          t17 += v * b15;
          v = a[3];
          t3 += v * b0;
          t4 += v * b1;
          t5 += v * b2;
          t6 += v * b3;
          t7 += v * b4;
          t8 += v * b5;
          t9 += v * b6;
          t10 += v * b7;
          t11 += v * b8;
          t12 += v * b9;
          t13 += v * b10;
          t14 += v * b11;
          t15 += v * b12;
          t16 += v * b13;
          t17 += v * b14;
          t18 += v * b15;
          v = a[4];
          t4 += v * b0;
          t5 += v * b1;
          t6 += v * b2;
          t7 += v * b3;
          t8 += v * b4;
          t9 += v * b5;
          t10 += v * b6;
          t11 += v * b7;
          t12 += v * b8;
          t13 += v * b9;
          t14 += v * b10;
          t15 += v * b11;
          t16 += v * b12;
          t17 += v * b13;
          t18 += v * b14;
          t19 += v * b15;
          v = a[5];
          t5 += v * b0;
          t6 += v * b1;
          t7 += v * b2;
          t8 += v * b3;
          t9 += v * b4;
          t10 += v * b5;
          t11 += v * b6;
          t12 += v * b7;
          t13 += v * b8;
          t14 += v * b9;
          t15 += v * b10;
          t16 += v * b11;
          t17 += v * b12;
          t18 += v * b13;
          t19 += v * b14;
          t20 += v * b15;
          v = a[6];
          t6 += v * b0;
          t7 += v * b1;
          t8 += v * b2;
          t9 += v * b3;
          t10 += v * b4;
          t11 += v * b5;
          t12 += v * b6;
          t13 += v * b7;
          t14 += v * b8;
          t15 += v * b9;
          t16 += v * b10;
          t17 += v * b11;
          t18 += v * b12;
          t19 += v * b13;
          t20 += v * b14;
          t21 += v * b15;
          v = a[7];
          t7 += v * b0;
          t8 += v * b1;
          t9 += v * b2;
          t10 += v * b3;
          t11 += v * b4;
          t12 += v * b5;
          t13 += v * b6;
          t14 += v * b7;
          t15 += v * b8;
          t16 += v * b9;
          t17 += v * b10;
          t18 += v * b11;
          t19 += v * b12;
          t20 += v * b13;
          t21 += v * b14;
          t22 += v * b15;
          v = a[8];
          t8 += v * b0;
          t9 += v * b1;
          t10 += v * b2;
          t11 += v * b3;
          t12 += v * b4;
          t13 += v * b5;
          t14 += v * b6;
          t15 += v * b7;
          t16 += v * b8;
          t17 += v * b9;
          t18 += v * b10;
          t19 += v * b11;
          t20 += v * b12;
          t21 += v * b13;
          t22 += v * b14;
          t23 += v * b15;
          v = a[9];
          t9 += v * b0;
          t10 += v * b1;
          t11 += v * b2;
          t12 += v * b3;
          t13 += v * b4;
          t14 += v * b5;
          t15 += v * b6;
          t16 += v * b7;
          t17 += v * b8;
          t18 += v * b9;
          t19 += v * b10;
          t20 += v * b11;
          t21 += v * b12;
          t22 += v * b13;
          t23 += v * b14;
          t24 += v * b15;
          v = a[10];
          t10 += v * b0;
          t11 += v * b1;
          t12 += v * b2;
          t13 += v * b3;
          t14 += v * b4;
          t15 += v * b5;
          t16 += v * b6;
          t17 += v * b7;
          t18 += v * b8;
          t19 += v * b9;
          t20 += v * b10;
          t21 += v * b11;
          t22 += v * b12;
          t23 += v * b13;
          t24 += v * b14;
          t25 += v * b15;
          v = a[11];
          t11 += v * b0;
          t12 += v * b1;
          t13 += v * b2;
          t14 += v * b3;
          t15 += v * b4;
          t16 += v * b5;
          t17 += v * b6;
          t18 += v * b7;
          t19 += v * b8;
          t20 += v * b9;
          t21 += v * b10;
          t22 += v * b11;
          t23 += v * b12;
          t24 += v * b13;
          t25 += v * b14;
          t26 += v * b15;
          v = a[12];
          t12 += v * b0;
          t13 += v * b1;
          t14 += v * b2;
          t15 += v * b3;
          t16 += v * b4;
          t17 += v * b5;
          t18 += v * b6;
          t19 += v * b7;
          t20 += v * b8;
          t21 += v * b9;
          t22 += v * b10;
          t23 += v * b11;
          t24 += v * b12;
          t25 += v * b13;
          t26 += v * b14;
          t27 += v * b15;
          v = a[13];
          t13 += v * b0;
          t14 += v * b1;
          t15 += v * b2;
          t16 += v * b3;
          t17 += v * b4;
          t18 += v * b5;
          t19 += v * b6;
          t20 += v * b7;
          t21 += v * b8;
          t22 += v * b9;
          t23 += v * b10;
          t24 += v * b11;
          t25 += v * b12;
          t26 += v * b13;
          t27 += v * b14;
          t28 += v * b15;
          v = a[14];
          t14 += v * b0;
          t15 += v * b1;
          t16 += v * b2;
          t17 += v * b3;
          t18 += v * b4;
          t19 += v * b5;
          t20 += v * b6;
          t21 += v * b7;
          t22 += v * b8;
          t23 += v * b9;
          t24 += v * b10;
          t25 += v * b11;
          t26 += v * b12;
          t27 += v * b13;
          t28 += v * b14;
          t29 += v * b15;
          v = a[15];
          t15 += v * b0;
          t16 += v * b1;
          t17 += v * b2;
          t18 += v * b3;
          t19 += v * b4;
          t20 += v * b5;
          t21 += v * b6;
          t22 += v * b7;
          t23 += v * b8;
          t24 += v * b9;
          t25 += v * b10;
          t26 += v * b11;
          t27 += v * b12;
          t28 += v * b13;
          t29 += v * b14;
          t30 += v * b15;
          t0 += 38 * t16;
          t1 += 38 * t17;
          t2 += 38 * t18;
          t3 += 38 * t19;
          t4 += 38 * t20;
          t5 += 38 * t21;
          t6 += 38 * t22;
          t7 += 38 * t23;
          t8 += 38 * t24;
          t9 += 38 * t25;
          t10 += 38 * t26;
          t11 += 38 * t27;
          t12 += 38 * t28;
          t13 += 38 * t29;
          t14 += 38 * t30;
          c = 1;
          v = t0 + c + 65535;
          c = Math.floor(v / 65536);
          t0 = v - c * 65536;
          v = t1 + c + 65535;
          c = Math.floor(v / 65536);
          t1 = v - c * 65536;
          v = t2 + c + 65535;
          c = Math.floor(v / 65536);
          t2 = v - c * 65536;
          v = t3 + c + 65535;
          c = Math.floor(v / 65536);
          t3 = v - c * 65536;
          v = t4 + c + 65535;
          c = Math.floor(v / 65536);
          t4 = v - c * 65536;
          v = t5 + c + 65535;
          c = Math.floor(v / 65536);
          t5 = v - c * 65536;
          v = t6 + c + 65535;
          c = Math.floor(v / 65536);
          t6 = v - c * 65536;
          v = t7 + c + 65535;
          c = Math.floor(v / 65536);
          t7 = v - c * 65536;
          v = t8 + c + 65535;
          c = Math.floor(v / 65536);
          t8 = v - c * 65536;
          v = t9 + c + 65535;
          c = Math.floor(v / 65536);
          t9 = v - c * 65536;
          v = t10 + c + 65535;
          c = Math.floor(v / 65536);
          t10 = v - c * 65536;
          v = t11 + c + 65535;
          c = Math.floor(v / 65536);
          t11 = v - c * 65536;
          v = t12 + c + 65535;
          c = Math.floor(v / 65536);
          t12 = v - c * 65536;
          v = t13 + c + 65535;
          c = Math.floor(v / 65536);
          t13 = v - c * 65536;
          v = t14 + c + 65535;
          c = Math.floor(v / 65536);
          t14 = v - c * 65536;
          v = t15 + c + 65535;
          c = Math.floor(v / 65536);
          t15 = v - c * 65536;
          t0 += c - 1 + 37 * (c - 1);
          c = 1;
          v = t0 + c + 65535;
          c = Math.floor(v / 65536);
          t0 = v - c * 65536;
          v = t1 + c + 65535;
          c = Math.floor(v / 65536);
          t1 = v - c * 65536;
          v = t2 + c + 65535;
          c = Math.floor(v / 65536);
          t2 = v - c * 65536;
          v = t3 + c + 65535;
          c = Math.floor(v / 65536);
          t3 = v - c * 65536;
          v = t4 + c + 65535;
          c = Math.floor(v / 65536);
          t4 = v - c * 65536;
          v = t5 + c + 65535;
          c = Math.floor(v / 65536);
          t5 = v - c * 65536;
          v = t6 + c + 65535;
          c = Math.floor(v / 65536);
          t6 = v - c * 65536;
          v = t7 + c + 65535;
          c = Math.floor(v / 65536);
          t7 = v - c * 65536;
          v = t8 + c + 65535;
          c = Math.floor(v / 65536);
          t8 = v - c * 65536;
          v = t9 + c + 65535;
          c = Math.floor(v / 65536);
          t9 = v - c * 65536;
          v = t10 + c + 65535;
          c = Math.floor(v / 65536);
          t10 = v - c * 65536;
          v = t11 + c + 65535;
          c = Math.floor(v / 65536);
          t11 = v - c * 65536;
          v = t12 + c + 65535;
          c = Math.floor(v / 65536);
          t12 = v - c * 65536;
          v = t13 + c + 65535;
          c = Math.floor(v / 65536);
          t13 = v - c * 65536;
          v = t14 + c + 65535;
          c = Math.floor(v / 65536);
          t14 = v - c * 65536;
          v = t15 + c + 65535;
          c = Math.floor(v / 65536);
          t15 = v - c * 65536;
          t0 += c - 1 + 37 * (c - 1);
          o[0] = t0;
          o[1] = t1;
          o[2] = t2;
          o[3] = t3;
          o[4] = t4;
          o[5] = t5;
          o[6] = t6;
          o[7] = t7;
          o[8] = t8;
          o[9] = t9;
          o[10] = t10;
          o[11] = t11;
          o[12] = t12;
          o[13] = t13;
          o[14] = t14;
          o[15] = t15;
        }
        function S(o, a) {
          M(o, a, a);
        }
        function inv25519(o, i) {
          var c = gf();
          var a;
          for (a = 0; a < 16; a++)
            c[a] = i[a];
          for (a = 253; a >= 0; a--) {
            S(c, c);
            if (a !== 2 && a !== 4)
              M(c, c, i);
          }
          for (a = 0; a < 16; a++)
            o[a] = c[a];
        }
        function pow2523(o, i) {
          var c = gf();
          var a;
          for (a = 0; a < 16; a++)
            c[a] = i[a];
          for (a = 250; a >= 0; a--) {
            S(c, c);
            if (a !== 1)
              M(c, c, i);
          }
          for (a = 0; a < 16; a++)
            o[a] = c[a];
        }
        function crypto_scalarmult(q, n, p) {
          var z = new Uint8Array(32);
          var x = new Float64Array(80), r, i;
          var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf();
          for (i = 0; i < 31; i++)
            z[i] = n[i];
          z[31] = n[31] & 127 | 64;
          z[0] &= 248;
          unpack25519(x, p);
          for (i = 0; i < 16; i++) {
            b[i] = x[i];
            d[i] = a[i] = c[i] = 0;
          }
          a[0] = d[0] = 1;
          for (i = 254; i >= 0; --i) {
            r = z[i >>> 3] >>> (i & 7) & 1;
            sel25519(a, b, r);
            sel25519(c, d, r);
            A(e, a, c);
            Z(a, a, c);
            A(c, b, d);
            Z(b, b, d);
            S(d, e);
            S(f, a);
            M(a, c, a);
            M(c, b, e);
            A(e, a, c);
            Z(a, a, c);
            S(b, a);
            Z(c, d, f);
            M(a, c, _121665);
            A(a, a, d);
            M(c, c, a);
            M(a, d, f);
            M(d, b, x);
            S(b, e);
            sel25519(a, b, r);
            sel25519(c, d, r);
          }
          for (i = 0; i < 16; i++) {
            x[i + 16] = a[i];
            x[i + 32] = c[i];
            x[i + 48] = b[i];
            x[i + 64] = d[i];
          }
          var x32 = x.subarray(32);
          var x16 = x.subarray(16);
          inv25519(x32, x32);
          M(x16, x16, x32);
          pack25519(q, x16);
          return 0;
        }
        function crypto_scalarmult_base(q, n) {
          return crypto_scalarmult(q, n, _9);
        }
        function crypto_box_keypair(y, x) {
          randombytes(x, 32);
          return crypto_scalarmult_base(y, x);
        }
        function crypto_box_beforenm(k, y, x) {
          var s = new Uint8Array(32);
          crypto_scalarmult(s, x, y);
          return crypto_core_hsalsa20(k, _0, s, sigma);
        }
        var crypto_box_afternm = crypto_secretbox;
        var crypto_box_open_afternm = crypto_secretbox_open;
        function crypto_box(c, m, d, n, y, x) {
          var k = new Uint8Array(32);
          crypto_box_beforenm(k, y, x);
          return crypto_box_afternm(c, m, d, n, k);
        }
        function crypto_box_open(m, c, d, n, y, x) {
          var k = new Uint8Array(32);
          crypto_box_beforenm(k, y, x);
          return crypto_box_open_afternm(m, c, d, n, k);
        }
        var K2 = [
          1116352408,
          3609767458,
          1899447441,
          602891725,
          3049323471,
          3964484399,
          3921009573,
          2173295548,
          961987163,
          4081628472,
          1508970993,
          3053834265,
          2453635748,
          2937671579,
          2870763221,
          3664609560,
          3624381080,
          2734883394,
          310598401,
          1164996542,
          607225278,
          1323610764,
          1426881987,
          3590304994,
          1925078388,
          4068182383,
          2162078206,
          991336113,
          2614888103,
          633803317,
          3248222580,
          3479774868,
          3835390401,
          2666613458,
          4022224774,
          944711139,
          264347078,
          2341262773,
          604807628,
          2007800933,
          770255983,
          1495990901,
          1249150122,
          1856431235,
          1555081692,
          3175218132,
          1996064986,
          2198950837,
          2554220882,
          3999719339,
          2821834349,
          766784016,
          2952996808,
          2566594879,
          3210313671,
          3203337956,
          3336571891,
          1034457026,
          3584528711,
          2466948901,
          113926993,
          3758326383,
          338241895,
          168717936,
          666307205,
          1188179964,
          773529912,
          1546045734,
          1294757372,
          1522805485,
          1396182291,
          2643833823,
          1695183700,
          2343527390,
          1986661051,
          1014477480,
          2177026350,
          1206759142,
          2456956037,
          344077627,
          2730485921,
          1290863460,
          2820302411,
          3158454273,
          3259730800,
          3505952657,
          3345764771,
          106217008,
          3516065817,
          3606008344,
          3600352804,
          1432725776,
          4094571909,
          1467031594,
          275423344,
          851169720,
          430227734,
          3100823752,
          506948616,
          1363258195,
          659060556,
          3750685593,
          883997877,
          3785050280,
          958139571,
          3318307427,
          1322822218,
          3812723403,
          1537002063,
          2003034995,
          1747873779,
          3602036899,
          1955562222,
          1575990012,
          2024104815,
          1125592928,
          2227730452,
          2716904306,
          2361852424,
          442776044,
          2428436474,
          593698344,
          2756734187,
          3733110249,
          3204031479,
          2999351573,
          3329325298,
          3815920427,
          3391569614,
          3928383900,
          3515267271,
          566280711,
          3940187606,
          3454069534,
          4118630271,
          4000239992,
          116418474,
          1914138554,
          174292421,
          2731055270,
          289380356,
          3203993006,
          460393269,
          320620315,
          685471733,
          587496836,
          852142971,
          1086792851,
          1017036298,
          365543100,
          1126000580,
          2618297676,
          1288033470,
          3409855158,
          1501505948,
          4234509866,
          1607167915,
          987167468,
          1816402316,
          1246189591
        ];
        function crypto_hashblocks_hl(hh, hl, m, n) {
          var wh = new Int32Array(16), wl = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i, j, h, l, a, b, c, d;
          var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
          var pos = 0;
          while (n >= 128) {
            for (i = 0; i < 16; i++) {
              j = 8 * i + pos;
              wh[i] = m[j + 0] << 24 | m[j + 1] << 16 | m[j + 2] << 8 | m[j + 3];
              wl[i] = m[j + 4] << 24 | m[j + 5] << 16 | m[j + 6] << 8 | m[j + 7];
            }
            for (i = 0; i < 80; i++) {
              bh0 = ah0;
              bh1 = ah1;
              bh2 = ah2;
              bh3 = ah3;
              bh4 = ah4;
              bh5 = ah5;
              bh6 = ah6;
              bh7 = ah7;
              bl0 = al0;
              bl1 = al1;
              bl2 = al2;
              bl3 = al3;
              bl4 = al4;
              bl5 = al5;
              bl6 = al6;
              bl7 = al7;
              h = ah7;
              l = al7;
              a = l & 65535;
              b = l >>> 16;
              c = h & 65535;
              d = h >>> 16;
              h = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
              l = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
              a += l & 65535;
              b += l >>> 16;
              c += h & 65535;
              d += h >>> 16;
              h = ah4 & ah5 ^ ~ah4 & ah6;
              l = al4 & al5 ^ ~al4 & al6;
              a += l & 65535;
              b += l >>> 16;
              c += h & 65535;
              d += h >>> 16;
              h = K2[i * 2];
              l = K2[i * 2 + 1];
              a += l & 65535;
              b += l >>> 16;
              c += h & 65535;
              d += h >>> 16;
              h = wh[i % 16];
              l = wl[i % 16];
              a += l & 65535;
              b += l >>> 16;
              c += h & 65535;
              d += h >>> 16;
              b += a >>> 16;
              c += b >>> 16;
              d += c >>> 16;
              th = c & 65535 | d << 16;
              tl = a & 65535 | b << 16;
              h = th;
              l = tl;
              a = l & 65535;
              b = l >>> 16;
              c = h & 65535;
              d = h >>> 16;
              h = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
              l = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
              a += l & 65535;
              b += l >>> 16;
              c += h & 65535;
              d += h >>> 16;
              h = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
              l = al0 & al1 ^ al0 & al2 ^ al1 & al2;
              a += l & 65535;
              b += l >>> 16;
              c += h & 65535;
              d += h >>> 16;
              b += a >>> 16;
              c += b >>> 16;
              d += c >>> 16;
              bh7 = c & 65535 | d << 16;
              bl7 = a & 65535 | b << 16;
              h = bh3;
              l = bl3;
              a = l & 65535;
              b = l >>> 16;
              c = h & 65535;
              d = h >>> 16;
              h = th;
              l = tl;
              a += l & 65535;
              b += l >>> 16;
              c += h & 65535;
              d += h >>> 16;
              b += a >>> 16;
              c += b >>> 16;
              d += c >>> 16;
              bh3 = c & 65535 | d << 16;
              bl3 = a & 65535 | b << 16;
              ah1 = bh0;
              ah2 = bh1;
              ah3 = bh2;
              ah4 = bh3;
              ah5 = bh4;
              ah6 = bh5;
              ah7 = bh6;
              ah0 = bh7;
              al1 = bl0;
              al2 = bl1;
              al3 = bl2;
              al4 = bl3;
              al5 = bl4;
              al6 = bl5;
              al7 = bl6;
              al0 = bl7;
              if (i % 16 === 15) {
                for (j = 0; j < 16; j++) {
                  h = wh[j];
                  l = wl[j];
                  a = l & 65535;
                  b = l >>> 16;
                  c = h & 65535;
                  d = h >>> 16;
                  h = wh[(j + 9) % 16];
                  l = wl[(j + 9) % 16];
                  a += l & 65535;
                  b += l >>> 16;
                  c += h & 65535;
                  d += h >>> 16;
                  th = wh[(j + 1) % 16];
                  tl = wl[(j + 1) % 16];
                  h = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
                  l = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
                  a += l & 65535;
                  b += l >>> 16;
                  c += h & 65535;
                  d += h >>> 16;
                  th = wh[(j + 14) % 16];
                  tl = wl[(j + 14) % 16];
                  h = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
                  l = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
                  a += l & 65535;
                  b += l >>> 16;
                  c += h & 65535;
                  d += h >>> 16;
                  b += a >>> 16;
                  c += b >>> 16;
                  d += c >>> 16;
                  wh[j] = c & 65535 | d << 16;
                  wl[j] = a & 65535 | b << 16;
                }
              }
            }
            h = ah0;
            l = al0;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = hh[0];
            l = hl[0];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            hh[0] = ah0 = c & 65535 | d << 16;
            hl[0] = al0 = a & 65535 | b << 16;
            h = ah1;
            l = al1;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = hh[1];
            l = hl[1];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            hh[1] = ah1 = c & 65535 | d << 16;
            hl[1] = al1 = a & 65535 | b << 16;
            h = ah2;
            l = al2;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = hh[2];
            l = hl[2];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            hh[2] = ah2 = c & 65535 | d << 16;
            hl[2] = al2 = a & 65535 | b << 16;
            h = ah3;
            l = al3;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = hh[3];
            l = hl[3];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            hh[3] = ah3 = c & 65535 | d << 16;
            hl[3] = al3 = a & 65535 | b << 16;
            h = ah4;
            l = al4;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = hh[4];
            l = hl[4];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            hh[4] = ah4 = c & 65535 | d << 16;
            hl[4] = al4 = a & 65535 | b << 16;
            h = ah5;
            l = al5;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = hh[5];
            l = hl[5];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            hh[5] = ah5 = c & 65535 | d << 16;
            hl[5] = al5 = a & 65535 | b << 16;
            h = ah6;
            l = al6;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = hh[6];
            l = hl[6];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            hh[6] = ah6 = c & 65535 | d << 16;
            hl[6] = al6 = a & 65535 | b << 16;
            h = ah7;
            l = al7;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = hh[7];
            l = hl[7];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            hh[7] = ah7 = c & 65535 | d << 16;
            hl[7] = al7 = a & 65535 | b << 16;
            pos += 128;
            n -= 128;
          }
          return n;
        }
        function crypto_hash(out, m, n) {
          var hh = new Int32Array(8), hl = new Int32Array(8), x = new Uint8Array(256), i, b = n;
          hh[0] = 1779033703;
          hh[1] = 3144134277;
          hh[2] = 1013904242;
          hh[3] = 2773480762;
          hh[4] = 1359893119;
          hh[5] = 2600822924;
          hh[6] = 528734635;
          hh[7] = 1541459225;
          hl[0] = 4089235720;
          hl[1] = 2227873595;
          hl[2] = 4271175723;
          hl[3] = 1595750129;
          hl[4] = 2917565137;
          hl[5] = 725511199;
          hl[6] = 4215389547;
          hl[7] = 327033209;
          crypto_hashblocks_hl(hh, hl, m, n);
          n %= 128;
          for (i = 0; i < n; i++)
            x[i] = m[b - n + i];
          x[n] = 128;
          n = 256 - 128 * (n < 112 ? 1 : 0);
          x[n - 9] = 0;
          ts64(x, n - 8, b / 536870912 | 0, b << 3);
          crypto_hashblocks_hl(hh, hl, x, n);
          for (i = 0; i < 8; i++)
            ts64(out, 8 * i, hh[i], hl[i]);
          return 0;
        }
        function add(p, q) {
          var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t = gf();
          Z(a, p[1], p[0]);
          Z(t, q[1], q[0]);
          M(a, a, t);
          A(b, p[0], p[1]);
          A(t, q[0], q[1]);
          M(b, b, t);
          M(c, p[3], q[3]);
          M(c, c, D2);
          M(d, p[2], q[2]);
          A(d, d, d);
          Z(e, b, a);
          Z(f, d, c);
          A(g, d, c);
          A(h, b, a);
          M(p[0], e, f);
          M(p[1], h, g);
          M(p[2], g, f);
          M(p[3], e, h);
        }
        function cswap(p, q, b) {
          var i;
          for (i = 0; i < 4; i++) {
            sel25519(p[i], q[i], b);
          }
        }
        function pack(r, p) {
          var tx = gf(), ty = gf(), zi = gf();
          inv25519(zi, p[2]);
          M(tx, p[0], zi);
          M(ty, p[1], zi);
          pack25519(r, ty);
          r[31] ^= par25519(tx) << 7;
        }
        function scalarmult(p, q, s) {
          var b, i;
          set25519(p[0], gf0);
          set25519(p[1], gf1);
          set25519(p[2], gf1);
          set25519(p[3], gf0);
          for (i = 255; i >= 0; --i) {
            b = s[i / 8 | 0] >> (i & 7) & 1;
            cswap(p, q, b);
            add(q, p);
            add(p, p);
            cswap(p, q, b);
          }
        }
        function scalarbase(p, s) {
          var q = [gf(), gf(), gf(), gf()];
          set25519(q[0], X);
          set25519(q[1], Y);
          set25519(q[2], gf1);
          M(q[3], X, Y);
          scalarmult(p, q, s);
        }
        function crypto_sign_keypair(pk, sk, seeded) {
          var d = new Uint8Array(64);
          var p = [gf(), gf(), gf(), gf()];
          var i;
          if (!seeded)
            randombytes(sk, 32);
          crypto_hash(d, sk, 32);
          d[0] &= 248;
          d[31] &= 127;
          d[31] |= 64;
          scalarbase(p, d);
          pack(pk, p);
          for (i = 0; i < 32; i++)
            sk[i + 32] = pk[i];
          return 0;
        }
        var L = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
        function modL(r, x) {
          var carry, i, j, k;
          for (i = 63; i >= 32; --i) {
            carry = 0;
            for (j = i - 32, k = i - 12; j < k; ++j) {
              x[j] += carry - 16 * x[i] * L[j - (i - 32)];
              carry = Math.floor((x[j] + 128) / 256);
              x[j] -= carry * 256;
            }
            x[j] += carry;
            x[i] = 0;
          }
          carry = 0;
          for (j = 0; j < 32; j++) {
            x[j] += carry - (x[31] >> 4) * L[j];
            carry = x[j] >> 8;
            x[j] &= 255;
          }
          for (j = 0; j < 32; j++)
            x[j] -= carry * L[j];
          for (i = 0; i < 32; i++) {
            x[i + 1] += x[i] >> 8;
            r[i] = x[i] & 255;
          }
        }
        function reduce(r) {
          var x = new Float64Array(64), i;
          for (i = 0; i < 64; i++)
            x[i] = r[i];
          for (i = 0; i < 64; i++)
            r[i] = 0;
          modL(r, x);
        }
        function crypto_sign(sm, m, n, sk) {
          var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
          var i, j, x = new Float64Array(64);
          var p = [gf(), gf(), gf(), gf()];
          crypto_hash(d, sk, 32);
          d[0] &= 248;
          d[31] &= 127;
          d[31] |= 64;
          var smlen = n + 64;
          for (i = 0; i < n; i++)
            sm[64 + i] = m[i];
          for (i = 0; i < 32; i++)
            sm[32 + i] = d[32 + i];
          crypto_hash(r, sm.subarray(32), n + 32);
          reduce(r);
          scalarbase(p, r);
          pack(sm, p);
          for (i = 32; i < 64; i++)
            sm[i] = sk[i];
          crypto_hash(h, sm, n + 64);
          reduce(h);
          for (i = 0; i < 64; i++)
            x[i] = 0;
          for (i = 0; i < 32; i++)
            x[i] = r[i];
          for (i = 0; i < 32; i++) {
            for (j = 0; j < 32; j++) {
              x[i + j] += h[i] * d[j];
            }
          }
          modL(sm.subarray(32), x);
          return smlen;
        }
        function unpackneg(r, p) {
          var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
          set25519(r[2], gf1);
          unpack25519(r[1], p);
          S(num, r[1]);
          M(den, num, D);
          Z(num, num, r[2]);
          A(den, r[2], den);
          S(den2, den);
          S(den4, den2);
          M(den6, den4, den2);
          M(t, den6, num);
          M(t, t, den);
          pow2523(t, t);
          M(t, t, num);
          M(t, t, den);
          M(t, t, den);
          M(r[0], t, den);
          S(chk, r[0]);
          M(chk, chk, den);
          if (neq25519(chk, num))
            M(r[0], r[0], I);
          S(chk, r[0]);
          M(chk, chk, den);
          if (neq25519(chk, num))
            return -1;
          if (par25519(r[0]) === p[31] >> 7)
            Z(r[0], gf0, r[0]);
          M(r[3], r[0], r[1]);
          return 0;
        }
        function crypto_sign_open(m, sm, n, pk) {
          var i;
          var t = new Uint8Array(32), h = new Uint8Array(64);
          var p = [gf(), gf(), gf(), gf()], q = [gf(), gf(), gf(), gf()];
          if (n < 64)
            return -1;
          if (unpackneg(q, pk))
            return -1;
          for (i = 0; i < n; i++)
            m[i] = sm[i];
          for (i = 0; i < 32; i++)
            m[i + 32] = pk[i];
          crypto_hash(h, m, n);
          reduce(h);
          scalarmult(p, q, h);
          scalarbase(q, sm.subarray(32));
          add(p, q);
          pack(t, p);
          n -= 64;
          if (crypto_verify_32(sm, 0, t, 0)) {
            for (i = 0; i < n; i++)
              m[i] = 0;
            return -1;
          }
          for (i = 0; i < n; i++)
            m[i] = sm[i + 64];
          return n;
        }
        var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
        nacl2.lowlevel = {
          crypto_core_hsalsa20,
          crypto_stream_xor,
          crypto_stream,
          crypto_stream_salsa20_xor,
          crypto_stream_salsa20,
          crypto_onetimeauth,
          crypto_onetimeauth_verify,
          crypto_verify_16,
          crypto_verify_32,
          crypto_secretbox,
          crypto_secretbox_open,
          crypto_scalarmult,
          crypto_scalarmult_base,
          crypto_box_beforenm,
          crypto_box_afternm,
          crypto_box,
          crypto_box_open,
          crypto_box_keypair,
          crypto_hash,
          crypto_sign,
          crypto_sign_keypair,
          crypto_sign_open,
          crypto_secretbox_KEYBYTES,
          crypto_secretbox_NONCEBYTES,
          crypto_secretbox_ZEROBYTES,
          crypto_secretbox_BOXZEROBYTES,
          crypto_scalarmult_BYTES,
          crypto_scalarmult_SCALARBYTES,
          crypto_box_PUBLICKEYBYTES,
          crypto_box_SECRETKEYBYTES,
          crypto_box_BEFORENMBYTES,
          crypto_box_NONCEBYTES,
          crypto_box_ZEROBYTES,
          crypto_box_BOXZEROBYTES,
          crypto_sign_BYTES,
          crypto_sign_PUBLICKEYBYTES,
          crypto_sign_SECRETKEYBYTES,
          crypto_sign_SEEDBYTES,
          crypto_hash_BYTES,
          gf,
          D,
          L,
          pack25519,
          unpack25519,
          M,
          A,
          S,
          Z,
          pow2523,
          add,
          set25519,
          modL,
          scalarmult,
          scalarbase
        };
        function checkLengths(k, n) {
          if (k.length !== crypto_secretbox_KEYBYTES)
            throw new Error("bad key size");
          if (n.length !== crypto_secretbox_NONCEBYTES)
            throw new Error("bad nonce size");
        }
        function checkBoxLengths(pk, sk) {
          if (pk.length !== crypto_box_PUBLICKEYBYTES)
            throw new Error("bad public key size");
          if (sk.length !== crypto_box_SECRETKEYBYTES)
            throw new Error("bad secret key size");
        }
        function checkArrayTypes() {
          for (var i = 0; i < arguments.length; i++) {
            if (!(arguments[i] instanceof Uint8Array))
              throw new TypeError("unexpected type, use Uint8Array");
          }
        }
        function cleanup(arr) {
          for (var i = 0; i < arr.length; i++)
            arr[i] = 0;
        }
        nacl2.randomBytes = function(n) {
          var b = new Uint8Array(n);
          randombytes(b, n);
          return b;
        };
        nacl2.secretbox = function(msg, nonce, key) {
          checkArrayTypes(msg, nonce, key);
          checkLengths(key, nonce);
          var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
          var c = new Uint8Array(m.length);
          for (var i = 0; i < msg.length; i++)
            m[i + crypto_secretbox_ZEROBYTES] = msg[i];
          crypto_secretbox(c, m, m.length, nonce, key);
          return c.subarray(crypto_secretbox_BOXZEROBYTES);
        };
        nacl2.secretbox.open = function(box, nonce, key) {
          checkArrayTypes(box, nonce, key);
          checkLengths(key, nonce);
          var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
          var m = new Uint8Array(c.length);
          for (var i = 0; i < box.length; i++)
            c[i + crypto_secretbox_BOXZEROBYTES] = box[i];
          if (c.length < 32)
            return null;
          if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0)
            return null;
          return m.subarray(crypto_secretbox_ZEROBYTES);
        };
        nacl2.secretbox.keyLength = crypto_secretbox_KEYBYTES;
        nacl2.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
        nacl2.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
        nacl2.scalarMult = function(n, p) {
          checkArrayTypes(n, p);
          if (n.length !== crypto_scalarmult_SCALARBYTES)
            throw new Error("bad n size");
          if (p.length !== crypto_scalarmult_BYTES)
            throw new Error("bad p size");
          var q = new Uint8Array(crypto_scalarmult_BYTES);
          crypto_scalarmult(q, n, p);
          return q;
        };
        nacl2.scalarMult.base = function(n) {
          checkArrayTypes(n);
          if (n.length !== crypto_scalarmult_SCALARBYTES)
            throw new Error("bad n size");
          var q = new Uint8Array(crypto_scalarmult_BYTES);
          crypto_scalarmult_base(q, n);
          return q;
        };
        nacl2.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
        nacl2.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
        nacl2.box = function(msg, nonce, publicKey, secretKey) {
          var k = nacl2.box.before(publicKey, secretKey);
          return nacl2.secretbox(msg, nonce, k);
        };
        nacl2.box.before = function(publicKey, secretKey) {
          checkArrayTypes(publicKey, secretKey);
          checkBoxLengths(publicKey, secretKey);
          var k = new Uint8Array(crypto_box_BEFORENMBYTES);
          crypto_box_beforenm(k, publicKey, secretKey);
          return k;
        };
        nacl2.box.after = nacl2.secretbox;
        nacl2.box.open = function(msg, nonce, publicKey, secretKey) {
          var k = nacl2.box.before(publicKey, secretKey);
          return nacl2.secretbox.open(msg, nonce, k);
        };
        nacl2.box.open.after = nacl2.secretbox.open;
        nacl2.box.keyPair = function() {
          var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
          var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
          crypto_box_keypair(pk, sk);
          return { publicKey: pk, secretKey: sk };
        };
        nacl2.box.keyPair.fromSecretKey = function(secretKey) {
          checkArrayTypes(secretKey);
          if (secretKey.length !== crypto_box_SECRETKEYBYTES)
            throw new Error("bad secret key size");
          var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
          crypto_scalarmult_base(pk, secretKey);
          return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
        };
        nacl2.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
        nacl2.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
        nacl2.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
        nacl2.box.nonceLength = crypto_box_NONCEBYTES;
        nacl2.box.overheadLength = nacl2.secretbox.overheadLength;
        nacl2.sign = function(msg, secretKey) {
          checkArrayTypes(msg, secretKey);
          if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
            throw new Error("bad secret key size");
          var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
          crypto_sign(signedMsg, msg, msg.length, secretKey);
          return signedMsg;
        };
        nacl2.sign.open = function(signedMsg, publicKey) {
          checkArrayTypes(signedMsg, publicKey);
          if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
            throw new Error("bad public key size");
          var tmp = new Uint8Array(signedMsg.length);
          var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
          if (mlen < 0)
            return null;
          var m = new Uint8Array(mlen);
          for (var i = 0; i < m.length; i++)
            m[i] = tmp[i];
          return m;
        };
        nacl2.sign.detached = function(msg, secretKey) {
          var signedMsg = nacl2.sign(msg, secretKey);
          var sig = new Uint8Array(crypto_sign_BYTES);
          for (var i = 0; i < sig.length; i++)
            sig[i] = signedMsg[i];
          return sig;
        };
        nacl2.sign.detached.verify = function(msg, sig, publicKey) {
          checkArrayTypes(msg, sig, publicKey);
          if (sig.length !== crypto_sign_BYTES)
            throw new Error("bad signature size");
          if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
            throw new Error("bad public key size");
          var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
          var m = new Uint8Array(crypto_sign_BYTES + msg.length);
          var i;
          for (i = 0; i < crypto_sign_BYTES; i++)
            sm[i] = sig[i];
          for (i = 0; i < msg.length; i++)
            sm[i + crypto_sign_BYTES] = msg[i];
          return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;
        };
        nacl2.sign.keyPair = function() {
          var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
          var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
          crypto_sign_keypair(pk, sk);
          return { publicKey: pk, secretKey: sk };
        };
        nacl2.sign.keyPair.fromSecretKey = function(secretKey) {
          checkArrayTypes(secretKey);
          if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
            throw new Error("bad secret key size");
          var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
          for (var i = 0; i < pk.length; i++)
            pk[i] = secretKey[32 + i];
          return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
        };
        nacl2.sign.keyPair.fromSeed = function(seed) {
          checkArrayTypes(seed);
          if (seed.length !== crypto_sign_SEEDBYTES)
            throw new Error("bad seed size");
          var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
          var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
          for (var i = 0; i < 32; i++)
            sk[i] = seed[i];
          crypto_sign_keypair(pk, sk, true);
          return { publicKey: pk, secretKey: sk };
        };
        nacl2.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
        nacl2.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
        nacl2.sign.seedLength = crypto_sign_SEEDBYTES;
        nacl2.sign.signatureLength = crypto_sign_BYTES;
        nacl2.hash = function(msg) {
          checkArrayTypes(msg);
          var h = new Uint8Array(crypto_hash_BYTES);
          crypto_hash(h, msg, msg.length);
          return h;
        };
        nacl2.hash.hashLength = crypto_hash_BYTES;
        nacl2.verify = function(x, y) {
          checkArrayTypes(x, y);
          if (x.length === 0 || y.length === 0)
            return false;
          if (x.length !== y.length)
            return false;
          return vn(x, 0, y, 0, x.length) === 0 ? true : false;
        };
        nacl2.setPRNG = function(fn) {
          randombytes = fn;
        };
        (function() {
          var crypto2 = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
          if (crypto2 && crypto2.getRandomValues) {
            var QUOTA = 65536;
            nacl2.setPRNG(function(x, n) {
              var i, v = new Uint8Array(n);
              for (i = 0; i < n; i += QUOTA) {
                crypto2.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
              }
              for (i = 0; i < n; i++)
                x[i] = v[i];
              cleanup(v);
            });
          } else if (typeof __require !== "undefined") {
            crypto2 = __require("crypto");
            if (crypto2 && crypto2.randomBytes) {
              nacl2.setPRNG(function(x, n) {
                var i, v = crypto2.randomBytes(n);
                for (i = 0; i < n; i++)
                  x[i] = v[i];
                cleanup(v);
              });
            }
          }
        })();
      })(typeof module2 !== "undefined" && module2.exports ? module2.exports : self.nacl = self.nacl || {});
    }
  });

  // node_modules/js-sha512/src/sha512.js
  var require_sha512 = __commonJS({
    "node_modules/js-sha512/src/sha512.js"(exports2, module2) {
      (function() {
        "use strict";
        var INPUT_ERROR = "input is invalid type";
        var FINALIZE_ERROR = "finalize already called";
        var WINDOW2 = typeof window === "object";
        var root2 = WINDOW2 ? window : {};
        if (root2.JS_SHA512_NO_WINDOW) {
          WINDOW2 = false;
        }
        var WEB_WORKER2 = !WINDOW2 && typeof self === "object";
        var NODE_JS2 = !root2.JS_SHA512_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
        if (NODE_JS2) {
          root2 = global;
        } else if (WEB_WORKER2) {
          root2 = self;
        }
        var COMMON_JS2 = !root2.JS_SHA512_NO_COMMON_JS && typeof module2 === "object" && module2.exports;
        var AMD2 = typeof define === "function" && define.amd;
        var ARRAY_BUFFER2 = !root2.JS_SHA512_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
        var HEX_CHARS2 = "0123456789abcdef".split("");
        var EXTRA2 = [-2147483648, 8388608, 32768, 128];
        var SHIFT2 = [24, 16, 8, 0];
        var K2 = [
          1116352408,
          3609767458,
          1899447441,
          602891725,
          3049323471,
          3964484399,
          3921009573,
          2173295548,
          961987163,
          4081628472,
          1508970993,
          3053834265,
          2453635748,
          2937671579,
          2870763221,
          3664609560,
          3624381080,
          2734883394,
          310598401,
          1164996542,
          607225278,
          1323610764,
          1426881987,
          3590304994,
          1925078388,
          4068182383,
          2162078206,
          991336113,
          2614888103,
          633803317,
          3248222580,
          3479774868,
          3835390401,
          2666613458,
          4022224774,
          944711139,
          264347078,
          2341262773,
          604807628,
          2007800933,
          770255983,
          1495990901,
          1249150122,
          1856431235,
          1555081692,
          3175218132,
          1996064986,
          2198950837,
          2554220882,
          3999719339,
          2821834349,
          766784016,
          2952996808,
          2566594879,
          3210313671,
          3203337956,
          3336571891,
          1034457026,
          3584528711,
          2466948901,
          113926993,
          3758326383,
          338241895,
          168717936,
          666307205,
          1188179964,
          773529912,
          1546045734,
          1294757372,
          1522805485,
          1396182291,
          2643833823,
          1695183700,
          2343527390,
          1986661051,
          1014477480,
          2177026350,
          1206759142,
          2456956037,
          344077627,
          2730485921,
          1290863460,
          2820302411,
          3158454273,
          3259730800,
          3505952657,
          3345764771,
          106217008,
          3516065817,
          3606008344,
          3600352804,
          1432725776,
          4094571909,
          1467031594,
          275423344,
          851169720,
          430227734,
          3100823752,
          506948616,
          1363258195,
          659060556,
          3750685593,
          883997877,
          3785050280,
          958139571,
          3318307427,
          1322822218,
          3812723403,
          1537002063,
          2003034995,
          1747873779,
          3602036899,
          1955562222,
          1575990012,
          2024104815,
          1125592928,
          2227730452,
          2716904306,
          2361852424,
          442776044,
          2428436474,
          593698344,
          2756734187,
          3733110249,
          3204031479,
          2999351573,
          3329325298,
          3815920427,
          3391569614,
          3928383900,
          3515267271,
          566280711,
          3940187606,
          3454069534,
          4118630271,
          4000239992,
          116418474,
          1914138554,
          174292421,
          2731055270,
          289380356,
          3203993006,
          460393269,
          320620315,
          685471733,
          587496836,
          852142971,
          1086792851,
          1017036298,
          365543100,
          1126000580,
          2618297676,
          1288033470,
          3409855158,
          1501505948,
          4234509866,
          1607167915,
          987167468,
          1816402316,
          1246189591
        ];
        var OUTPUT_TYPES2 = ["hex", "array", "digest", "arrayBuffer"];
        var blocks2 = [];
        if (root2.JS_SHA512_NO_NODE_JS || !Array.isArray) {
          Array.isArray = function(obj) {
            return Object.prototype.toString.call(obj) === "[object Array]";
          };
        }
        if (ARRAY_BUFFER2 && (root2.JS_SHA512_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
          ArrayBuffer.isView = function(obj) {
            return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
          };
        }
        var createOutputMethod2 = function(outputType, bits) {
          return function(message) {
            return new Sha512(bits, true).update(message)[outputType]();
          };
        };
        var createMethod2 = function(bits) {
          var method2 = createOutputMethod2("hex", bits);
          method2.create = function() {
            return new Sha512(bits);
          };
          method2.update = function(message) {
            return method2.create().update(message);
          };
          for (var i = 0; i < OUTPUT_TYPES2.length; ++i) {
            var type = OUTPUT_TYPES2[i];
            method2[type] = createOutputMethod2(type, bits);
          }
          return method2;
        };
        var createHmacOutputMethod2 = function(outputType, bits) {
          return function(key, message) {
            return new HmacSha512(key, bits, true).update(message)[outputType]();
          };
        };
        var createHmacMethod2 = function(bits) {
          var method2 = createHmacOutputMethod2("hex", bits);
          method2.create = function(key) {
            return new HmacSha512(key, bits);
          };
          method2.update = function(key, message) {
            return method2.create(key).update(message);
          };
          for (var i = 0; i < OUTPUT_TYPES2.length; ++i) {
            var type = OUTPUT_TYPES2[i];
            method2[type] = createHmacOutputMethod2(type, bits);
          }
          return method2;
        };
        function Sha512(bits, sharedMemory) {
          if (sharedMemory) {
            blocks2[0] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = blocks2[16] = blocks2[17] = blocks2[18] = blocks2[19] = blocks2[20] = blocks2[21] = blocks2[22] = blocks2[23] = blocks2[24] = blocks2[25] = blocks2[26] = blocks2[27] = blocks2[28] = blocks2[29] = blocks2[30] = blocks2[31] = blocks2[32] = 0;
            this.blocks = blocks2;
          } else {
            this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
          }
          if (bits == 384) {
            this.h0h = 3418070365;
            this.h0l = 3238371032;
            this.h1h = 1654270250;
            this.h1l = 914150663;
            this.h2h = 2438529370;
            this.h2l = 812702999;
            this.h3h = 355462360;
            this.h3l = 4144912697;
            this.h4h = 1731405415;
            this.h4l = 4290775857;
            this.h5h = 2394180231;
            this.h5l = 1750603025;
            this.h6h = 3675008525;
            this.h6l = 1694076839;
            this.h7h = 1203062813;
            this.h7l = 3204075428;
          } else if (bits == 256) {
            this.h0h = 573645204;
            this.h0l = 4230739756;
            this.h1h = 2673172387;
            this.h1l = 3360449730;
            this.h2h = 596883563;
            this.h2l = 1867755857;
            this.h3h = 2520282905;
            this.h3l = 1497426621;
            this.h4h = 2519219938;
            this.h4l = 2827943907;
            this.h5h = 3193839141;
            this.h5l = 1401305490;
            this.h6h = 721525244;
            this.h6l = 746961066;
            this.h7h = 246885852;
            this.h7l = 2177182882;
          } else if (bits == 224) {
            this.h0h = 2352822216;
            this.h0l = 424955298;
            this.h1h = 1944164710;
            this.h1l = 2312950998;
            this.h2h = 502970286;
            this.h2l = 855612546;
            this.h3h = 1738396948;
            this.h3l = 1479516111;
            this.h4h = 258812777;
            this.h4l = 2077511080;
            this.h5h = 2011393907;
            this.h5l = 79989058;
            this.h6h = 1067287976;
            this.h6l = 1780299464;
            this.h7h = 286451373;
            this.h7l = 2446758561;
          } else {
            this.h0h = 1779033703;
            this.h0l = 4089235720;
            this.h1h = 3144134277;
            this.h1l = 2227873595;
            this.h2h = 1013904242;
            this.h2l = 4271175723;
            this.h3h = 2773480762;
            this.h3l = 1595750129;
            this.h4h = 1359893119;
            this.h4l = 2917565137;
            this.h5h = 2600822924;
            this.h5l = 725511199;
            this.h6h = 528734635;
            this.h6l = 4215389547;
            this.h7h = 1541459225;
            this.h7l = 327033209;
          }
          this.bits = bits;
          this.block = this.start = this.bytes = this.hBytes = 0;
          this.finalized = this.hashed = false;
        }
        Sha512.prototype.update = function(message) {
          if (this.finalized) {
            throw new Error(FINALIZE_ERROR);
          }
          var notString, type = typeof message;
          if (type !== "string") {
            if (type === "object") {
              if (message === null) {
                throw new Error(INPUT_ERROR);
              } else if (ARRAY_BUFFER2 && message.constructor === ArrayBuffer) {
                message = new Uint8Array(message);
              } else if (!Array.isArray(message)) {
                if (!ARRAY_BUFFER2 || !ArrayBuffer.isView(message)) {
                  throw new Error(INPUT_ERROR);
                }
              }
            } else {
              throw new Error(INPUT_ERROR);
            }
            notString = true;
          }
          var code, index = 0, i, length = message.length, blocks3 = this.blocks;
          while (index < length) {
            if (this.hashed) {
              this.hashed = false;
              blocks3[0] = this.block;
              blocks3[1] = blocks3[2] = blocks3[3] = blocks3[4] = blocks3[5] = blocks3[6] = blocks3[7] = blocks3[8] = blocks3[9] = blocks3[10] = blocks3[11] = blocks3[12] = blocks3[13] = blocks3[14] = blocks3[15] = blocks3[16] = blocks3[17] = blocks3[18] = blocks3[19] = blocks3[20] = blocks3[21] = blocks3[22] = blocks3[23] = blocks3[24] = blocks3[25] = blocks3[26] = blocks3[27] = blocks3[28] = blocks3[29] = blocks3[30] = blocks3[31] = blocks3[32] = 0;
            }
            if (notString) {
              for (i = this.start; index < length && i < 128; ++index) {
                blocks3[i >> 2] |= message[index] << SHIFT2[i++ & 3];
              }
            } else {
              for (i = this.start; index < length && i < 128; ++index) {
                code = message.charCodeAt(index);
                if (code < 128) {
                  blocks3[i >> 2] |= code << SHIFT2[i++ & 3];
                } else if (code < 2048) {
                  blocks3[i >> 2] |= (192 | code >> 6) << SHIFT2[i++ & 3];
                  blocks3[i >> 2] |= (128 | code & 63) << SHIFT2[i++ & 3];
                } else if (code < 55296 || code >= 57344) {
                  blocks3[i >> 2] |= (224 | code >> 12) << SHIFT2[i++ & 3];
                  blocks3[i >> 2] |= (128 | code >> 6 & 63) << SHIFT2[i++ & 3];
                  blocks3[i >> 2] |= (128 | code & 63) << SHIFT2[i++ & 3];
                } else {
                  code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                  blocks3[i >> 2] |= (240 | code >> 18) << SHIFT2[i++ & 3];
                  blocks3[i >> 2] |= (128 | code >> 12 & 63) << SHIFT2[i++ & 3];
                  blocks3[i >> 2] |= (128 | code >> 6 & 63) << SHIFT2[i++ & 3];
                  blocks3[i >> 2] |= (128 | code & 63) << SHIFT2[i++ & 3];
                }
              }
            }
            this.lastByteIndex = i;
            this.bytes += i - this.start;
            if (i >= 128) {
              this.block = blocks3[32];
              this.start = i - 128;
              this.hash();
              this.hashed = true;
            } else {
              this.start = i;
            }
          }
          if (this.bytes > 4294967295) {
            this.hBytes += this.bytes / 4294967296 << 0;
            this.bytes = this.bytes % 4294967296;
          }
          return this;
        };
        Sha512.prototype.finalize = function() {
          if (this.finalized) {
            return;
          }
          this.finalized = true;
          var blocks3 = this.blocks, i = this.lastByteIndex;
          blocks3[32] = this.block;
          blocks3[i >> 2] |= EXTRA2[i & 3];
          this.block = blocks3[32];
          if (i >= 112) {
            if (!this.hashed) {
              this.hash();
            }
            blocks3[0] = this.block;
            blocks3[1] = blocks3[2] = blocks3[3] = blocks3[4] = blocks3[5] = blocks3[6] = blocks3[7] = blocks3[8] = blocks3[9] = blocks3[10] = blocks3[11] = blocks3[12] = blocks3[13] = blocks3[14] = blocks3[15] = blocks3[16] = blocks3[17] = blocks3[18] = blocks3[19] = blocks3[20] = blocks3[21] = blocks3[22] = blocks3[23] = blocks3[24] = blocks3[25] = blocks3[26] = blocks3[27] = blocks3[28] = blocks3[29] = blocks3[30] = blocks3[31] = blocks3[32] = 0;
          }
          blocks3[30] = this.hBytes << 3 | this.bytes >>> 29;
          blocks3[31] = this.bytes << 3;
          this.hash();
        };
        Sha512.prototype.hash = function() {
          var h0h = this.h0h, h0l = this.h0l, h1h = this.h1h, h1l = this.h1l, h2h = this.h2h, h2l = this.h2l, h3h = this.h3h, h3l = this.h3l, h4h = this.h4h, h4l = this.h4l, h5h = this.h5h, h5l = this.h5l, h6h = this.h6h, h6l = this.h6l, h7h = this.h7h, h7l = this.h7l, blocks3 = this.blocks, j, s0h, s0l, s1h, s1l, c1, c2, c3, c4, abh, abl, dah, dal, cdh, cdl, bch, bcl, majh, majl, t1h, t1l, t2h, t2l, chh, chl;
          for (j = 32; j < 160; j += 2) {
            t1h = blocks3[j - 30];
            t1l = blocks3[j - 29];
            s0h = (t1h >>> 1 | t1l << 31) ^ (t1h >>> 8 | t1l << 24) ^ t1h >>> 7;
            s0l = (t1l >>> 1 | t1h << 31) ^ (t1l >>> 8 | t1h << 24) ^ (t1l >>> 7 | t1h << 25);
            t1h = blocks3[j - 4];
            t1l = blocks3[j - 3];
            s1h = (t1h >>> 19 | t1l << 13) ^ (t1l >>> 29 | t1h << 3) ^ t1h >>> 6;
            s1l = (t1l >>> 19 | t1h << 13) ^ (t1h >>> 29 | t1l << 3) ^ (t1l >>> 6 | t1h << 26);
            t1h = blocks3[j - 32];
            t1l = blocks3[j - 31];
            t2h = blocks3[j - 14];
            t2l = blocks3[j - 13];
            c1 = (t2l & 65535) + (t1l & 65535) + (s0l & 65535) + (s1l & 65535);
            c2 = (t2l >>> 16) + (t1l >>> 16) + (s0l >>> 16) + (s1l >>> 16) + (c1 >>> 16);
            c3 = (t2h & 65535) + (t1h & 65535) + (s0h & 65535) + (s1h & 65535) + (c2 >>> 16);
            c4 = (t2h >>> 16) + (t1h >>> 16) + (s0h >>> 16) + (s1h >>> 16) + (c3 >>> 16);
            blocks3[j] = c4 << 16 | c3 & 65535;
            blocks3[j + 1] = c2 << 16 | c1 & 65535;
          }
          var ah = h0h, al = h0l, bh = h1h, bl = h1l, ch = h2h, cl = h2l, dh = h3h, dl = h3l, eh = h4h, el = h4l, fh = h5h, fl = h5l, gh = h6h, gl = h6l, hh = h7h, hl = h7l;
          bch = bh & ch;
          bcl = bl & cl;
          for (j = 0; j < 160; j += 8) {
            s0h = (ah >>> 28 | al << 4) ^ (al >>> 2 | ah << 30) ^ (al >>> 7 | ah << 25);
            s0l = (al >>> 28 | ah << 4) ^ (ah >>> 2 | al << 30) ^ (ah >>> 7 | al << 25);
            s1h = (eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (el >>> 9 | eh << 23);
            s1l = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (eh >>> 9 | el << 23);
            abh = ah & bh;
            abl = al & bl;
            majh = abh ^ ah & ch ^ bch;
            majl = abl ^ al & cl ^ bcl;
            chh = eh & fh ^ ~eh & gh;
            chl = el & fl ^ ~el & gl;
            t1h = blocks3[j];
            t1l = blocks3[j + 1];
            t2h = K2[j];
            t2l = K2[j + 1];
            c1 = (t2l & 65535) + (t1l & 65535) + (chl & 65535) + (s1l & 65535) + (hl & 65535);
            c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (hl >>> 16) + (c1 >>> 16);
            c3 = (t2h & 65535) + (t1h & 65535) + (chh & 65535) + (s1h & 65535) + (hh & 65535) + (c2 >>> 16);
            c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (hh >>> 16) + (c3 >>> 16);
            t1h = c4 << 16 | c3 & 65535;
            t1l = c2 << 16 | c1 & 65535;
            c1 = (majl & 65535) + (s0l & 65535);
            c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
            c3 = (majh & 65535) + (s0h & 65535) + (c2 >>> 16);
            c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);
            t2h = c4 << 16 | c3 & 65535;
            t2l = c2 << 16 | c1 & 65535;
            c1 = (dl & 65535) + (t1l & 65535);
            c2 = (dl >>> 16) + (t1l >>> 16) + (c1 >>> 16);
            c3 = (dh & 65535) + (t1h & 65535) + (c2 >>> 16);
            c4 = (dh >>> 16) + (t1h >>> 16) + (c3 >>> 16);
            hh = c4 << 16 | c3 & 65535;
            hl = c2 << 16 | c1 & 65535;
            c1 = (t2l & 65535) + (t1l & 65535);
            c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
            c3 = (t2h & 65535) + (t1h & 65535) + (c2 >>> 16);
            c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);
            dh = c4 << 16 | c3 & 65535;
            dl = c2 << 16 | c1 & 65535;
            s0h = (dh >>> 28 | dl << 4) ^ (dl >>> 2 | dh << 30) ^ (dl >>> 7 | dh << 25);
            s0l = (dl >>> 28 | dh << 4) ^ (dh >>> 2 | dl << 30) ^ (dh >>> 7 | dl << 25);
            s1h = (hh >>> 14 | hl << 18) ^ (hh >>> 18 | hl << 14) ^ (hl >>> 9 | hh << 23);
            s1l = (hl >>> 14 | hh << 18) ^ (hl >>> 18 | hh << 14) ^ (hh >>> 9 | hl << 23);
            dah = dh & ah;
            dal = dl & al;
            majh = dah ^ dh & bh ^ abh;
            majl = dal ^ dl & bl ^ abl;
            chh = hh & eh ^ ~hh & fh;
            chl = hl & el ^ ~hl & fl;
            t1h = blocks3[j + 2];
            t1l = blocks3[j + 3];
            t2h = K2[j + 2];
            t2l = K2[j + 3];
            c1 = (t2l & 65535) + (t1l & 65535) + (chl & 65535) + (s1l & 65535) + (gl & 65535);
            c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (gl >>> 16) + (c1 >>> 16);
            c3 = (t2h & 65535) + (t1h & 65535) + (chh & 65535) + (s1h & 65535) + (gh & 65535) + (c2 >>> 16);
            c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (gh >>> 16) + (c3 >>> 16);
            t1h = c4 << 16 | c3 & 65535;
            t1l = c2 << 16 | c1 & 65535;
            c1 = (majl & 65535) + (s0l & 65535);
            c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
            c3 = (majh & 65535) + (s0h & 65535) + (c2 >>> 16);
            c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);
            t2h = c4 << 16 | c3 & 65535;
            t2l = c2 << 16 | c1 & 65535;
            c1 = (cl & 65535) + (t1l & 65535);
            c2 = (cl >>> 16) + (t1l >>> 16) + (c1 >>> 16);
            c3 = (ch & 65535) + (t1h & 65535) + (c2 >>> 16);
            c4 = (ch >>> 16) + (t1h >>> 16) + (c3 >>> 16);
            gh = c4 << 16 | c3 & 65535;
            gl = c2 << 16 | c1 & 65535;
            c1 = (t2l & 65535) + (t1l & 65535);
            c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
            c3 = (t2h & 65535) + (t1h & 65535) + (c2 >>> 16);
            c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);
            ch = c4 << 16 | c3 & 65535;
            cl = c2 << 16 | c1 & 65535;
            s0h = (ch >>> 28 | cl << 4) ^ (cl >>> 2 | ch << 30) ^ (cl >>> 7 | ch << 25);
            s0l = (cl >>> 28 | ch << 4) ^ (ch >>> 2 | cl << 30) ^ (ch >>> 7 | cl << 25);
            s1h = (gh >>> 14 | gl << 18) ^ (gh >>> 18 | gl << 14) ^ (gl >>> 9 | gh << 23);
            s1l = (gl >>> 14 | gh << 18) ^ (gl >>> 18 | gh << 14) ^ (gh >>> 9 | gl << 23);
            cdh = ch & dh;
            cdl = cl & dl;
            majh = cdh ^ ch & ah ^ dah;
            majl = cdl ^ cl & al ^ dal;
            chh = gh & hh ^ ~gh & eh;
            chl = gl & hl ^ ~gl & el;
            t1h = blocks3[j + 4];
            t1l = blocks3[j + 5];
            t2h = K2[j + 4];
            t2l = K2[j + 5];
            c1 = (t2l & 65535) + (t1l & 65535) + (chl & 65535) + (s1l & 65535) + (fl & 65535);
            c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (fl >>> 16) + (c1 >>> 16);
            c3 = (t2h & 65535) + (t1h & 65535) + (chh & 65535) + (s1h & 65535) + (fh & 65535) + (c2 >>> 16);
            c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (fh >>> 16) + (c3 >>> 16);
            t1h = c4 << 16 | c3 & 65535;
            t1l = c2 << 16 | c1 & 65535;
            c1 = (majl & 65535) + (s0l & 65535);
            c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
            c3 = (majh & 65535) + (s0h & 65535) + (c2 >>> 16);
            c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);
            t2h = c4 << 16 | c3 & 65535;
            t2l = c2 << 16 | c1 & 65535;
            c1 = (bl & 65535) + (t1l & 65535);
            c2 = (bl >>> 16) + (t1l >>> 16) + (c1 >>> 16);
            c3 = (bh & 65535) + (t1h & 65535) + (c2 >>> 16);
            c4 = (bh >>> 16) + (t1h >>> 16) + (c3 >>> 16);
            fh = c4 << 16 | c3 & 65535;
            fl = c2 << 16 | c1 & 65535;
            c1 = (t2l & 65535) + (t1l & 65535);
            c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
            c3 = (t2h & 65535) + (t1h & 65535) + (c2 >>> 16);
            c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);
            bh = c4 << 16 | c3 & 65535;
            bl = c2 << 16 | c1 & 65535;
            s0h = (bh >>> 28 | bl << 4) ^ (bl >>> 2 | bh << 30) ^ (bl >>> 7 | bh << 25);
            s0l = (bl >>> 28 | bh << 4) ^ (bh >>> 2 | bl << 30) ^ (bh >>> 7 | bl << 25);
            s1h = (fh >>> 14 | fl << 18) ^ (fh >>> 18 | fl << 14) ^ (fl >>> 9 | fh << 23);
            s1l = (fl >>> 14 | fh << 18) ^ (fl >>> 18 | fh << 14) ^ (fh >>> 9 | fl << 23);
            bch = bh & ch;
            bcl = bl & cl;
            majh = bch ^ bh & dh ^ cdh;
            majl = bcl ^ bl & dl ^ cdl;
            chh = fh & gh ^ ~fh & hh;
            chl = fl & gl ^ ~fl & hl;
            t1h = blocks3[j + 6];
            t1l = blocks3[j + 7];
            t2h = K2[j + 6];
            t2l = K2[j + 7];
            c1 = (t2l & 65535) + (t1l & 65535) + (chl & 65535) + (s1l & 65535) + (el & 65535);
            c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (el >>> 16) + (c1 >>> 16);
            c3 = (t2h & 65535) + (t1h & 65535) + (chh & 65535) + (s1h & 65535) + (eh & 65535) + (c2 >>> 16);
            c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (eh >>> 16) + (c3 >>> 16);
            t1h = c4 << 16 | c3 & 65535;
            t1l = c2 << 16 | c1 & 65535;
            c1 = (majl & 65535) + (s0l & 65535);
            c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
            c3 = (majh & 65535) + (s0h & 65535) + (c2 >>> 16);
            c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);
            t2h = c4 << 16 | c3 & 65535;
            t2l = c2 << 16 | c1 & 65535;
            c1 = (al & 65535) + (t1l & 65535);
            c2 = (al >>> 16) + (t1l >>> 16) + (c1 >>> 16);
            c3 = (ah & 65535) + (t1h & 65535) + (c2 >>> 16);
            c4 = (ah >>> 16) + (t1h >>> 16) + (c3 >>> 16);
            eh = c4 << 16 | c3 & 65535;
            el = c2 << 16 | c1 & 65535;
            c1 = (t2l & 65535) + (t1l & 65535);
            c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
            c3 = (t2h & 65535) + (t1h & 65535) + (c2 >>> 16);
            c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);
            ah = c4 << 16 | c3 & 65535;
            al = c2 << 16 | c1 & 65535;
          }
          c1 = (h0l & 65535) + (al & 65535);
          c2 = (h0l >>> 16) + (al >>> 16) + (c1 >>> 16);
          c3 = (h0h & 65535) + (ah & 65535) + (c2 >>> 16);
          c4 = (h0h >>> 16) + (ah >>> 16) + (c3 >>> 16);
          this.h0h = c4 << 16 | c3 & 65535;
          this.h0l = c2 << 16 | c1 & 65535;
          c1 = (h1l & 65535) + (bl & 65535);
          c2 = (h1l >>> 16) + (bl >>> 16) + (c1 >>> 16);
          c3 = (h1h & 65535) + (bh & 65535) + (c2 >>> 16);
          c4 = (h1h >>> 16) + (bh >>> 16) + (c3 >>> 16);
          this.h1h = c4 << 16 | c3 & 65535;
          this.h1l = c2 << 16 | c1 & 65535;
          c1 = (h2l & 65535) + (cl & 65535);
          c2 = (h2l >>> 16) + (cl >>> 16) + (c1 >>> 16);
          c3 = (h2h & 65535) + (ch & 65535) + (c2 >>> 16);
          c4 = (h2h >>> 16) + (ch >>> 16) + (c3 >>> 16);
          this.h2h = c4 << 16 | c3 & 65535;
          this.h2l = c2 << 16 | c1 & 65535;
          c1 = (h3l & 65535) + (dl & 65535);
          c2 = (h3l >>> 16) + (dl >>> 16) + (c1 >>> 16);
          c3 = (h3h & 65535) + (dh & 65535) + (c2 >>> 16);
          c4 = (h3h >>> 16) + (dh >>> 16) + (c3 >>> 16);
          this.h3h = c4 << 16 | c3 & 65535;
          this.h3l = c2 << 16 | c1 & 65535;
          c1 = (h4l & 65535) + (el & 65535);
          c2 = (h4l >>> 16) + (el >>> 16) + (c1 >>> 16);
          c3 = (h4h & 65535) + (eh & 65535) + (c2 >>> 16);
          c4 = (h4h >>> 16) + (eh >>> 16) + (c3 >>> 16);
          this.h4h = c4 << 16 | c3 & 65535;
          this.h4l = c2 << 16 | c1 & 65535;
          c1 = (h5l & 65535) + (fl & 65535);
          c2 = (h5l >>> 16) + (fl >>> 16) + (c1 >>> 16);
          c3 = (h5h & 65535) + (fh & 65535) + (c2 >>> 16);
          c4 = (h5h >>> 16) + (fh >>> 16) + (c3 >>> 16);
          this.h5h = c4 << 16 | c3 & 65535;
          this.h5l = c2 << 16 | c1 & 65535;
          c1 = (h6l & 65535) + (gl & 65535);
          c2 = (h6l >>> 16) + (gl >>> 16) + (c1 >>> 16);
          c3 = (h6h & 65535) + (gh & 65535) + (c2 >>> 16);
          c4 = (h6h >>> 16) + (gh >>> 16) + (c3 >>> 16);
          this.h6h = c4 << 16 | c3 & 65535;
          this.h6l = c2 << 16 | c1 & 65535;
          c1 = (h7l & 65535) + (hl & 65535);
          c2 = (h7l >>> 16) + (hl >>> 16) + (c1 >>> 16);
          c3 = (h7h & 65535) + (hh & 65535) + (c2 >>> 16);
          c4 = (h7h >>> 16) + (hh >>> 16) + (c3 >>> 16);
          this.h7h = c4 << 16 | c3 & 65535;
          this.h7l = c2 << 16 | c1 & 65535;
        };
        Sha512.prototype.hex = function() {
          this.finalize();
          var h0h = this.h0h, h0l = this.h0l, h1h = this.h1h, h1l = this.h1l, h2h = this.h2h, h2l = this.h2l, h3h = this.h3h, h3l = this.h3l, h4h = this.h4h, h4l = this.h4l, h5h = this.h5h, h5l = this.h5l, h6h = this.h6h, h6l = this.h6l, h7h = this.h7h, h7l = this.h7l, bits = this.bits;
          var hex = HEX_CHARS2[h0h >> 28 & 15] + HEX_CHARS2[h0h >> 24 & 15] + HEX_CHARS2[h0h >> 20 & 15] + HEX_CHARS2[h0h >> 16 & 15] + HEX_CHARS2[h0h >> 12 & 15] + HEX_CHARS2[h0h >> 8 & 15] + HEX_CHARS2[h0h >> 4 & 15] + HEX_CHARS2[h0h & 15] + HEX_CHARS2[h0l >> 28 & 15] + HEX_CHARS2[h0l >> 24 & 15] + HEX_CHARS2[h0l >> 20 & 15] + HEX_CHARS2[h0l >> 16 & 15] + HEX_CHARS2[h0l >> 12 & 15] + HEX_CHARS2[h0l >> 8 & 15] + HEX_CHARS2[h0l >> 4 & 15] + HEX_CHARS2[h0l & 15] + HEX_CHARS2[h1h >> 28 & 15] + HEX_CHARS2[h1h >> 24 & 15] + HEX_CHARS2[h1h >> 20 & 15] + HEX_CHARS2[h1h >> 16 & 15] + HEX_CHARS2[h1h >> 12 & 15] + HEX_CHARS2[h1h >> 8 & 15] + HEX_CHARS2[h1h >> 4 & 15] + HEX_CHARS2[h1h & 15] + HEX_CHARS2[h1l >> 28 & 15] + HEX_CHARS2[h1l >> 24 & 15] + HEX_CHARS2[h1l >> 20 & 15] + HEX_CHARS2[h1l >> 16 & 15] + HEX_CHARS2[h1l >> 12 & 15] + HEX_CHARS2[h1l >> 8 & 15] + HEX_CHARS2[h1l >> 4 & 15] + HEX_CHARS2[h1l & 15] + HEX_CHARS2[h2h >> 28 & 15] + HEX_CHARS2[h2h >> 24 & 15] + HEX_CHARS2[h2h >> 20 & 15] + HEX_CHARS2[h2h >> 16 & 15] + HEX_CHARS2[h2h >> 12 & 15] + HEX_CHARS2[h2h >> 8 & 15] + HEX_CHARS2[h2h >> 4 & 15] + HEX_CHARS2[h2h & 15] + HEX_CHARS2[h2l >> 28 & 15] + HEX_CHARS2[h2l >> 24 & 15] + HEX_CHARS2[h2l >> 20 & 15] + HEX_CHARS2[h2l >> 16 & 15] + HEX_CHARS2[h2l >> 12 & 15] + HEX_CHARS2[h2l >> 8 & 15] + HEX_CHARS2[h2l >> 4 & 15] + HEX_CHARS2[h2l & 15] + HEX_CHARS2[h3h >> 28 & 15] + HEX_CHARS2[h3h >> 24 & 15] + HEX_CHARS2[h3h >> 20 & 15] + HEX_CHARS2[h3h >> 16 & 15] + HEX_CHARS2[h3h >> 12 & 15] + HEX_CHARS2[h3h >> 8 & 15] + HEX_CHARS2[h3h >> 4 & 15] + HEX_CHARS2[h3h & 15];
          if (bits >= 256) {
            hex += HEX_CHARS2[h3l >> 28 & 15] + HEX_CHARS2[h3l >> 24 & 15] + HEX_CHARS2[h3l >> 20 & 15] + HEX_CHARS2[h3l >> 16 & 15] + HEX_CHARS2[h3l >> 12 & 15] + HEX_CHARS2[h3l >> 8 & 15] + HEX_CHARS2[h3l >> 4 & 15] + HEX_CHARS2[h3l & 15];
          }
          if (bits >= 384) {
            hex += HEX_CHARS2[h4h >> 28 & 15] + HEX_CHARS2[h4h >> 24 & 15] + HEX_CHARS2[h4h >> 20 & 15] + HEX_CHARS2[h4h >> 16 & 15] + HEX_CHARS2[h4h >> 12 & 15] + HEX_CHARS2[h4h >> 8 & 15] + HEX_CHARS2[h4h >> 4 & 15] + HEX_CHARS2[h4h & 15] + HEX_CHARS2[h4l >> 28 & 15] + HEX_CHARS2[h4l >> 24 & 15] + HEX_CHARS2[h4l >> 20 & 15] + HEX_CHARS2[h4l >> 16 & 15] + HEX_CHARS2[h4l >> 12 & 15] + HEX_CHARS2[h4l >> 8 & 15] + HEX_CHARS2[h4l >> 4 & 15] + HEX_CHARS2[h4l & 15] + HEX_CHARS2[h5h >> 28 & 15] + HEX_CHARS2[h5h >> 24 & 15] + HEX_CHARS2[h5h >> 20 & 15] + HEX_CHARS2[h5h >> 16 & 15] + HEX_CHARS2[h5h >> 12 & 15] + HEX_CHARS2[h5h >> 8 & 15] + HEX_CHARS2[h5h >> 4 & 15] + HEX_CHARS2[h5h & 15] + HEX_CHARS2[h5l >> 28 & 15] + HEX_CHARS2[h5l >> 24 & 15] + HEX_CHARS2[h5l >> 20 & 15] + HEX_CHARS2[h5l >> 16 & 15] + HEX_CHARS2[h5l >> 12 & 15] + HEX_CHARS2[h5l >> 8 & 15] + HEX_CHARS2[h5l >> 4 & 15] + HEX_CHARS2[h5l & 15];
          }
          if (bits == 512) {
            hex += HEX_CHARS2[h6h >> 28 & 15] + HEX_CHARS2[h6h >> 24 & 15] + HEX_CHARS2[h6h >> 20 & 15] + HEX_CHARS2[h6h >> 16 & 15] + HEX_CHARS2[h6h >> 12 & 15] + HEX_CHARS2[h6h >> 8 & 15] + HEX_CHARS2[h6h >> 4 & 15] + HEX_CHARS2[h6h & 15] + HEX_CHARS2[h6l >> 28 & 15] + HEX_CHARS2[h6l >> 24 & 15] + HEX_CHARS2[h6l >> 20 & 15] + HEX_CHARS2[h6l >> 16 & 15] + HEX_CHARS2[h6l >> 12 & 15] + HEX_CHARS2[h6l >> 8 & 15] + HEX_CHARS2[h6l >> 4 & 15] + HEX_CHARS2[h6l & 15] + HEX_CHARS2[h7h >> 28 & 15] + HEX_CHARS2[h7h >> 24 & 15] + HEX_CHARS2[h7h >> 20 & 15] + HEX_CHARS2[h7h >> 16 & 15] + HEX_CHARS2[h7h >> 12 & 15] + HEX_CHARS2[h7h >> 8 & 15] + HEX_CHARS2[h7h >> 4 & 15] + HEX_CHARS2[h7h & 15] + HEX_CHARS2[h7l >> 28 & 15] + HEX_CHARS2[h7l >> 24 & 15] + HEX_CHARS2[h7l >> 20 & 15] + HEX_CHARS2[h7l >> 16 & 15] + HEX_CHARS2[h7l >> 12 & 15] + HEX_CHARS2[h7l >> 8 & 15] + HEX_CHARS2[h7l >> 4 & 15] + HEX_CHARS2[h7l & 15];
          }
          return hex;
        };
        Sha512.prototype.toString = Sha512.prototype.hex;
        Sha512.prototype.digest = function() {
          this.finalize();
          var h0h = this.h0h, h0l = this.h0l, h1h = this.h1h, h1l = this.h1l, h2h = this.h2h, h2l = this.h2l, h3h = this.h3h, h3l = this.h3l, h4h = this.h4h, h4l = this.h4l, h5h = this.h5h, h5l = this.h5l, h6h = this.h6h, h6l = this.h6l, h7h = this.h7h, h7l = this.h7l, bits = this.bits;
          var arr = [
            h0h >> 24 & 255,
            h0h >> 16 & 255,
            h0h >> 8 & 255,
            h0h & 255,
            h0l >> 24 & 255,
            h0l >> 16 & 255,
            h0l >> 8 & 255,
            h0l & 255,
            h1h >> 24 & 255,
            h1h >> 16 & 255,
            h1h >> 8 & 255,
            h1h & 255,
            h1l >> 24 & 255,
            h1l >> 16 & 255,
            h1l >> 8 & 255,
            h1l & 255,
            h2h >> 24 & 255,
            h2h >> 16 & 255,
            h2h >> 8 & 255,
            h2h & 255,
            h2l >> 24 & 255,
            h2l >> 16 & 255,
            h2l >> 8 & 255,
            h2l & 255,
            h3h >> 24 & 255,
            h3h >> 16 & 255,
            h3h >> 8 & 255,
            h3h & 255
          ];
          if (bits >= 256) {
            arr.push(h3l >> 24 & 255, h3l >> 16 & 255, h3l >> 8 & 255, h3l & 255);
          }
          if (bits >= 384) {
            arr.push(h4h >> 24 & 255, h4h >> 16 & 255, h4h >> 8 & 255, h4h & 255, h4l >> 24 & 255, h4l >> 16 & 255, h4l >> 8 & 255, h4l & 255, h5h >> 24 & 255, h5h >> 16 & 255, h5h >> 8 & 255, h5h & 255, h5l >> 24 & 255, h5l >> 16 & 255, h5l >> 8 & 255, h5l & 255);
          }
          if (bits == 512) {
            arr.push(h6h >> 24 & 255, h6h >> 16 & 255, h6h >> 8 & 255, h6h & 255, h6l >> 24 & 255, h6l >> 16 & 255, h6l >> 8 & 255, h6l & 255, h7h >> 24 & 255, h7h >> 16 & 255, h7h >> 8 & 255, h7h & 255, h7l >> 24 & 255, h7l >> 16 & 255, h7l >> 8 & 255, h7l & 255);
          }
          return arr;
        };
        Sha512.prototype.array = Sha512.prototype.digest;
        Sha512.prototype.arrayBuffer = function() {
          this.finalize();
          var bits = this.bits;
          var buffer = new ArrayBuffer(bits / 8);
          var dataView = new DataView(buffer);
          dataView.setUint32(0, this.h0h);
          dataView.setUint32(4, this.h0l);
          dataView.setUint32(8, this.h1h);
          dataView.setUint32(12, this.h1l);
          dataView.setUint32(16, this.h2h);
          dataView.setUint32(20, this.h2l);
          dataView.setUint32(24, this.h3h);
          if (bits >= 256) {
            dataView.setUint32(28, this.h3l);
          }
          if (bits >= 384) {
            dataView.setUint32(32, this.h4h);
            dataView.setUint32(36, this.h4l);
            dataView.setUint32(40, this.h5h);
            dataView.setUint32(44, this.h5l);
          }
          if (bits == 512) {
            dataView.setUint32(48, this.h6h);
            dataView.setUint32(52, this.h6l);
            dataView.setUint32(56, this.h7h);
            dataView.setUint32(60, this.h7l);
          }
          return buffer;
        };
        Sha512.prototype.clone = function() {
          var hash = new Sha512(this.bits, false);
          this.copyTo(hash);
          return hash;
        };
        Sha512.prototype.copyTo = function(hash) {
          var i = 0, attrs = [
            "h0h",
            "h0l",
            "h1h",
            "h1l",
            "h2h",
            "h2l",
            "h3h",
            "h3l",
            "h4h",
            "h4l",
            "h5h",
            "h5l",
            "h6h",
            "h6l",
            "h7h",
            "h7l",
            "start",
            "bytes",
            "hBytes",
            "finalized",
            "hashed",
            "lastByteIndex"
          ];
          for (i = 0; i < attrs.length; ++i) {
            hash[attrs[i]] = this[attrs[i]];
          }
          for (i = 0; i < this.blocks.length; ++i) {
            hash.blocks[i] = this.blocks[i];
          }
        };
        function HmacSha512(key, bits, sharedMemory) {
          var notString, type = typeof key;
          if (type !== "string") {
            if (type === "object") {
              if (key === null) {
                throw new Error(INPUT_ERROR);
              } else if (ARRAY_BUFFER2 && key.constructor === ArrayBuffer) {
                key = new Uint8Array(key);
              } else if (!Array.isArray(key)) {
                if (!ARRAY_BUFFER2 || !ArrayBuffer.isView(key)) {
                  throw new Error(INPUT_ERROR);
                }
              }
            } else {
              throw new Error(INPUT_ERROR);
            }
            notString = true;
          }
          var length = key.length;
          if (!notString) {
            var bytes = [], length = key.length, index = 0, code;
            for (var i = 0; i < length; ++i) {
              code = key.charCodeAt(i);
              if (code < 128) {
                bytes[index++] = code;
              } else if (code < 2048) {
                bytes[index++] = 192 | code >> 6;
                bytes[index++] = 128 | code & 63;
              } else if (code < 55296 || code >= 57344) {
                bytes[index++] = 224 | code >> 12;
                bytes[index++] = 128 | code >> 6 & 63;
                bytes[index++] = 128 | code & 63;
              } else {
                code = 65536 + ((code & 1023) << 10 | key.charCodeAt(++i) & 1023);
                bytes[index++] = 240 | code >> 18;
                bytes[index++] = 128 | code >> 12 & 63;
                bytes[index++] = 128 | code >> 6 & 63;
                bytes[index++] = 128 | code & 63;
              }
            }
            key = bytes;
          }
          if (key.length > 128) {
            key = new Sha512(bits, true).update(key).array();
          }
          var oKeyPad = [], iKeyPad = [];
          for (var i = 0; i < 128; ++i) {
            var b = key[i] || 0;
            oKeyPad[i] = 92 ^ b;
            iKeyPad[i] = 54 ^ b;
          }
          Sha512.call(this, bits, sharedMemory);
          this.update(iKeyPad);
          this.oKeyPad = oKeyPad;
          this.inner = true;
          this.sharedMemory = sharedMemory;
        }
        HmacSha512.prototype = new Sha512();
        HmacSha512.prototype.finalize = function() {
          Sha512.prototype.finalize.call(this);
          if (this.inner) {
            this.inner = false;
            var innerHash = this.array();
            Sha512.call(this, this.bits, this.sharedMemory);
            this.update(this.oKeyPad);
            this.update(innerHash);
            Sha512.prototype.finalize.call(this);
          }
        };
        HmacSha512.prototype.clone = function() {
          var hash = new HmacSha512([], this.bits, false);
          this.copyTo(hash);
          hash.inner = this.inner;
          for (var i = 0; i < this.oKeyPad.length; ++i) {
            hash.oKeyPad[i] = this.oKeyPad[i];
          }
          return hash;
        };
        var exports3 = createMethod2(512);
        exports3.sha512 = exports3;
        exports3.sha384 = createMethod2(384);
        exports3.sha512_256 = createMethod2(256);
        exports3.sha512_224 = createMethod2(224);
        exports3.sha512.hmac = createHmacMethod2(512);
        exports3.sha384.hmac = createHmacMethod2(384);
        exports3.sha512_256.hmac = createHmacMethod2(256);
        exports3.sha512_224.hmac = createHmacMethod2(224);
        if (COMMON_JS2) {
          module2.exports = exports3;
        } else {
          root2.sha512 = exports3.sha512;
          root2.sha384 = exports3.sha384;
          root2.sha512_256 = exports3.sha512_256;
          root2.sha512_224 = exports3.sha512_224;
          if (AMD2) {
            define(function() {
              return exports3;
            });
          }
        }
      })();
    }
  });

  // node_modules/algosdk/dist/esm/src/nacl/naclWrappers.js
  var naclWrappers_exports = {};
  __export(naclWrappers_exports, {
    HASH_BYTES_LENGTH: () => HASH_BYTES_LENGTH,
    PUBLIC_KEY_LENGTH: () => PUBLIC_KEY_LENGTH,
    SECRET_KEY_LENGTH: () => SECRET_KEY_LENGTH,
    SEED_BTYES_LENGTH: () => SEED_BTYES_LENGTH,
    bytesEqual: () => bytesEqual,
    genericHash: () => genericHash,
    keyPair: () => keyPair,
    keyPairFromSecretKey: () => keyPairFromSecretKey,
    keyPairFromSeed: () => keyPairFromSeed,
    randomBytes: () => randomBytes,
    sign: () => sign,
    verify: () => verify
  });
  function genericHash(arr) {
    return import_js_sha512.default.sha512_256.array(arr);
  }
  function randomBytes(length) {
    return import_tweetnacl.default.randomBytes(length);
  }
  function keyPairFromSeed(seed) {
    return import_tweetnacl.default.sign.keyPair.fromSeed(seed);
  }
  function keyPair() {
    const seed = randomBytes(import_tweetnacl.default.box.secretKeyLength);
    return keyPairFromSeed(seed);
  }
  function keyPairFromSecretKey(sk) {
    return import_tweetnacl.default.sign.keyPair.fromSecretKey(sk);
  }
  function sign(msg, secretKey) {
    return import_tweetnacl.default.sign.detached(msg, secretKey);
  }
  function bytesEqual(a, b) {
    return import_tweetnacl.default.verify(a, b);
  }
  function verify(message, signature, verifyKey) {
    return import_tweetnacl.default.sign.detached.verify(message, signature, verifyKey);
  }
  var import_tweetnacl, import_js_sha512, PUBLIC_KEY_LENGTH, SECRET_KEY_LENGTH, HASH_BYTES_LENGTH, SEED_BTYES_LENGTH;
  var init_naclWrappers = __esm({
    "node_modules/algosdk/dist/esm/src/nacl/naclWrappers.js"() {
      import_tweetnacl = __toESM(require_nacl_fast());
      import_js_sha512 = __toESM(require_sha512());
      PUBLIC_KEY_LENGTH = import_tweetnacl.default.sign.publicKeyLength;
      SECRET_KEY_LENGTH = import_tweetnacl.default.sign.secretKeyLength;
      HASH_BYTES_LENGTH = 32;
      SEED_BTYES_LENGTH = 32;
    }
  });

  // node_modules/hi-base32/src/base32.js
  var require_base32 = __commonJS({
    "node_modules/hi-base32/src/base32.js"(exports2, module2) {
      (function() {
        "use strict";
        var root2 = typeof window === "object" ? window : {};
        var NODE_JS2 = !root2.HI_BASE32_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
        if (NODE_JS2) {
          root2 = global;
        }
        var COMMON_JS2 = !root2.HI_BASE32_NO_COMMON_JS && typeof module2 === "object" && module2.exports;
        var AMD2 = typeof define === "function" && define.amd;
        var BASE32_ENCODE_CHAR = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567".split("");
        var BASE32_DECODE_CHAR = {
          "A": 0,
          "B": 1,
          "C": 2,
          "D": 3,
          "E": 4,
          "F": 5,
          "G": 6,
          "H": 7,
          "I": 8,
          "J": 9,
          "K": 10,
          "L": 11,
          "M": 12,
          "N": 13,
          "O": 14,
          "P": 15,
          "Q": 16,
          "R": 17,
          "S": 18,
          "T": 19,
          "U": 20,
          "V": 21,
          "W": 22,
          "X": 23,
          "Y": 24,
          "Z": 25,
          "2": 26,
          "3": 27,
          "4": 28,
          "5": 29,
          "6": 30,
          "7": 31
        };
        var blocks2 = [0, 0, 0, 0, 0, 0, 0, 0];
        var throwInvalidUtf8 = function(position, partial) {
          if (partial.length > 10) {
            partial = "..." + partial.substr(-10);
          }
          var err = new Error("Decoded data is not valid UTF-8. Maybe try base32.decode.asBytes()? Partial data after reading " + position + " bytes: " + partial + " <-");
          err.position = position;
          throw err;
        };
        var toUtf8String = function(bytes) {
          var str = "", length = bytes.length, i = 0, followingChars = 0, b, c;
          while (i < length) {
            b = bytes[i++];
            if (b <= 127) {
              str += String.fromCharCode(b);
              continue;
            } else if (b > 191 && b <= 223) {
              c = b & 31;
              followingChars = 1;
            } else if (b <= 239) {
              c = b & 15;
              followingChars = 2;
            } else if (b <= 247) {
              c = b & 7;
              followingChars = 3;
            } else {
              throwInvalidUtf8(i, str);
            }
            for (var j = 0; j < followingChars; ++j) {
              b = bytes[i++];
              if (b < 128 || b > 191) {
                throwInvalidUtf8(i, str);
              }
              c <<= 6;
              c += b & 63;
            }
            if (c >= 55296 && c <= 57343) {
              throwInvalidUtf8(i, str);
            }
            if (c > 1114111) {
              throwInvalidUtf8(i, str);
            }
            if (c <= 65535) {
              str += String.fromCharCode(c);
            } else {
              c -= 65536;
              str += String.fromCharCode((c >> 10) + 55296);
              str += String.fromCharCode((c & 1023) + 56320);
            }
          }
          return str;
        };
        var decodeAsBytes = function(base32Str) {
          if (base32Str === "") {
            return [];
          } else if (!/^[A-Z2-7=]+$/.test(base32Str)) {
            throw new Error("Invalid base32 characters");
          }
          base32Str = base32Str.replace(/=/g, "");
          var v1, v2, v3, v4, v5, v6, v7, v8, bytes = [], index = 0, length = base32Str.length;
          for (var i = 0, count = length >> 3 << 3; i < count; ) {
            v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v6 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v7 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v8 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            bytes[index++] = (v1 << 3 | v2 >>> 2) & 255;
            bytes[index++] = (v2 << 6 | v3 << 1 | v4 >>> 4) & 255;
            bytes[index++] = (v4 << 4 | v5 >>> 1) & 255;
            bytes[index++] = (v5 << 7 | v6 << 2 | v7 >>> 3) & 255;
            bytes[index++] = (v7 << 5 | v8) & 255;
          }
          var remain = length - count;
          if (remain === 2) {
            v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            bytes[index++] = (v1 << 3 | v2 >>> 2) & 255;
          } else if (remain === 4) {
            v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            bytes[index++] = (v1 << 3 | v2 >>> 2) & 255;
            bytes[index++] = (v2 << 6 | v3 << 1 | v4 >>> 4) & 255;
          } else if (remain === 5) {
            v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            bytes[index++] = (v1 << 3 | v2 >>> 2) & 255;
            bytes[index++] = (v2 << 6 | v3 << 1 | v4 >>> 4) & 255;
            bytes[index++] = (v4 << 4 | v5 >>> 1) & 255;
          } else if (remain === 7) {
            v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v6 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v7 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            bytes[index++] = (v1 << 3 | v2 >>> 2) & 255;
            bytes[index++] = (v2 << 6 | v3 << 1 | v4 >>> 4) & 255;
            bytes[index++] = (v4 << 4 | v5 >>> 1) & 255;
            bytes[index++] = (v5 << 7 | v6 << 2 | v7 >>> 3) & 255;
          }
          return bytes;
        };
        var encodeAscii = function(str) {
          var v1, v2, v3, v4, v5, base32Str = "", length = str.length;
          for (var i = 0, count = parseInt(length / 5) * 5; i < count; ) {
            v1 = str.charCodeAt(i++);
            v2 = str.charCodeAt(i++);
            v3 = str.charCodeAt(i++);
            v4 = str.charCodeAt(i++);
            v5 = str.charCodeAt(i++);
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v3 << 1 | v4 >>> 7) & 31] + BASE32_ENCODE_CHAR[v4 >>> 2 & 31] + BASE32_ENCODE_CHAR[(v4 << 3 | v5 >>> 5) & 31] + BASE32_ENCODE_CHAR[v5 & 31];
          }
          var remain = length - count;
          if (remain === 1) {
            v1 = str.charCodeAt(i);
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[v1 << 2 & 31] + "======";
          } else if (remain === 2) {
            v1 = str.charCodeAt(i++);
            v2 = str.charCodeAt(i);
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[v2 << 4 & 31] + "====";
          } else if (remain === 3) {
            v1 = str.charCodeAt(i++);
            v2 = str.charCodeAt(i++);
            v3 = str.charCodeAt(i);
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[v3 << 1 & 31] + "===";
          } else if (remain === 4) {
            v1 = str.charCodeAt(i++);
            v2 = str.charCodeAt(i++);
            v3 = str.charCodeAt(i++);
            v4 = str.charCodeAt(i);
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v3 << 1 | v4 >>> 7) & 31] + BASE32_ENCODE_CHAR[v4 >>> 2 & 31] + BASE32_ENCODE_CHAR[v4 << 3 & 31] + "=";
          }
          return base32Str;
        };
        var encodeUtf8 = function(str) {
          var v1, v2, v3, v4, v5, code, end = false, base32Str = "", index = 0, i, start = 0, bytes = 0, length = str.length;
          if (str === "") {
            return base32Str;
          }
          do {
            blocks2[0] = blocks2[5];
            blocks2[1] = blocks2[6];
            blocks2[2] = blocks2[7];
            for (i = start; index < length && i < 5; ++index) {
              code = str.charCodeAt(index);
              if (code < 128) {
                blocks2[i++] = code;
              } else if (code < 2048) {
                blocks2[i++] = 192 | code >> 6;
                blocks2[i++] = 128 | code & 63;
              } else if (code < 55296 || code >= 57344) {
                blocks2[i++] = 224 | code >> 12;
                blocks2[i++] = 128 | code >> 6 & 63;
                blocks2[i++] = 128 | code & 63;
              } else {
                code = 65536 + ((code & 1023) << 10 | str.charCodeAt(++index) & 1023);
                blocks2[i++] = 240 | code >> 18;
                blocks2[i++] = 128 | code >> 12 & 63;
                blocks2[i++] = 128 | code >> 6 & 63;
                blocks2[i++] = 128 | code & 63;
              }
            }
            bytes += i - start;
            start = i - 5;
            if (index === length) {
              ++index;
            }
            if (index > length && i < 6) {
              end = true;
            }
            v1 = blocks2[0];
            if (i > 4) {
              v2 = blocks2[1];
              v3 = blocks2[2];
              v4 = blocks2[3];
              v5 = blocks2[4];
              base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v3 << 1 | v4 >>> 7) & 31] + BASE32_ENCODE_CHAR[v4 >>> 2 & 31] + BASE32_ENCODE_CHAR[(v4 << 3 | v5 >>> 5) & 31] + BASE32_ENCODE_CHAR[v5 & 31];
            } else if (i === 1) {
              base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[v1 << 2 & 31] + "======";
            } else if (i === 2) {
              v2 = blocks2[1];
              base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[v2 << 4 & 31] + "====";
            } else if (i === 3) {
              v2 = blocks2[1];
              v3 = blocks2[2];
              base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[v3 << 1 & 31] + "===";
            } else {
              v2 = blocks2[1];
              v3 = blocks2[2];
              v4 = blocks2[3];
              base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v3 << 1 | v4 >>> 7) & 31] + BASE32_ENCODE_CHAR[v4 >>> 2 & 31] + BASE32_ENCODE_CHAR[v4 << 3 & 31] + "=";
            }
          } while (!end);
          return base32Str;
        };
        var encodeBytes = function(bytes) {
          var v1, v2, v3, v4, v5, base32Str = "", length = bytes.length;
          for (var i = 0, count = parseInt(length / 5) * 5; i < count; ) {
            v1 = bytes[i++];
            v2 = bytes[i++];
            v3 = bytes[i++];
            v4 = bytes[i++];
            v5 = bytes[i++];
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v3 << 1 | v4 >>> 7) & 31] + BASE32_ENCODE_CHAR[v4 >>> 2 & 31] + BASE32_ENCODE_CHAR[(v4 << 3 | v5 >>> 5) & 31] + BASE32_ENCODE_CHAR[v5 & 31];
          }
          var remain = length - count;
          if (remain === 1) {
            v1 = bytes[i];
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[v1 << 2 & 31] + "======";
          } else if (remain === 2) {
            v1 = bytes[i++];
            v2 = bytes[i];
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[v2 << 4 & 31] + "====";
          } else if (remain === 3) {
            v1 = bytes[i++];
            v2 = bytes[i++];
            v3 = bytes[i];
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[v3 << 1 & 31] + "===";
          } else if (remain === 4) {
            v1 = bytes[i++];
            v2 = bytes[i++];
            v3 = bytes[i++];
            v4 = bytes[i];
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v3 << 1 | v4 >>> 7) & 31] + BASE32_ENCODE_CHAR[v4 >>> 2 & 31] + BASE32_ENCODE_CHAR[v4 << 3 & 31] + "=";
          }
          return base32Str;
        };
        var encode3 = function(input, asciiOnly) {
          var notString = typeof input !== "string";
          if (notString && input.constructor === ArrayBuffer) {
            input = new Uint8Array(input);
          }
          if (notString) {
            return encodeBytes(input);
          } else if (asciiOnly) {
            return encodeAscii(input);
          } else {
            return encodeUtf8(input);
          }
        };
        var decode3 = function(base32Str, asciiOnly) {
          if (!asciiOnly) {
            return toUtf8String(decodeAsBytes(base32Str));
          }
          if (base32Str === "") {
            return "";
          } else if (!/^[A-Z2-7=]+$/.test(base32Str)) {
            throw new Error("Invalid base32 characters");
          }
          var v1, v2, v3, v4, v5, v6, v7, v8, str = "", length = base32Str.indexOf("=");
          if (length === -1) {
            length = base32Str.length;
          }
          for (var i = 0, count = length >> 3 << 3; i < count; ) {
            v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v6 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v7 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v8 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255) + String.fromCharCode((v2 << 6 | v3 << 1 | v4 >>> 4) & 255) + String.fromCharCode((v4 << 4 | v5 >>> 1) & 255) + String.fromCharCode((v5 << 7 | v6 << 2 | v7 >>> 3) & 255) + String.fromCharCode((v7 << 5 | v8) & 255);
          }
          var remain = length - count;
          if (remain === 2) {
            v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255);
          } else if (remain === 4) {
            v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255) + String.fromCharCode((v2 << 6 | v3 << 1 | v4 >>> 4) & 255);
          } else if (remain === 5) {
            v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255) + String.fromCharCode((v2 << 6 | v3 << 1 | v4 >>> 4) & 255) + String.fromCharCode((v4 << 4 | v5 >>> 1) & 255);
          } else if (remain === 7) {
            v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v6 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v7 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255) + String.fromCharCode((v2 << 6 | v3 << 1 | v4 >>> 4) & 255) + String.fromCharCode((v4 << 4 | v5 >>> 1) & 255) + String.fromCharCode((v5 << 7 | v6 << 2 | v7 >>> 3) & 255);
          }
          return str;
        };
        var exports3 = {
          encode: encode3,
          decode: decode3
        };
        decode3.asBytes = decodeAsBytes;
        if (COMMON_JS2) {
          module2.exports = exports3;
        } else {
          root2.base32 = exports3;
          if (AMD2) {
            define(function() {
              return exports3;
            });
          }
        }
      })();
    }
  });

  // node_modules/bignumber.js/bignumber.mjs
  var bignumber_exports = {};
  __export(bignumber_exports, {
    BigNumber: () => BigNumber,
    default: () => bignumber_default
  });
  function clone(configObject) {
    var div, convertBase, parseNumeric, P = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
      prefix: "",
      groupSize: 3,
      secondaryGroupSize: 0,
      groupSeparator: ",",
      decimalSeparator: ".",
      fractionGroupSize: 0,
      fractionGroupSeparator: "\xA0",
      suffix: ""
    }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
    function BigNumber2(v, b) {
      var alphabet, c, caseChanged, e, i, isNum, len, str, x = this;
      if (!(x instanceof BigNumber2))
        return new BigNumber2(v, b);
      if (b == null) {
        if (v && v._isBigNumber === true) {
          x.s = v.s;
          if (!v.c || v.e > MAX_EXP) {
            x.c = x.e = null;
          } else if (v.e < MIN_EXP) {
            x.c = [x.e = 0];
          } else {
            x.e = v.e;
            x.c = v.c.slice();
          }
          return;
        }
        if ((isNum = typeof v == "number") && v * 0 == 0) {
          x.s = 1 / v < 0 ? (v = -v, -1) : 1;
          if (v === ~~v) {
            for (e = 0, i = v; i >= 10; i /= 10, e++)
              ;
            if (e > MAX_EXP) {
              x.c = x.e = null;
            } else {
              x.e = e;
              x.c = [v];
            }
            return;
          }
          str = String(v);
        } else {
          if (!isNumeric.test(str = String(v)))
            return parseNumeric(x, str, isNum);
          x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
        }
        if ((e = str.indexOf(".")) > -1)
          str = str.replace(".", "");
        if ((i = str.search(/e/i)) > 0) {
          if (e < 0)
            e = i;
          e += +str.slice(i + 1);
          str = str.substring(0, i);
        } else if (e < 0) {
          e = str.length;
        }
      } else {
        intCheck(b, 2, ALPHABET.length, "Base");
        if (b == 10 && alphabetHasNormalDecimalDigits) {
          x = new BigNumber2(v);
          return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
        }
        str = String(v);
        if (isNum = typeof v == "number") {
          if (v * 0 != 0)
            return parseNumeric(x, str, isNum, b);
          x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;
          if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
            throw Error(tooManyDigits + v);
          }
        } else {
          x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
        }
        alphabet = ALPHABET.slice(0, b);
        e = i = 0;
        for (len = str.length; i < len; i++) {
          if (alphabet.indexOf(c = str.charAt(i)) < 0) {
            if (c == ".") {
              if (i > e) {
                e = len;
                continue;
              }
            } else if (!caseChanged) {
              if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                caseChanged = true;
                i = -1;
                e = 0;
                continue;
              }
            }
            return parseNumeric(x, String(v), isNum, b);
          }
        }
        isNum = false;
        str = convertBase(str, b, 10, x.s);
        if ((e = str.indexOf(".")) > -1)
          str = str.replace(".", "");
        else
          e = str.length;
      }
      for (i = 0; str.charCodeAt(i) === 48; i++)
        ;
      for (len = str.length; str.charCodeAt(--len) === 48; )
        ;
      if (str = str.slice(i, ++len)) {
        len -= i;
        if (isNum && BigNumber2.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
          throw Error(tooManyDigits + x.s * v);
        }
        if ((e = e - i - 1) > MAX_EXP) {
          x.c = x.e = null;
        } else if (e < MIN_EXP) {
          x.c = [x.e = 0];
        } else {
          x.e = e;
          x.c = [];
          i = (e + 1) % LOG_BASE;
          if (e < 0)
            i += LOG_BASE;
          if (i < len) {
            if (i)
              x.c.push(+str.slice(0, i));
            for (len -= LOG_BASE; i < len; ) {
              x.c.push(+str.slice(i, i += LOG_BASE));
            }
            i = LOG_BASE - (str = str.slice(i)).length;
          } else {
            i -= len;
          }
          for (; i--; str += "0")
            ;
          x.c.push(+str);
        }
      } else {
        x.c = [x.e = 0];
      }
    }
    BigNumber2.clone = clone;
    BigNumber2.ROUND_UP = 0;
    BigNumber2.ROUND_DOWN = 1;
    BigNumber2.ROUND_CEIL = 2;
    BigNumber2.ROUND_FLOOR = 3;
    BigNumber2.ROUND_HALF_UP = 4;
    BigNumber2.ROUND_HALF_DOWN = 5;
    BigNumber2.ROUND_HALF_EVEN = 6;
    BigNumber2.ROUND_HALF_CEIL = 7;
    BigNumber2.ROUND_HALF_FLOOR = 8;
    BigNumber2.EUCLID = 9;
    BigNumber2.config = BigNumber2.set = function(obj) {
      var p, v;
      if (obj != null) {
        if (typeof obj == "object") {
          if (obj.hasOwnProperty(p = "DECIMAL_PLACES")) {
            v = obj[p];
            intCheck(v, 0, MAX, p);
            DECIMAL_PLACES = v;
          }
          if (obj.hasOwnProperty(p = "ROUNDING_MODE")) {
            v = obj[p];
            intCheck(v, 0, 8, p);
            ROUNDING_MODE = v;
          }
          if (obj.hasOwnProperty(p = "EXPONENTIAL_AT")) {
            v = obj[p];
            if (v && v.pop) {
              intCheck(v[0], -MAX, 0, p);
              intCheck(v[1], 0, MAX, p);
              TO_EXP_NEG = v[0];
              TO_EXP_POS = v[1];
            } else {
              intCheck(v, -MAX, MAX, p);
              TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
            }
          }
          if (obj.hasOwnProperty(p = "RANGE")) {
            v = obj[p];
            if (v && v.pop) {
              intCheck(v[0], -MAX, -1, p);
              intCheck(v[1], 1, MAX, p);
              MIN_EXP = v[0];
              MAX_EXP = v[1];
            } else {
              intCheck(v, -MAX, MAX, p);
              if (v) {
                MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
              } else {
                throw Error(bignumberError + p + " cannot be zero: " + v);
              }
            }
          }
          if (obj.hasOwnProperty(p = "CRYPTO")) {
            v = obj[p];
            if (v === !!v) {
              if (v) {
                if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                  CRYPTO = v;
                } else {
                  CRYPTO = !v;
                  throw Error(bignumberError + "crypto unavailable");
                }
              } else {
                CRYPTO = v;
              }
            } else {
              throw Error(bignumberError + p + " not true or false: " + v);
            }
          }
          if (obj.hasOwnProperty(p = "MODULO_MODE")) {
            v = obj[p];
            intCheck(v, 0, 9, p);
            MODULO_MODE = v;
          }
          if (obj.hasOwnProperty(p = "POW_PRECISION")) {
            v = obj[p];
            intCheck(v, 0, MAX, p);
            POW_PRECISION = v;
          }
          if (obj.hasOwnProperty(p = "FORMAT")) {
            v = obj[p];
            if (typeof v == "object")
              FORMAT = v;
            else
              throw Error(bignumberError + p + " not an object: " + v);
          }
          if (obj.hasOwnProperty(p = "ALPHABET")) {
            v = obj[p];
            if (typeof v == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
              alphabetHasNormalDecimalDigits = v.slice(0, 10) == "0123456789";
              ALPHABET = v;
            } else {
              throw Error(bignumberError + p + " invalid: " + v);
            }
          }
        } else {
          throw Error(bignumberError + "Object expected: " + obj);
        }
      }
      return {
        DECIMAL_PLACES,
        ROUNDING_MODE,
        EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
        RANGE: [MIN_EXP, MAX_EXP],
        CRYPTO,
        MODULO_MODE,
        POW_PRECISION,
        FORMAT,
        ALPHABET
      };
    };
    BigNumber2.isBigNumber = function(v) {
      if (!v || v._isBigNumber !== true)
        return false;
      if (!BigNumber2.DEBUG)
        return true;
      var i, n, c = v.c, e = v.e, s = v.s;
      out:
        if ({}.toString.call(c) == "[object Array]") {
          if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
            if (c[0] === 0) {
              if (e === 0 && c.length === 1)
                return true;
              break out;
            }
            i = (e + 1) % LOG_BASE;
            if (i < 1)
              i += LOG_BASE;
            if (String(c[0]).length == i) {
              for (i = 0; i < c.length; i++) {
                n = c[i];
                if (n < 0 || n >= BASE || n !== mathfloor(n))
                  break out;
              }
              if (n !== 0)
                return true;
            }
          }
        } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
          return true;
        }
      throw Error(bignumberError + "Invalid BigNumber: " + v);
    };
    BigNumber2.maximum = BigNumber2.max = function() {
      return maxOrMin(arguments, P.lt);
    };
    BigNumber2.minimum = BigNumber2.min = function() {
      return maxOrMin(arguments, P.gt);
    };
    BigNumber2.random = function() {
      var pow2_53 = 9007199254740992;
      var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
        return mathfloor(Math.random() * pow2_53);
      } : function() {
        return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
      };
      return function(dp) {
        var a, b, e, k, v, i = 0, c = [], rand = new BigNumber2(ONE);
        if (dp == null)
          dp = DECIMAL_PLACES;
        else
          intCheck(dp, 0, MAX);
        k = mathceil(dp / LOG_BASE);
        if (CRYPTO) {
          if (crypto.getRandomValues) {
            a = crypto.getRandomValues(new Uint32Array(k *= 2));
            for (; i < k; ) {
              v = a[i] * 131072 + (a[i + 1] >>> 11);
              if (v >= 9e15) {
                b = crypto.getRandomValues(new Uint32Array(2));
                a[i] = b[0];
                a[i + 1] = b[1];
              } else {
                c.push(v % 1e14);
                i += 2;
              }
            }
            i = k / 2;
          } else if (crypto.randomBytes) {
            a = crypto.randomBytes(k *= 7);
            for (; i < k; ) {
              v = (a[i] & 31) * 281474976710656 + a[i + 1] * 1099511627776 + a[i + 2] * 4294967296 + a[i + 3] * 16777216 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
              if (v >= 9e15) {
                crypto.randomBytes(7).copy(a, i);
              } else {
                c.push(v % 1e14);
                i += 7;
              }
            }
            i = k / 7;
          } else {
            CRYPTO = false;
            throw Error(bignumberError + "crypto unavailable");
          }
        }
        if (!CRYPTO) {
          for (; i < k; ) {
            v = random53bitInt();
            if (v < 9e15)
              c[i++] = v % 1e14;
          }
        }
        k = c[--i];
        dp %= LOG_BASE;
        if (k && dp) {
          v = POWS_TEN[LOG_BASE - dp];
          c[i] = mathfloor(k / v) * v;
        }
        for (; c[i] === 0; c.pop(), i--)
          ;
        if (i < 0) {
          c = [e = 0];
        } else {
          for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE)
            ;
          for (i = 1, v = c[0]; v >= 10; v /= 10, i++)
            ;
          if (i < LOG_BASE)
            e -= LOG_BASE - i;
        }
        rand.e = e;
        rand.c = c;
        return rand;
      };
    }();
    BigNumber2.sum = function() {
      var i = 1, args = arguments, sum = new BigNumber2(args[0]);
      for (; i < args.length; )
        sum = sum.plus(args[i++]);
      return sum;
    };
    convertBase = function() {
      var decimal = "0123456789";
      function toBaseOut(str, baseIn, baseOut, alphabet) {
        var j, arr = [0], arrL, i = 0, len = str.length;
        for (; i < len; ) {
          for (arrL = arr.length; arrL--; arr[arrL] *= baseIn)
            ;
          arr[0] += alphabet.indexOf(str.charAt(i++));
          for (j = 0; j < arr.length; j++) {
            if (arr[j] > baseOut - 1) {
              if (arr[j + 1] == null)
                arr[j + 1] = 0;
              arr[j + 1] += arr[j] / baseOut | 0;
              arr[j] %= baseOut;
            }
          }
        }
        return arr.reverse();
      }
      return function(str, baseIn, baseOut, sign2, callerIsToString) {
        var alphabet, d, e, k, r, x, xc, y, i = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
        if (i >= 0) {
          k = POW_PRECISION;
          POW_PRECISION = 0;
          str = str.replace(".", "");
          y = new BigNumber2(baseIn);
          x = y.pow(str.length - i);
          POW_PRECISION = k;
          y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, "0"), 10, baseOut, decimal);
          y.e = y.c.length;
        }
        xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
        e = k = xc.length;
        for (; xc[--k] == 0; xc.pop())
          ;
        if (!xc[0])
          return alphabet.charAt(0);
        if (i < 0) {
          --e;
        } else {
          x.c = xc;
          x.e = e;
          x.s = sign2;
          x = div(x, y, dp, rm, baseOut);
          xc = x.c;
          r = x.r;
          e = x.e;
        }
        d = e + dp + 1;
        i = xc[d];
        k = baseOut / 2;
        r = r || d < 0 || xc[d + 1] != null;
        r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
        if (d < 1 || !xc[0]) {
          str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
        } else {
          xc.length = d;
          if (r) {
            for (--baseOut; ++xc[--d] > baseOut; ) {
              xc[d] = 0;
              if (!d) {
                ++e;
                xc = [1].concat(xc);
              }
            }
          }
          for (k = xc.length; !xc[--k]; )
            ;
          for (i = 0, str = ""; i <= k; str += alphabet.charAt(xc[i++]))
            ;
          str = toFixedPoint(str, e, alphabet.charAt(0));
        }
        return str;
      };
    }();
    div = function() {
      function multiply(x, k, base) {
        var m, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
        for (x = x.slice(); i--; ) {
          xlo = x[i] % SQRT_BASE;
          xhi = x[i] / SQRT_BASE | 0;
          m = khi * xlo + xhi * klo;
          temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
          carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
          x[i] = temp % base;
        }
        if (carry)
          x = [carry].concat(x);
        return x;
      }
      function compare2(a, b, aL, bL) {
        var i, cmp;
        if (aL != bL) {
          cmp = aL > bL ? 1 : -1;
        } else {
          for (i = cmp = 0; i < aL; i++) {
            if (a[i] != b[i]) {
              cmp = a[i] > b[i] ? 1 : -1;
              break;
            }
          }
        }
        return cmp;
      }
      function subtract(a, b, aL, base) {
        var i = 0;
        for (; aL--; ) {
          a[aL] -= i;
          i = a[aL] < b[aL] ? 1 : 0;
          a[aL] = i * base + a[aL] - b[aL];
        }
        for (; !a[0] && a.length > 1; a.splice(0, 1))
          ;
      }
      return function(x, y, dp, rm, base) {
        var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;
        if (!xc || !xc[0] || !yc || !yc[0]) {
          return new BigNumber2(!x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : xc && xc[0] == 0 || !yc ? s * 0 : s / 0);
        }
        q = new BigNumber2(s);
        qc = q.c = [];
        e = x.e - y.e;
        s = dp + e + 1;
        if (!base) {
          base = BASE;
          e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
          s = s / LOG_BASE | 0;
        }
        for (i = 0; yc[i] == (xc[i] || 0); i++)
          ;
        if (yc[i] > (xc[i] || 0))
          e--;
        if (s < 0) {
          qc.push(1);
          more = true;
        } else {
          xL = xc.length;
          yL = yc.length;
          i = 0;
          s += 2;
          n = mathfloor(base / (yc[0] + 1));
          if (n > 1) {
            yc = multiply(yc, n, base);
            xc = multiply(xc, n, base);
            yL = yc.length;
            xL = xc.length;
          }
          xi = yL;
          rem = xc.slice(0, yL);
          remL = rem.length;
          for (; remL < yL; rem[remL++] = 0)
            ;
          yz = yc.slice();
          yz = [0].concat(yz);
          yc0 = yc[0];
          if (yc[1] >= base / 2)
            yc0++;
          do {
            n = 0;
            cmp = compare2(yc, rem, yL, remL);
            if (cmp < 0) {
              rem0 = rem[0];
              if (yL != remL)
                rem0 = rem0 * base + (rem[1] || 0);
              n = mathfloor(rem0 / yc0);
              if (n > 1) {
                if (n >= base)
                  n = base - 1;
                prod = multiply(yc, n, base);
                prodL = prod.length;
                remL = rem.length;
                while (compare2(prod, rem, prodL, remL) == 1) {
                  n--;
                  subtract(prod, yL < prodL ? yz : yc, prodL, base);
                  prodL = prod.length;
                  cmp = 1;
                }
              } else {
                if (n == 0) {
                  cmp = n = 1;
                }
                prod = yc.slice();
                prodL = prod.length;
              }
              if (prodL < remL)
                prod = [0].concat(prod);
              subtract(rem, prod, remL, base);
              remL = rem.length;
              if (cmp == -1) {
                while (compare2(yc, rem, yL, remL) < 1) {
                  n++;
                  subtract(rem, yL < remL ? yz : yc, remL, base);
                  remL = rem.length;
                }
              }
            } else if (cmp === 0) {
              n++;
              rem = [0];
            }
            qc[i++] = n;
            if (rem[0]) {
              rem[remL++] = xc[xi] || 0;
            } else {
              rem = [xc[xi]];
              remL = 1;
            }
          } while ((xi++ < xL || rem[0] != null) && s--);
          more = rem[0] != null;
          if (!qc[0])
            qc.splice(0, 1);
        }
        if (base == BASE) {
          for (i = 1, s = qc[0]; s >= 10; s /= 10, i++)
            ;
          round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);
        } else {
          q.e = e;
          q.r = +more;
        }
        return q;
      };
    }();
    function format(n, i, rm, id) {
      var c0, e, ne, len, str;
      if (rm == null)
        rm = ROUNDING_MODE;
      else
        intCheck(rm, 0, 8);
      if (!n.c)
        return n.toString();
      c0 = n.c[0];
      ne = n.e;
      if (i == null) {
        str = coeffToString(n.c);
        str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
      } else {
        n = round(new BigNumber2(n), i, rm);
        e = n.e;
        str = coeffToString(n.c);
        len = str.length;
        if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {
          for (; len < i; str += "0", len++)
            ;
          str = toExponential(str, e);
        } else {
          i -= ne;
          str = toFixedPoint(str, e, "0");
          if (e + 1 > len) {
            if (--i > 0)
              for (str += "."; i--; str += "0")
                ;
          } else {
            i += e - len;
            if (i > 0) {
              if (e + 1 == len)
                str += ".";
              for (; i--; str += "0")
                ;
            }
          }
        }
      }
      return n.s < 0 && c0 ? "-" + str : str;
    }
    function maxOrMin(args, method2) {
      var n, i = 1, m = new BigNumber2(args[0]);
      for (; i < args.length; i++) {
        n = new BigNumber2(args[i]);
        if (!n.s) {
          m = n;
          break;
        } else if (method2.call(m, n)) {
          m = n;
        }
      }
      return m;
    }
    function normalise(n, c, e) {
      var i = 1, j = c.length;
      for (; !c[--j]; c.pop())
        ;
      for (j = c[0]; j >= 10; j /= 10, i++)
        ;
      if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
        n.c = n.e = null;
      } else if (e < MIN_EXP) {
        n.c = [n.e = 0];
      } else {
        n.e = e;
        n.c = c;
      }
      return n;
    }
    parseNumeric = function() {
      var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
      return function(x, str, isNum, b) {
        var base, s = isNum ? str : str.replace(whitespaceOrPlus, "");
        if (isInfinityOrNaN.test(s)) {
          x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
        } else {
          if (!isNum) {
            s = s.replace(basePrefix, function(m, p1, p2) {
              base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
              return !b || b == base ? p1 : m;
            });
            if (b) {
              base = b;
              s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
            }
            if (str != s)
              return new BigNumber2(s, base);
          }
          if (BigNumber2.DEBUG) {
            throw Error(bignumberError + "Not a" + (b ? " base " + b : "") + " number: " + str);
          }
          x.s = null;
        }
        x.c = x.e = null;
      };
    }();
    function round(x, sd, rm, r) {
      var d, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;
      if (xc) {
        out: {
          for (d = 1, k = xc[0]; k >= 10; k /= 10, d++)
            ;
          i = sd - d;
          if (i < 0) {
            i += LOG_BASE;
            j = sd;
            n = xc[ni = 0];
            rd = n / pows10[d - j - 1] % 10 | 0;
          } else {
            ni = mathceil((i + 1) / LOG_BASE);
            if (ni >= xc.length) {
              if (r) {
                for (; xc.length <= ni; xc.push(0))
                  ;
                n = rd = 0;
                d = 1;
                i %= LOG_BASE;
                j = i - LOG_BASE + 1;
              } else {
                break out;
              }
            } else {
              n = k = xc[ni];
              for (d = 1; k >= 10; k /= 10, d++)
                ;
              i %= LOG_BASE;
              j = i - LOG_BASE + d;
              rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;
            }
          }
          r = r || sd < 0 || xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
          r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
          if (sd < 1 || !xc[0]) {
            xc.length = 0;
            if (r) {
              sd -= x.e + 1;
              xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
              x.e = -sd || 0;
            } else {
              xc[0] = x.e = 0;
            }
            return x;
          }
          if (i == 0) {
            xc.length = ni;
            k = 1;
            ni--;
          } else {
            xc.length = ni + 1;
            k = pows10[LOG_BASE - i];
            xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
          }
          if (r) {
            for (; ; ) {
              if (ni == 0) {
                for (i = 1, j = xc[0]; j >= 10; j /= 10, i++)
                  ;
                j = xc[0] += k;
                for (k = 1; j >= 10; j /= 10, k++)
                  ;
                if (i != k) {
                  x.e++;
                  if (xc[0] == BASE)
                    xc[0] = 1;
                }
                break;
              } else {
                xc[ni] += k;
                if (xc[ni] != BASE)
                  break;
                xc[ni--] = 0;
                k = 1;
              }
            }
          }
          for (i = xc.length; xc[--i] === 0; xc.pop())
            ;
        }
        if (x.e > MAX_EXP) {
          x.c = x.e = null;
        } else if (x.e < MIN_EXP) {
          x.c = [x.e = 0];
        }
      }
      return x;
    }
    function valueOf(n) {
      var str, e = n.e;
      if (e === null)
        return n.toString();
      str = coeffToString(n.c);
      str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, "0");
      return n.s < 0 ? "-" + str : str;
    }
    P.absoluteValue = P.abs = function() {
      var x = new BigNumber2(this);
      if (x.s < 0)
        x.s = 1;
      return x;
    };
    P.comparedTo = function(y, b) {
      return compare(this, new BigNumber2(y, b));
    };
    P.decimalPlaces = P.dp = function(dp, rm) {
      var c, n, v, x = this;
      if (dp != null) {
        intCheck(dp, 0, MAX);
        if (rm == null)
          rm = ROUNDING_MODE;
        else
          intCheck(rm, 0, 8);
        return round(new BigNumber2(x), dp + x.e + 1, rm);
      }
      if (!(c = x.c))
        return null;
      n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
      if (v = c[v])
        for (; v % 10 == 0; v /= 10, n--)
          ;
      if (n < 0)
        n = 0;
      return n;
    };
    P.dividedBy = P.div = function(y, b) {
      return div(this, new BigNumber2(y, b), DECIMAL_PLACES, ROUNDING_MODE);
    };
    P.dividedToIntegerBy = P.idiv = function(y, b) {
      return div(this, new BigNumber2(y, b), 0, 1);
    };
    P.exponentiatedBy = P.pow = function(n, m) {
      var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;
      n = new BigNumber2(n);
      if (n.c && !n.isInteger()) {
        throw Error(bignumberError + "Exponent not an integer: " + valueOf(n));
      }
      if (m != null)
        m = new BigNumber2(m);
      nIsBig = n.e > 14;
      if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
        y = new BigNumber2(Math.pow(+valueOf(x), nIsBig ? 2 - isOdd(n) : +valueOf(n)));
        return m ? y.mod(m) : y;
      }
      nIsNeg = n.s < 0;
      if (m) {
        if (m.c ? !m.c[0] : !m.s)
          return new BigNumber2(NaN);
        isModExp = !nIsNeg && x.isInteger() && m.isInteger();
        if (isModExp)
          x = x.mod(m);
      } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
        k = x.s < 0 && isOdd(n) ? -0 : 0;
        if (x.e > -1)
          k = 1 / k;
        return new BigNumber2(nIsNeg ? 1 / k : k);
      } else if (POW_PRECISION) {
        k = mathceil(POW_PRECISION / LOG_BASE + 2);
      }
      if (nIsBig) {
        half = new BigNumber2(0.5);
        if (nIsNeg)
          n.s = 1;
        nIsOdd = isOdd(n);
      } else {
        i = Math.abs(+valueOf(n));
        nIsOdd = i % 2;
      }
      y = new BigNumber2(ONE);
      for (; ; ) {
        if (nIsOdd) {
          y = y.times(x);
          if (!y.c)
            break;
          if (k) {
            if (y.c.length > k)
              y.c.length = k;
          } else if (isModExp) {
            y = y.mod(m);
          }
        }
        if (i) {
          i = mathfloor(i / 2);
          if (i === 0)
            break;
          nIsOdd = i % 2;
        } else {
          n = n.times(half);
          round(n, n.e + 1, 1);
          if (n.e > 14) {
            nIsOdd = isOdd(n);
          } else {
            i = +valueOf(n);
            if (i === 0)
              break;
            nIsOdd = i % 2;
          }
        }
        x = x.times(x);
        if (k) {
          if (x.c && x.c.length > k)
            x.c.length = k;
        } else if (isModExp) {
          x = x.mod(m);
        }
      }
      if (isModExp)
        return y;
      if (nIsNeg)
        y = ONE.div(y);
      return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
    };
    P.integerValue = function(rm) {
      var n = new BigNumber2(this);
      if (rm == null)
        rm = ROUNDING_MODE;
      else
        intCheck(rm, 0, 8);
      return round(n, n.e + 1, rm);
    };
    P.isEqualTo = P.eq = function(y, b) {
      return compare(this, new BigNumber2(y, b)) === 0;
    };
    P.isFinite = function() {
      return !!this.c;
    };
    P.isGreaterThan = P.gt = function(y, b) {
      return compare(this, new BigNumber2(y, b)) > 0;
    };
    P.isGreaterThanOrEqualTo = P.gte = function(y, b) {
      return (b = compare(this, new BigNumber2(y, b))) === 1 || b === 0;
    };
    P.isInteger = function() {
      return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
    };
    P.isLessThan = P.lt = function(y, b) {
      return compare(this, new BigNumber2(y, b)) < 0;
    };
    P.isLessThanOrEqualTo = P.lte = function(y, b) {
      return (b = compare(this, new BigNumber2(y, b))) === -1 || b === 0;
    };
    P.isNaN = function() {
      return !this.s;
    };
    P.isNegative = function() {
      return this.s < 0;
    };
    P.isPositive = function() {
      return this.s > 0;
    };
    P.isZero = function() {
      return !!this.c && this.c[0] == 0;
    };
    P.minus = function(y, b) {
      var i, j, t, xLTy, x = this, a = x.s;
      y = new BigNumber2(y, b);
      b = y.s;
      if (!a || !b)
        return new BigNumber2(NaN);
      if (a != b) {
        y.s = -b;
        return x.plus(y);
      }
      var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
      if (!xe || !ye) {
        if (!xc || !yc)
          return xc ? (y.s = -b, y) : new BigNumber2(yc ? x : NaN);
        if (!xc[0] || !yc[0]) {
          return yc[0] ? (y.s = -b, y) : new BigNumber2(xc[0] ? x : ROUNDING_MODE == 3 ? -0 : 0);
        }
      }
      xe = bitFloor(xe);
      ye = bitFloor(ye);
      xc = xc.slice();
      if (a = xe - ye) {
        if (xLTy = a < 0) {
          a = -a;
          t = xc;
        } else {
          ye = xe;
          t = yc;
        }
        t.reverse();
        for (b = a; b--; t.push(0))
          ;
        t.reverse();
      } else {
        j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
        for (a = b = 0; b < j; b++) {
          if (xc[b] != yc[b]) {
            xLTy = xc[b] < yc[b];
            break;
          }
        }
      }
      if (xLTy)
        t = xc, xc = yc, yc = t, y.s = -y.s;
      b = (j = yc.length) - (i = xc.length);
      if (b > 0)
        for (; b--; xc[i++] = 0)
          ;
      b = BASE - 1;
      for (; j > a; ) {
        if (xc[--j] < yc[j]) {
          for (i = j; i && !xc[--i]; xc[i] = b)
            ;
          --xc[i];
          xc[j] += BASE;
        }
        xc[j] -= yc[j];
      }
      for (; xc[0] == 0; xc.splice(0, 1), --ye)
        ;
      if (!xc[0]) {
        y.s = ROUNDING_MODE == 3 ? -1 : 1;
        y.c = [y.e = 0];
        return y;
      }
      return normalise(y, xc, ye);
    };
    P.modulo = P.mod = function(y, b) {
      var q, s, x = this;
      y = new BigNumber2(y, b);
      if (!x.c || !y.s || y.c && !y.c[0]) {
        return new BigNumber2(NaN);
      } else if (!y.c || x.c && !x.c[0]) {
        return new BigNumber2(x);
      }
      if (MODULO_MODE == 9) {
        s = y.s;
        y.s = 1;
        q = div(x, y, 0, 3);
        y.s = s;
        q.s *= s;
      } else {
        q = div(x, y, 0, MODULO_MODE);
      }
      y = x.minus(q.times(y));
      if (!y.c[0] && MODULO_MODE == 1)
        y.s = x.s;
      return y;
    };
    P.multipliedBy = P.times = function(y, b) {
      var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber2(y, b)).c;
      if (!xc || !yc || !xc[0] || !yc[0]) {
        if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
          y.c = y.e = y.s = null;
        } else {
          y.s *= x.s;
          if (!xc || !yc) {
            y.c = y.e = null;
          } else {
            y.c = [0];
            y.e = 0;
          }
        }
        return y;
      }
      e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
      y.s *= x.s;
      xcL = xc.length;
      ycL = yc.length;
      if (xcL < ycL)
        zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i;
      for (i = xcL + ycL, zc = []; i--; zc.push(0))
        ;
      base = BASE;
      sqrtBase = SQRT_BASE;
      for (i = ycL; --i >= 0; ) {
        c = 0;
        ylo = yc[i] % sqrtBase;
        yhi = yc[i] / sqrtBase | 0;
        for (k = xcL, j = i + k; j > i; ) {
          xlo = xc[--k] % sqrtBase;
          xhi = xc[k] / sqrtBase | 0;
          m = yhi * xlo + xhi * ylo;
          xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
          c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
          zc[j--] = xlo % base;
        }
        zc[j] = c;
      }
      if (c) {
        ++e;
      } else {
        zc.splice(0, 1);
      }
      return normalise(y, zc, e);
    };
    P.negated = function() {
      var x = new BigNumber2(this);
      x.s = -x.s || null;
      return x;
    };
    P.plus = function(y, b) {
      var t, x = this, a = x.s;
      y = new BigNumber2(y, b);
      b = y.s;
      if (!a || !b)
        return new BigNumber2(NaN);
      if (a != b) {
        y.s = -b;
        return x.minus(y);
      }
      var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
      if (!xe || !ye) {
        if (!xc || !yc)
          return new BigNumber2(a / 0);
        if (!xc[0] || !yc[0])
          return yc[0] ? y : new BigNumber2(xc[0] ? x : a * 0);
      }
      xe = bitFloor(xe);
      ye = bitFloor(ye);
      xc = xc.slice();
      if (a = xe - ye) {
        if (a > 0) {
          ye = xe;
          t = yc;
        } else {
          a = -a;
          t = xc;
        }
        t.reverse();
        for (; a--; t.push(0))
          ;
        t.reverse();
      }
      a = xc.length;
      b = yc.length;
      if (a - b < 0)
        t = yc, yc = xc, xc = t, b = a;
      for (a = 0; b; ) {
        a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
        xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
      }
      if (a) {
        xc = [a].concat(xc);
        ++ye;
      }
      return normalise(y, xc, ye);
    };
    P.precision = P.sd = function(sd, rm) {
      var c, n, v, x = this;
      if (sd != null && sd !== !!sd) {
        intCheck(sd, 1, MAX);
        if (rm == null)
          rm = ROUNDING_MODE;
        else
          intCheck(rm, 0, 8);
        return round(new BigNumber2(x), sd, rm);
      }
      if (!(c = x.c))
        return null;
      v = c.length - 1;
      n = v * LOG_BASE + 1;
      if (v = c[v]) {
        for (; v % 10 == 0; v /= 10, n--)
          ;
        for (v = c[0]; v >= 10; v /= 10, n++)
          ;
      }
      if (sd && x.e + 1 > n)
        n = x.e + 1;
      return n;
    };
    P.shiftedBy = function(k) {
      intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
      return this.times("1e" + k);
    };
    P.squareRoot = P.sqrt = function() {
      var m, n, r, rep, t, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
      if (s !== 1 || !c || !c[0]) {
        return new BigNumber2(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
      }
      s = Math.sqrt(+valueOf(x));
      if (s == 0 || s == 1 / 0) {
        n = coeffToString(c);
        if ((n.length + e) % 2 == 0)
          n += "0";
        s = Math.sqrt(+n);
        e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
        if (s == 1 / 0) {
          n = "5e" + e;
        } else {
          n = s.toExponential();
          n = n.slice(0, n.indexOf("e") + 1) + e;
        }
        r = new BigNumber2(n);
      } else {
        r = new BigNumber2(s + "");
      }
      if (r.c[0]) {
        e = r.e;
        s = e + dp;
        if (s < 3)
          s = 0;
        for (; ; ) {
          t = r;
          r = half.times(t.plus(div(x, t, dp, 1)));
          if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
            if (r.e < e)
              --s;
            n = n.slice(s - 3, s + 1);
            if (n == "9999" || !rep && n == "4999") {
              if (!rep) {
                round(t, t.e + DECIMAL_PLACES + 2, 0);
                if (t.times(t).eq(x)) {
                  r = t;
                  break;
                }
              }
              dp += 4;
              s += 4;
              rep = 1;
            } else {
              if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                round(r, r.e + DECIMAL_PLACES + 2, 1);
                m = !r.times(r).eq(x);
              }
              break;
            }
          }
        }
      }
      return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
    };
    P.toExponential = function(dp, rm) {
      if (dp != null) {
        intCheck(dp, 0, MAX);
        dp++;
      }
      return format(this, dp, rm, 1);
    };
    P.toFixed = function(dp, rm) {
      if (dp != null) {
        intCheck(dp, 0, MAX);
        dp = dp + this.e + 1;
      }
      return format(this, dp, rm);
    };
    P.toFormat = function(dp, rm, format2) {
      var str, x = this;
      if (format2 == null) {
        if (dp != null && rm && typeof rm == "object") {
          format2 = rm;
          rm = null;
        } else if (dp && typeof dp == "object") {
          format2 = dp;
          dp = rm = null;
        } else {
          format2 = FORMAT;
        }
      } else if (typeof format2 != "object") {
        throw Error(bignumberError + "Argument not an object: " + format2);
      }
      str = x.toFixed(dp, rm);
      if (x.c) {
        var i, arr = str.split("."), g1 = +format2.groupSize, g2 = +format2.secondaryGroupSize, groupSeparator = format2.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
        if (g2)
          i = g1, g1 = g2, g2 = i, len -= i;
        if (g1 > 0 && len > 0) {
          i = len % g1 || g1;
          intPart = intDigits.substr(0, i);
          for (; i < len; i += g1)
            intPart += groupSeparator + intDigits.substr(i, g1);
          if (g2 > 0)
            intPart += groupSeparator + intDigits.slice(i);
          if (isNeg)
            intPart = "-" + intPart;
        }
        str = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g2 = +format2.fractionGroupSize) ? fractionPart.replace(new RegExp("\\d{" + g2 + "}\\B", "g"), "$&" + (format2.fractionGroupSeparator || "")) : fractionPart) : intPart;
      }
      return (format2.prefix || "") + str + (format2.suffix || "");
    };
    P.toFraction = function(md) {
      var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s, x = this, xc = x.c;
      if (md != null) {
        n = new BigNumber2(md);
        if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
          throw Error(bignumberError + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n));
        }
      }
      if (!xc)
        return new BigNumber2(x);
      d = new BigNumber2(ONE);
      n1 = d0 = new BigNumber2(ONE);
      d1 = n0 = new BigNumber2(ONE);
      s = coeffToString(xc);
      e = d.e = s.length - x.e - 1;
      d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
      md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;
      exp = MAX_EXP;
      MAX_EXP = 1 / 0;
      n = new BigNumber2(s);
      n0.c[0] = 0;
      for (; ; ) {
        q = div(n, d, 0, 1);
        d2 = d0.plus(q.times(d1));
        if (d2.comparedTo(md) == 1)
          break;
        d0 = d1;
        d1 = d2;
        n1 = n0.plus(q.times(d2 = n1));
        n0 = d2;
        d = n.minus(q.times(d2 = d));
        n = d2;
      }
      d2 = div(md.minus(d0), d1, 0, 1);
      n0 = n0.plus(d2.times(n1));
      d0 = d0.plus(d2.times(d1));
      n0.s = n1.s = x.s;
      e = e * 2;
      r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];
      MAX_EXP = exp;
      return r;
    };
    P.toNumber = function() {
      return +valueOf(this);
    };
    P.toPrecision = function(sd, rm) {
      if (sd != null)
        intCheck(sd, 1, MAX);
      return format(this, sd, rm, 2);
    };
    P.toString = function(b) {
      var str, n = this, s = n.s, e = n.e;
      if (e === null) {
        if (s) {
          str = "Infinity";
          if (s < 0)
            str = "-" + str;
        } else {
          str = "NaN";
        }
      } else {
        if (b == null) {
          str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, "0");
        } else if (b === 10 && alphabetHasNormalDecimalDigits) {
          n = round(new BigNumber2(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
          str = toFixedPoint(coeffToString(n.c), n.e, "0");
        } else {
          intCheck(b, 2, ALPHABET.length, "Base");
          str = convertBase(toFixedPoint(coeffToString(n.c), e, "0"), 10, b, s, true);
        }
        if (s < 0 && n.c[0])
          str = "-" + str;
      }
      return str;
    };
    P.valueOf = P.toJSON = function() {
      return valueOf(this);
    };
    P._isBigNumber = true;
    P[Symbol.toStringTag] = "BigNumber";
    P[Symbol.for("nodejs.util.inspect.custom")] = P.valueOf;
    if (configObject != null)
      BigNumber2.set(configObject);
    return BigNumber2;
  }
  function bitFloor(n) {
    var i = n | 0;
    return n > 0 || n === i ? i : i - 1;
  }
  function coeffToString(a) {
    var s, z, i = 1, j = a.length, r = a[0] + "";
    for (; i < j; ) {
      s = a[i++] + "";
      z = LOG_BASE - s.length;
      for (; z--; s = "0" + s)
        ;
      r += s;
    }
    for (j = r.length; r.charCodeAt(--j) === 48; )
      ;
    return r.slice(0, j + 1 || 1);
  }
  function compare(x, y) {
    var a, b, xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;
    if (!i || !j)
      return null;
    a = xc && !xc[0];
    b = yc && !yc[0];
    if (a || b)
      return a ? b ? 0 : -j : i;
    if (i != j)
      return i;
    a = i < 0;
    b = k == l;
    if (!xc || !yc)
      return b ? 0 : !xc ^ a ? 1 : -1;
    if (!b)
      return k > l ^ a ? 1 : -1;
    j = (k = xc.length) < (l = yc.length) ? k : l;
    for (i = 0; i < j; i++)
      if (xc[i] != yc[i])
        return xc[i] > yc[i] ^ a ? 1 : -1;
    return k == l ? 0 : k > l ^ a ? 1 : -1;
  }
  function intCheck(n, min, max, name) {
    if (n < min || n > max || n !== mathfloor(n)) {
      throw Error(bignumberError + (name || "Argument") + (typeof n == "number" ? n < min || n > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n));
    }
  }
  function isOdd(n) {
    var k = n.c.length - 1;
    return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
  }
  function toExponential(str, e) {
    return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e < 0 ? "e" : "e+") + e;
  }
  function toFixedPoint(str, e, z) {
    var len, zs;
    if (e < 0) {
      for (zs = z + "."; ++e; zs += z)
        ;
      str = zs + str;
    } else {
      len = str.length;
      if (++e > len) {
        for (zs = z, e -= len; --e; zs += z)
          ;
        str += zs;
      } else if (e < len) {
        str = str.slice(0, e) + "." + str.slice(e);
      }
    }
    return str;
  }
  var isNumeric, mathceil, mathfloor, bignumberError, tooManyDigits, BASE, LOG_BASE, MAX_SAFE_INTEGER, POWS_TEN, SQRT_BASE, MAX, BigNumber, bignumber_default;
  var init_bignumber = __esm({
    "node_modules/bignumber.js/bignumber.mjs"() {
      isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i;
      mathceil = Math.ceil;
      mathfloor = Math.floor;
      bignumberError = "[BigNumber Error] ";
      tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ";
      BASE = 1e14;
      LOG_BASE = 14;
      MAX_SAFE_INTEGER = 9007199254740991;
      POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13];
      SQRT_BASE = 1e7;
      MAX = 1e9;
      BigNumber = clone();
      bignumber_default = BigNumber;
    }
  });

  // node_modules/json-bigint/lib/stringify.js
  var require_stringify = __commonJS({
    "node_modules/json-bigint/lib/stringify.js"(exports2, module2) {
      var BigNumber2 = (init_bignumber(), __toCommonJS(bignumber_exports));
      var JSON2 = module2.exports;
      (function() {
        "use strict";
        function f(n) {
          return n < 10 ? "0" + n : n;
        }
        var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, gap, indent, meta = {
          "\b": "\\b",
          "	": "\\t",
          "\n": "\\n",
          "\f": "\\f",
          "\r": "\\r",
          '"': '\\"',
          "\\": "\\\\"
        }, rep;
        function quote(string) {
          escapable.lastIndex = 0;
          return escapable.test(string) ? '"' + string.replace(escapable, function(a) {
            var c = meta[a];
            return typeof c === "string" ? c : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
          }) + '"' : '"' + string + '"';
        }
        function str(key, holder) {
          var i, k, v, length, mind = gap, partial, value = holder[key], isBigNumber = value != null && (value instanceof BigNumber2 || BigNumber2.isBigNumber(value));
          if (value && typeof value === "object" && typeof value.toJSON === "function") {
            value = value.toJSON(key);
          }
          if (typeof rep === "function") {
            value = rep.call(holder, key, value);
          }
          switch (typeof value) {
            case "string":
              if (isBigNumber) {
                return value;
              } else {
                return quote(value);
              }
            case "number":
              return isFinite(value) ? String(value) : "null";
            case "boolean":
            case "null":
            case "bigint":
              return String(value);
            case "object":
              if (!value) {
                return "null";
              }
              gap += indent;
              partial = [];
              if (Object.prototype.toString.apply(value) === "[object Array]") {
                length = value.length;
                for (i = 0; i < length; i += 1) {
                  partial[i] = str(i, value) || "null";
                }
                v = partial.length === 0 ? "[]" : gap ? "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]" : "[" + partial.join(",") + "]";
                gap = mind;
                return v;
              }
              if (rep && typeof rep === "object") {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                  if (typeof rep[i] === "string") {
                    k = rep[i];
                    v = str(k, value);
                    if (v) {
                      partial.push(quote(k) + (gap ? ": " : ":") + v);
                    }
                  }
                }
              } else {
                Object.keys(value).forEach(function(k2) {
                  var v2 = str(k2, value);
                  if (v2) {
                    partial.push(quote(k2) + (gap ? ": " : ":") + v2);
                  }
                });
              }
              v = partial.length === 0 ? "{}" : gap ? "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}" : "{" + partial.join(",") + "}";
              gap = mind;
              return v;
          }
        }
        if (typeof JSON2.stringify !== "function") {
          JSON2.stringify = function(value, replacer, space) {
            var i;
            gap = "";
            indent = "";
            if (typeof space === "number") {
              for (i = 0; i < space; i += 1) {
                indent += " ";
              }
            } else if (typeof space === "string") {
              indent = space;
            }
            rep = replacer;
            if (replacer && typeof replacer !== "function" && (typeof replacer !== "object" || typeof replacer.length !== "number")) {
              throw new Error("JSON.stringify");
            }
            return str("", { "": value });
          };
        }
      })();
    }
  });

  // node_modules/json-bigint/lib/parse.js
  var require_parse = __commonJS({
    "node_modules/json-bigint/lib/parse.js"(exports2, module2) {
      var BigNumber2 = null;
      var suspectProtoRx = /(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])/;
      var suspectConstructorRx = /(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)/;
      var json_parse = function(options) {
        "use strict";
        var _options = {
          strict: false,
          storeAsString: false,
          alwaysParseAsBig: false,
          useNativeBigInt: false,
          protoAction: "error",
          constructorAction: "error"
        };
        if (options !== void 0 && options !== null) {
          if (options.strict === true) {
            _options.strict = true;
          }
          if (options.storeAsString === true) {
            _options.storeAsString = true;
          }
          _options.alwaysParseAsBig = options.alwaysParseAsBig === true ? options.alwaysParseAsBig : false;
          _options.useNativeBigInt = options.useNativeBigInt === true ? options.useNativeBigInt : false;
          if (typeof options.constructorAction !== "undefined") {
            if (options.constructorAction === "error" || options.constructorAction === "ignore" || options.constructorAction === "preserve") {
              _options.constructorAction = options.constructorAction;
            } else {
              throw new Error(`Incorrect value for constructorAction option, must be "error", "ignore" or undefined but passed ${options.constructorAction}`);
            }
          }
          if (typeof options.protoAction !== "undefined") {
            if (options.protoAction === "error" || options.protoAction === "ignore" || options.protoAction === "preserve") {
              _options.protoAction = options.protoAction;
            } else {
              throw new Error(`Incorrect value for protoAction option, must be "error", "ignore" or undefined but passed ${options.protoAction}`);
            }
          }
        }
        var at, ch, escapee = {
          '"': '"',
          "\\": "\\",
          "/": "/",
          b: "\b",
          f: "\f",
          n: "\n",
          r: "\r",
          t: "	"
        }, text, error = function(m) {
          throw {
            name: "SyntaxError",
            message: m,
            at,
            text
          };
        }, next = function(c) {
          if (c && c !== ch) {
            error("Expected '" + c + "' instead of '" + ch + "'");
          }
          ch = text.charAt(at);
          at += 1;
          return ch;
        }, number = function() {
          var number2, string2 = "";
          if (ch === "-") {
            string2 = "-";
            next("-");
          }
          while (ch >= "0" && ch <= "9") {
            string2 += ch;
            next();
          }
          if (ch === ".") {
            string2 += ".";
            while (next() && ch >= "0" && ch <= "9") {
              string2 += ch;
            }
          }
          if (ch === "e" || ch === "E") {
            string2 += ch;
            next();
            if (ch === "-" || ch === "+") {
              string2 += ch;
              next();
            }
            while (ch >= "0" && ch <= "9") {
              string2 += ch;
              next();
            }
          }
          number2 = +string2;
          if (!isFinite(number2)) {
            error("Bad number");
          } else {
            if (BigNumber2 == null)
              BigNumber2 = (init_bignumber(), __toCommonJS(bignumber_exports));
            if (string2.length > 15)
              return _options.storeAsString ? string2 : _options.useNativeBigInt ? BigInt(string2) : new BigNumber2(string2);
            else
              return !_options.alwaysParseAsBig ? number2 : _options.useNativeBigInt ? BigInt(number2) : new BigNumber2(number2);
          }
        }, string = function() {
          var hex, i, string2 = "", uffff;
          if (ch === '"') {
            var startAt = at;
            while (next()) {
              if (ch === '"') {
                if (at - 1 > startAt)
                  string2 += text.substring(startAt, at - 1);
                next();
                return string2;
              }
              if (ch === "\\") {
                if (at - 1 > startAt)
                  string2 += text.substring(startAt, at - 1);
                next();
                if (ch === "u") {
                  uffff = 0;
                  for (i = 0; i < 4; i += 1) {
                    hex = parseInt(next(), 16);
                    if (!isFinite(hex)) {
                      break;
                    }
                    uffff = uffff * 16 + hex;
                  }
                  string2 += String.fromCharCode(uffff);
                } else if (typeof escapee[ch] === "string") {
                  string2 += escapee[ch];
                } else {
                  break;
                }
                startAt = at;
              }
            }
          }
          error("Bad string");
        }, white = function() {
          while (ch && ch <= " ") {
            next();
          }
        }, word = function() {
          switch (ch) {
            case "t":
              next("t");
              next("r");
              next("u");
              next("e");
              return true;
            case "f":
              next("f");
              next("a");
              next("l");
              next("s");
              next("e");
              return false;
            case "n":
              next("n");
              next("u");
              next("l");
              next("l");
              return null;
          }
          error("Unexpected '" + ch + "'");
        }, value, array = function() {
          var array2 = [];
          if (ch === "[") {
            next("[");
            white();
            if (ch === "]") {
              next("]");
              return array2;
            }
            while (ch) {
              array2.push(value());
              white();
              if (ch === "]") {
                next("]");
                return array2;
              }
              next(",");
              white();
            }
          }
          error("Bad array");
        }, object = function() {
          var key, object2 = /* @__PURE__ */ Object.create(null);
          if (ch === "{") {
            next("{");
            white();
            if (ch === "}") {
              next("}");
              return object2;
            }
            while (ch) {
              key = string();
              white();
              next(":");
              if (_options.strict === true && Object.hasOwnProperty.call(object2, key)) {
                error('Duplicate key "' + key + '"');
              }
              if (suspectProtoRx.test(key) === true) {
                if (_options.protoAction === "error") {
                  error("Object contains forbidden prototype property");
                } else if (_options.protoAction === "ignore") {
                  value();
                } else {
                  object2[key] = value();
                }
              } else if (suspectConstructorRx.test(key) === true) {
                if (_options.constructorAction === "error") {
                  error("Object contains forbidden constructor property");
                } else if (_options.constructorAction === "ignore") {
                  value();
                } else {
                  object2[key] = value();
                }
              } else {
                object2[key] = value();
              }
              white();
              if (ch === "}") {
                next("}");
                return object2;
              }
              next(",");
              white();
            }
          }
          error("Bad object");
        };
        value = function() {
          white();
          switch (ch) {
            case "{":
              return object();
            case "[":
              return array();
            case '"':
              return string();
            case "-":
              return number();
            default:
              return ch >= "0" && ch <= "9" ? number() : word();
          }
        };
        return function(source, reviver) {
          var result;
          text = source + "";
          at = 0;
          ch = " ";
          result = value();
          white();
          if (ch) {
            error("Syntax error");
          }
          return typeof reviver === "function" ? function walk(holder, key) {
            var k, v, value2 = holder[key];
            if (value2 && typeof value2 === "object") {
              Object.keys(value2).forEach(function(k2) {
                v = walk(value2, k2);
                if (v !== void 0) {
                  value2[k2] = v;
                } else {
                  delete value2[k2];
                }
              });
            }
            return reviver.call(holder, key, value2);
          }({ "": result }, "") : result;
        };
      };
      module2.exports = json_parse;
    }
  });

  // node_modules/json-bigint/index.js
  var require_json_bigint = __commonJS({
    "node_modules/json-bigint/index.js"(exports2, module2) {
      var json_stringify = require_stringify().stringify;
      var json_parse = require_parse();
      module2.exports = function(options) {
        return {
          parse: json_parse(options),
          stringify: json_stringify
        };
      };
      module2.exports.parse = json_parse();
      module2.exports.stringify = json_stringify;
    }
  });

  // node_modules/algosdk/dist/esm/src/types/intDecoding.js
  var IntDecoding, intDecoding_default;
  var init_intDecoding = __esm({
    "node_modules/algosdk/dist/esm/src/types/intDecoding.js"() {
      (function(IntDecoding2) {
        IntDecoding2["DEFAULT"] = "default";
        IntDecoding2["SAFE"] = "safe";
        IntDecoding2["MIXED"] = "mixed";
        IntDecoding2["BIGINT"] = "bigint";
      })(IntDecoding || (IntDecoding = {}));
      intDecoding_default = IntDecoding;
    }
  });

  // node_modules/algosdk/dist/esm/src/utils/utils.js
  var utils_exports = {};
  __export(utils_exports, {
    arrayEqual: () => arrayEqual,
    concatArrays: () => concatArrays,
    isNode: () => isNode,
    parseJSON: () => parseJSON,
    removeUndefinedProperties: () => removeUndefinedProperties
  });
  function parseJSON(str, options) {
    const intDecoding = options && options.intDecoding ? options.intDecoding : intDecoding_default.DEFAULT;
    const parsed = JSONbig.parse(str, (_, value) => {
      if (value != null && typeof value === "object" && Object.getPrototypeOf(value) == null) {
        Object.setPrototypeOf(value, Object.prototype);
      }
      if (typeof value === "bigint") {
        if (intDecoding === "bigint" || intDecoding === "mixed" && value > Number.MAX_SAFE_INTEGER) {
          return value;
        }
        if (intDecoding === "default" || intDecoding === "mixed") {
          return Number(value);
        }
        throw new Error(`Integer exceeds maximum safe integer: ${value.toString()}. Try parsing with a different intDecoding option.`);
      }
      if (typeof value === "number") {
        if (intDecoding === "bigint" && Number.isInteger(value)) {
          return BigInt(value);
        }
      }
      return value;
    });
    return parsed;
  }
  function arrayEqual(a, b) {
    if (a.length !== b.length) {
      return false;
    }
    return Array.from(a).every((val, i) => val === b[i]);
  }
  function concatArrays(...arrs) {
    const size = arrs.reduce((sum, arr) => sum + arr.length, 0);
    const c = new Uint8Array(size);
    let offset = 0;
    for (let i = 0; i < arrs.length; i++) {
      c.set(arrs[i], offset);
      offset += arrs[i].length;
    }
    return c;
  }
  function removeUndefinedProperties(obj) {
    const mutableCopy = __spreadValues({}, obj);
    Object.keys(mutableCopy).forEach((key) => {
      if (typeof mutableCopy[key] === "undefined")
        delete mutableCopy[key];
    });
    return mutableCopy;
  }
  function isNode() {
    return typeof process === "object" && typeof process.versions === "object" && typeof process.versions.node !== "undefined";
  }
  var import_json_bigint, JSONbig;
  var init_utils = __esm({
    "node_modules/algosdk/dist/esm/src/utils/utils.js"() {
      import_json_bigint = __toESM(require_json_bigint());
      init_intDecoding();
      JSONbig = (0, import_json_bigint.default)({ useNativeBigInt: true, strict: true });
    }
  });

  // node_modules/algosdk/dist/esm/src/encoding/uint64.js
  function encodeUint64(num) {
    const isInteger = typeof num === "bigint" || Number.isInteger(num);
    if (!isInteger || num < 0 || num > BigInt("0xffffffffffffffff")) {
      throw new Error("Input is not a 64-bit unsigned integer");
    }
    const buf = Buffer.allocUnsafe(8);
    buf.writeBigUInt64BE(BigInt(num));
    return new Uint8Array(buf);
  }
  function decodeUint64(data, decodingMode = "safe") {
    if (decodingMode !== "safe" && decodingMode !== "mixed" && decodingMode !== "bigint") {
      throw new Error(`Unknown decodingMode option: ${decodingMode}`);
    }
    if (data.byteLength === 0 || data.byteLength > 8) {
      throw new Error(`Data has unacceptable length. Expected length is between 1 and 8, got ${data.byteLength}`);
    }
    const padding = Buffer.allocUnsafe(8 - data.byteLength);
    padding.fill(0);
    const buf = Buffer.concat([padding, Buffer.from(data)]);
    const num = buf.readBigUInt64BE();
    const isBig = num > Number.MAX_SAFE_INTEGER;
    if (decodingMode === "safe") {
      if (isBig) {
        throw new Error(`Integer exceeds maximum safe integer: ${num.toString()}. Try decoding with "mixed" or "safe" decodingMode.`);
      }
      return Number(num);
    }
    if (decodingMode === "mixed" && !isBig) {
      return Number(num);
    }
    return num;
  }
  var init_uint64 = __esm({
    "node_modules/algosdk/dist/esm/src/encoding/uint64.js"() {
    }
  });

  // node_modules/algosdk/dist/esm/src/encoding/address.js
  var address_exports = {};
  __export(address_exports, {
    ALGORAND_ZERO_ADDRESS_STRING: () => ALGORAND_ZERO_ADDRESS_STRING,
    CHECKSUM_ADDRESS_ERROR_MSG: () => CHECKSUM_ADDRESS_ERROR_MSG,
    INVALID_MSIG_PK_ERROR_MSG: () => INVALID_MSIG_PK_ERROR_MSG,
    INVALID_MSIG_THRESHOLD_ERROR_MSG: () => INVALID_MSIG_THRESHOLD_ERROR_MSG,
    INVALID_MSIG_VERSION_ERROR_MSG: () => INVALID_MSIG_VERSION_ERROR_MSG,
    MALFORMED_ADDRESS_ERROR_MSG: () => MALFORMED_ADDRESS_ERROR_MSG,
    UNEXPECTED_PK_LEN_ERROR_MSG: () => UNEXPECTED_PK_LEN_ERROR_MSG,
    decodeAddress: () => decodeAddress,
    encodeAddress: () => encodeAddress,
    fromMultisigPreImg: () => fromMultisigPreImg,
    fromMultisigPreImgAddrs: () => fromMultisigPreImgAddrs,
    getApplicationAddress: () => getApplicationAddress,
    isValidAddress: () => isValidAddress
  });
  function decodeAddress(address) {
    if (typeof address !== "string" || address.length !== ALGORAND_ADDRESS_LENGTH)
      throw new Error(MALFORMED_ADDRESS_ERROR_MSG);
    const decoded = import_hi_base32.default.decode.asBytes(address.toString());
    if (decoded.length !== ALGORAND_ADDRESS_BYTE_LENGTH)
      throw new Error(MALFORMED_ADDRESS_ERROR_MSG);
    const pk = new Uint8Array(decoded.slice(0, ALGORAND_ADDRESS_BYTE_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH));
    const cs = new Uint8Array(decoded.slice(PUBLIC_KEY_LENGTH, ALGORAND_ADDRESS_BYTE_LENGTH));
    const checksum = genericHash(pk).slice(HASH_BYTES_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH, HASH_BYTES_LENGTH);
    if (!arrayEqual(checksum, cs))
      throw new Error(CHECKSUM_ADDRESS_ERROR_MSG);
    return { publicKey: pk, checksum: cs };
  }
  function isValidAddress(address) {
    try {
      decodeAddress(address);
    } catch (e) {
      return false;
    }
    return true;
  }
  function encodeAddress(address) {
    const checksum = genericHash(address).slice(PUBLIC_KEY_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH, PUBLIC_KEY_LENGTH);
    const addr = import_hi_base32.default.encode(concatArrays(address, checksum));
    return addr.toString().slice(0, ALGORAND_ADDRESS_LENGTH);
  }
  function fromMultisigPreImg({ version, threshold, pks }) {
    if (version !== 1 || version > 255 || version < 0) {
      throw new Error(INVALID_MSIG_VERSION_ERROR_MSG);
    }
    if (threshold === 0 || pks.length === 0 || threshold > pks.length || threshold > 255) {
      throw new Error(INVALID_MSIG_THRESHOLD_ERROR_MSG);
    }
    const pkLen = ALGORAND_ADDRESS_BYTE_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH;
    if (pkLen !== PUBLIC_KEY_LENGTH) {
      throw new Error(UNEXPECTED_PK_LEN_ERROR_MSG);
    }
    const merged = new Uint8Array(MULTISIG_PREIMG2ADDR_PREFIX.length + 2 + pkLen * pks.length);
    merged.set(MULTISIG_PREIMG2ADDR_PREFIX, 0);
    merged.set([version], MULTISIG_PREIMG2ADDR_PREFIX.length);
    merged.set([threshold], MULTISIG_PREIMG2ADDR_PREFIX.length + 1);
    for (let i = 0; i < pks.length; i++) {
      if (pks[i].length !== pkLen) {
        throw new Error(INVALID_MSIG_PK_ERROR_MSG);
      }
      merged.set(pks[i], MULTISIG_PREIMG2ADDR_PREFIX.length + 2 + i * pkLen);
    }
    return new Uint8Array(genericHash(merged));
  }
  function fromMultisigPreImgAddrs({ version, threshold, addrs }) {
    const pks = addrs.map((addr) => decodeAddress(addr).publicKey);
    return encodeAddress(fromMultisigPreImg({ version, threshold, pks }));
  }
  function getApplicationAddress(appID) {
    const toBeSigned = concatArrays(APP_ID_PREFIX, encodeUint64(appID));
    const hash = genericHash(toBeSigned);
    return encodeAddress(new Uint8Array(hash));
  }
  var import_hi_base32, ALGORAND_ADDRESS_BYTE_LENGTH, ALGORAND_CHECKSUM_BYTE_LENGTH, ALGORAND_ADDRESS_LENGTH, ALGORAND_ZERO_ADDRESS_STRING, MULTISIG_PREIMG2ADDR_PREFIX, APP_ID_PREFIX, MALFORMED_ADDRESS_ERROR_MSG, CHECKSUM_ADDRESS_ERROR_MSG, INVALID_MSIG_VERSION_ERROR_MSG, INVALID_MSIG_THRESHOLD_ERROR_MSG, INVALID_MSIG_PK_ERROR_MSG, UNEXPECTED_PK_LEN_ERROR_MSG;
  var init_address = __esm({
    "node_modules/algosdk/dist/esm/src/encoding/address.js"() {
      import_hi_base32 = __toESM(require_base32());
      init_naclWrappers();
      init_utils();
      init_uint64();
      ALGORAND_ADDRESS_BYTE_LENGTH = 36;
      ALGORAND_CHECKSUM_BYTE_LENGTH = 4;
      ALGORAND_ADDRESS_LENGTH = 58;
      ALGORAND_ZERO_ADDRESS_STRING = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ";
      MULTISIG_PREIMG2ADDR_PREFIX = new Uint8Array([
        77,
        117,
        108,
        116,
        105,
        115,
        105,
        103,
        65,
        100,
        100,
        114
      ]);
      APP_ID_PREFIX = Buffer.from("appID");
      MALFORMED_ADDRESS_ERROR_MSG = "address seems to be malformed";
      CHECKSUM_ADDRESS_ERROR_MSG = "wrong checksum for address";
      INVALID_MSIG_VERSION_ERROR_MSG = "invalid multisig version";
      INVALID_MSIG_THRESHOLD_ERROR_MSG = "bad multisig threshold";
      INVALID_MSIG_PK_ERROR_MSG = "bad multisig public key - wrong length";
      UNEXPECTED_PK_LEN_ERROR_MSG = "nacl public key length is not 32 bytes";
    }
  });

  // node_modules/algo-msgpack-with-bigint/dist/utils/utf8.js
  var require_utf8 = __commonJS({
    "node_modules/algo-msgpack-with-bigint/dist/utils/utf8.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.utf8DecodeTD = exports2.TEXT_DECODER_THRESHOLD = exports2.utf8DecodeJs = exports2.utf8EncodeTE = exports2.TEXT_ENCODER_THRESHOLD = exports2.utf8EncodeJs = exports2.utf8Count = exports2.TEXT_ENCODING_AVAILABLE = void 0;
      exports2.TEXT_ENCODING_AVAILABLE = typeof process !== "undefined" && process.env.TEXT_ENCODING !== "never" && typeof TextEncoder !== "undefined" && typeof TextDecoder !== "undefined";
      function utf8Count(str) {
        const strLength = str.length;
        let byteLength = 0;
        let pos = 0;
        while (pos < strLength) {
          let value = str.charCodeAt(pos++);
          if ((value & 4294967168) === 0) {
            byteLength++;
            continue;
          } else if ((value & 4294965248) === 0) {
            byteLength += 2;
          } else {
            if (value >= 55296 && value <= 56319) {
              if (pos < strLength) {
                const extra = str.charCodeAt(pos);
                if ((extra & 64512) === 56320) {
                  ++pos;
                  value = ((value & 1023) << 10) + (extra & 1023) + 65536;
                }
              }
            }
            if ((value & 4294901760) === 0) {
              byteLength += 3;
            } else {
              byteLength += 4;
            }
          }
        }
        return byteLength;
      }
      exports2.utf8Count = utf8Count;
      function utf8EncodeJs(str, output, outputOffset) {
        const strLength = str.length;
        let offset = outputOffset;
        let pos = 0;
        while (pos < strLength) {
          let value = str.charCodeAt(pos++);
          if ((value & 4294967168) === 0) {
            output[offset++] = value;
            continue;
          } else if ((value & 4294965248) === 0) {
            output[offset++] = value >> 6 & 31 | 192;
          } else {
            if (value >= 55296 && value <= 56319) {
              if (pos < strLength) {
                const extra = str.charCodeAt(pos);
                if ((extra & 64512) === 56320) {
                  ++pos;
                  value = ((value & 1023) << 10) + (extra & 1023) + 65536;
                }
              }
            }
            if ((value & 4294901760) === 0) {
              output[offset++] = value >> 12 & 15 | 224;
              output[offset++] = value >> 6 & 63 | 128;
            } else {
              output[offset++] = value >> 18 & 7 | 240;
              output[offset++] = value >> 12 & 63 | 128;
              output[offset++] = value >> 6 & 63 | 128;
            }
          }
          output[offset++] = value & 63 | 128;
        }
      }
      exports2.utf8EncodeJs = utf8EncodeJs;
      var sharedTextEncoder = exports2.TEXT_ENCODING_AVAILABLE ? new TextEncoder() : void 0;
      exports2.TEXT_ENCODER_THRESHOLD = typeof process !== "undefined" && process.env.TEXT_ENCODING !== "force" ? 200 : 0;
      function utf8EncodeTEencode(str, output, outputOffset) {
        output.set(sharedTextEncoder.encode(str), outputOffset);
      }
      function utf8EncodeTEencodeInto(str, output, outputOffset) {
        sharedTextEncoder.encodeInto(str, output.subarray(outputOffset));
      }
      exports2.utf8EncodeTE = (sharedTextEncoder === null || sharedTextEncoder === void 0 ? void 0 : sharedTextEncoder.encodeInto) ? utf8EncodeTEencodeInto : utf8EncodeTEencode;
      var CHUNK_SIZE = 4096;
      function utf8DecodeJs(bytes, inputOffset, byteLength) {
        let offset = inputOffset;
        const end = offset + byteLength;
        const units = [];
        let result = "";
        while (offset < end) {
          const byte1 = bytes[offset++];
          if ((byte1 & 128) === 0) {
            units.push(byte1);
          } else if ((byte1 & 224) === 192) {
            const byte2 = bytes[offset++] & 63;
            units.push((byte1 & 31) << 6 | byte2);
          } else if ((byte1 & 240) === 224) {
            const byte2 = bytes[offset++] & 63;
            const byte3 = bytes[offset++] & 63;
            units.push((byte1 & 31) << 12 | byte2 << 6 | byte3);
          } else if ((byte1 & 248) === 240) {
            const byte2 = bytes[offset++] & 63;
            const byte3 = bytes[offset++] & 63;
            const byte4 = bytes[offset++] & 63;
            let unit = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;
            if (unit > 65535) {
              unit -= 65536;
              units.push(unit >>> 10 & 1023 | 55296);
              unit = 56320 | unit & 1023;
            }
            units.push(unit);
          } else {
            units.push(byte1);
          }
          if (units.length >= CHUNK_SIZE) {
            result += String.fromCharCode(...units);
            units.length = 0;
          }
        }
        if (units.length > 0) {
          result += String.fromCharCode(...units);
        }
        return result;
      }
      exports2.utf8DecodeJs = utf8DecodeJs;
      var sharedTextDecoder = exports2.TEXT_ENCODING_AVAILABLE ? new TextDecoder() : null;
      exports2.TEXT_DECODER_THRESHOLD = typeof process !== "undefined" && process.env.TEXT_DECODER !== "force" ? 200 : 0;
      function utf8DecodeTD(bytes, inputOffset, byteLength) {
        const stringBytes = bytes.subarray(inputOffset, inputOffset + byteLength);
        return sharedTextDecoder.decode(stringBytes);
      }
      exports2.utf8DecodeTD = utf8DecodeTD;
    }
  });

  // node_modules/algo-msgpack-with-bigint/dist/ExtData.js
  var require_ExtData = __commonJS({
    "node_modules/algo-msgpack-with-bigint/dist/ExtData.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ExtData = void 0;
      var ExtData = class {
        constructor(type, data) {
          this.type = type;
          this.data = data;
        }
      };
      exports2.ExtData = ExtData;
    }
  });

  // node_modules/algo-msgpack-with-bigint/dist/utils/int.js
  var require_int = __commonJS({
    "node_modules/algo-msgpack-with-bigint/dist/utils/int.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getUint64 = exports2.getInt64 = exports2.setBigInt64 = exports2.setInt64 = exports2.setUint64 = void 0;
      function setUint64(view, offset, value) {
        const high = value / 4294967296;
        const low = value;
        view.setUint32(offset, high);
        view.setUint32(offset + 4, low);
      }
      exports2.setUint64 = setUint64;
      function setInt64(view, offset, value) {
        const high = Math.floor(value / 4294967296);
        const low = value;
        view.setUint32(offset, high);
        view.setUint32(offset + 4, low);
      }
      exports2.setInt64 = setInt64;
      function setBigInt64(view, offset, value) {
        let high = Number(value / BigInt(4294967296));
        const low = Number(value % BigInt(4294967296));
        if (high < 0 && low !== 0) {
          high -= 1;
        }
        view.setUint32(offset, high);
        view.setUint32(offset + 4, low);
      }
      exports2.setBigInt64 = setBigInt64;
      function getInt64(view, offset) {
        const high = view.getInt32(offset);
        const low = view.getUint32(offset + 4);
        const exceeds_min_safe_int = high < Math.floor(Number.MIN_SAFE_INTEGER / 4294967296) || high === Math.floor(Number.MIN_SAFE_INTEGER / 4294967296) && low === 0;
        const exceeds_max_safe_int = high > Math.floor(Number.MAX_SAFE_INTEGER / 4294967296);
        if (exceeds_min_safe_int || exceeds_max_safe_int) {
          return BigInt(high) * BigInt(4294967296) + BigInt(low);
        }
        return high * 4294967296 + low;
      }
      exports2.getInt64 = getInt64;
      function getUint64(view, offset) {
        const high = view.getUint32(offset);
        const low = view.getUint32(offset + 4);
        const exceeds_max_safe_int = high > Math.floor(Number.MAX_SAFE_INTEGER / 4294967296);
        if (exceeds_max_safe_int) {
          return BigInt(high) * BigInt(4294967296) + BigInt(low);
        }
        return high * 4294967296 + low;
      }
      exports2.getUint64 = getUint64;
    }
  });

  // node_modules/algo-msgpack-with-bigint/dist/timestamp.js
  var require_timestamp = __commonJS({
    "node_modules/algo-msgpack-with-bigint/dist/timestamp.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.timestampExtension = exports2.decodeTimestampExtension = exports2.decodeTimestampToTimeSpec = exports2.encodeTimestampExtension = exports2.encodeDateToTimeSpec = exports2.encodeTimeSpecToTimestamp = exports2.EXT_TIMESTAMP = void 0;
      var int_1 = require_int();
      exports2.EXT_TIMESTAMP = -1;
      var TIMESTAMP32_MAX_SEC = 4294967296 - 1;
      var TIMESTAMP64_MAX_SEC = 17179869184 - 1;
      function encodeTimeSpecToTimestamp({ sec, nsec }) {
        if (sec >= 0 && nsec >= 0 && sec <= TIMESTAMP64_MAX_SEC) {
          if (nsec === 0 && sec <= TIMESTAMP32_MAX_SEC) {
            const rv = new Uint8Array(4);
            const view = new DataView(rv.buffer);
            view.setUint32(0, sec);
            return rv;
          } else {
            const secHigh = sec / 4294967296;
            const secLow = sec & 4294967295;
            const rv = new Uint8Array(8);
            const view = new DataView(rv.buffer);
            view.setUint32(0, nsec << 2 | secHigh & 3);
            view.setUint32(4, secLow);
            return rv;
          }
        } else {
          const rv = new Uint8Array(12);
          const view = new DataView(rv.buffer);
          view.setUint32(0, nsec);
          int_1.setInt64(view, 4, sec);
          return rv;
        }
      }
      exports2.encodeTimeSpecToTimestamp = encodeTimeSpecToTimestamp;
      function encodeDateToTimeSpec(date) {
        const msec = date.getTime();
        const sec = Math.floor(msec / 1e3);
        const nsec = (msec - sec * 1e3) * 1e6;
        const nsecInSec = Math.floor(nsec / 1e9);
        return {
          sec: sec + nsecInSec,
          nsec: nsec - nsecInSec * 1e9
        };
      }
      exports2.encodeDateToTimeSpec = encodeDateToTimeSpec;
      function encodeTimestampExtension(object) {
        if (object instanceof Date) {
          const timeSpec = encodeDateToTimeSpec(object);
          return encodeTimeSpecToTimestamp(timeSpec);
        } else {
          return null;
        }
      }
      exports2.encodeTimestampExtension = encodeTimestampExtension;
      function decodeTimestampToTimeSpec(data) {
        const view = new DataView(data.buffer, data.byteOffset, data.byteLength);
        switch (data.byteLength) {
          case 4: {
            const sec = view.getUint32(0);
            const nsec = 0;
            return { sec, nsec };
          }
          case 8: {
            const nsec30AndSecHigh2 = view.getUint32(0);
            const secLow32 = view.getUint32(4);
            const sec = (nsec30AndSecHigh2 & 3) * 4294967296 + secLow32;
            const nsec = nsec30AndSecHigh2 >>> 2;
            return { sec, nsec };
          }
          case 12: {
            const sec = int_1.getInt64(view, 4);
            const nsec = view.getUint32(0);
            return { sec, nsec };
          }
          default:
            throw new Error(`Unrecognized data size for timestamp: ${data.length}`);
        }
      }
      exports2.decodeTimestampToTimeSpec = decodeTimestampToTimeSpec;
      function decodeTimestampExtension(data) {
        const timeSpec = decodeTimestampToTimeSpec(data);
        return new Date(timeSpec.sec * 1e3 + timeSpec.nsec / 1e6);
      }
      exports2.decodeTimestampExtension = decodeTimestampExtension;
      exports2.timestampExtension = {
        type: exports2.EXT_TIMESTAMP,
        encode: encodeTimestampExtension,
        decode: decodeTimestampExtension
      };
    }
  });

  // node_modules/algo-msgpack-with-bigint/dist/ExtensionCodec.js
  var require_ExtensionCodec = __commonJS({
    "node_modules/algo-msgpack-with-bigint/dist/ExtensionCodec.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ExtensionCodec = void 0;
      var ExtData_1 = require_ExtData();
      var timestamp_1 = require_timestamp();
      var ExtensionCodec = class {
        constructor() {
          this.builtInEncoders = [];
          this.builtInDecoders = [];
          this.encoders = [];
          this.decoders = [];
          this.register(timestamp_1.timestampExtension);
        }
        register({ type, encode: encode3, decode: decode3 }) {
          if (type >= 0) {
            this.encoders[type] = encode3;
            this.decoders[type] = decode3;
          } else {
            const index = 1 + type;
            this.builtInEncoders[index] = encode3;
            this.builtInDecoders[index] = decode3;
          }
        }
        tryToEncode(object, context) {
          for (let i = 0; i < this.builtInEncoders.length; i++) {
            const encoder = this.builtInEncoders[i];
            if (encoder != null) {
              const data = encoder(object, context);
              if (data != null) {
                const type = -1 - i;
                return new ExtData_1.ExtData(type, data);
              }
            }
          }
          for (let i = 0; i < this.encoders.length; i++) {
            const encoder = this.encoders[i];
            if (encoder != null) {
              const data = encoder(object, context);
              if (data != null) {
                const type = i;
                return new ExtData_1.ExtData(type, data);
              }
            }
          }
          if (object instanceof ExtData_1.ExtData) {
            return object;
          }
          return null;
        }
        decode(data, type, context) {
          const decoder = type < 0 ? this.builtInDecoders[-1 - type] : this.decoders[type];
          if (decoder) {
            return decoder(data, type, context);
          } else {
            return new ExtData_1.ExtData(type, data);
          }
        }
      };
      exports2.ExtensionCodec = ExtensionCodec;
      ExtensionCodec.defaultCodec = new ExtensionCodec();
    }
  });

  // node_modules/algo-msgpack-with-bigint/dist/utils/typedArrays.js
  var require_typedArrays = __commonJS({
    "node_modules/algo-msgpack-with-bigint/dist/utils/typedArrays.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createDataView = exports2.ensureUint8Array = void 0;
      function ensureUint8Array(buffer) {
        if (buffer instanceof Uint8Array) {
          return buffer;
        } else if (ArrayBuffer.isView(buffer)) {
          return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
        } else if (buffer instanceof ArrayBuffer) {
          return new Uint8Array(buffer);
        } else {
          return Uint8Array.from(buffer);
        }
      }
      exports2.ensureUint8Array = ensureUint8Array;
      function createDataView(buffer) {
        if (buffer instanceof ArrayBuffer) {
          return new DataView(buffer);
        }
        const bufferView = ensureUint8Array(buffer);
        return new DataView(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);
      }
      exports2.createDataView = createDataView;
    }
  });

  // node_modules/algo-msgpack-with-bigint/dist/Encoder.js
  var require_Encoder = __commonJS({
    "node_modules/algo-msgpack-with-bigint/dist/Encoder.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Encoder = exports2.DEFAULT_INITIAL_BUFFER_SIZE = exports2.DEFAULT_MAX_DEPTH = void 0;
      var utf8_1 = require_utf8();
      var ExtensionCodec_1 = require_ExtensionCodec();
      var int_1 = require_int();
      var typedArrays_1 = require_typedArrays();
      exports2.DEFAULT_MAX_DEPTH = 100;
      exports2.DEFAULT_INITIAL_BUFFER_SIZE = 2048;
      var Encoder = class {
        constructor(extensionCodec = ExtensionCodec_1.ExtensionCodec.defaultCodec, context = void 0, maxDepth = exports2.DEFAULT_MAX_DEPTH, initialBufferSize = exports2.DEFAULT_INITIAL_BUFFER_SIZE, sortKeys = false, forceFloat32 = false, ignoreUndefined = false, forceIntegerToFloat = false) {
          this.extensionCodec = extensionCodec;
          this.context = context;
          this.maxDepth = maxDepth;
          this.initialBufferSize = initialBufferSize;
          this.sortKeys = sortKeys;
          this.forceFloat32 = forceFloat32;
          this.ignoreUndefined = ignoreUndefined;
          this.forceIntegerToFloat = forceIntegerToFloat;
          this.pos = 0;
          this.view = new DataView(new ArrayBuffer(this.initialBufferSize));
          this.bytes = new Uint8Array(this.view.buffer);
        }
        getUint8Array() {
          return this.bytes.subarray(0, this.pos);
        }
        reinitializeState() {
          this.pos = 0;
        }
        encode(object) {
          this.reinitializeState();
          this.doEncode(object, 1);
          return this.getUint8Array();
        }
        doEncode(object, depth) {
          if (depth > this.maxDepth) {
            throw new Error(`Too deep objects in depth ${depth}`);
          }
          if (object == null) {
            this.encodeNil();
          } else if (typeof object === "boolean") {
            this.encodeBoolean(object);
          } else if (typeof object === "number") {
            this.encodeNumber(object);
          } else if (typeof object === "string") {
            this.encodeString(object);
          } else if (typeof object === "bigint") {
            this.encodebigint(object);
          } else {
            this.encodeObject(object, depth);
          }
        }
        ensureBufferSizeToWrite(sizeToWrite) {
          const requiredSize = this.pos + sizeToWrite;
          if (this.view.byteLength < requiredSize) {
            this.resizeBuffer(requiredSize * 2);
          }
        }
        resizeBuffer(newSize) {
          const newBuffer = new ArrayBuffer(newSize);
          const newBytes = new Uint8Array(newBuffer);
          const newView = new DataView(newBuffer);
          newBytes.set(this.bytes);
          this.view = newView;
          this.bytes = newBytes;
        }
        encodeNil() {
          this.writeU8(192);
        }
        encodeBoolean(object) {
          if (object === false) {
            this.writeU8(194);
          } else {
            this.writeU8(195);
          }
        }
        encodeNumber(object) {
          if (Number.isSafeInteger(object) && !this.forceIntegerToFloat) {
            if (object >= 0) {
              if (object < 128) {
                this.writeU8(object);
              } else if (object < 256) {
                this.writeU8(204);
                this.writeU8(object);
              } else if (object < 65536) {
                this.writeU8(205);
                this.writeU16(object);
              } else if (object < 4294967296) {
                this.writeU8(206);
                this.writeU32(object);
              } else {
                this.writeU8(207);
                this.writeU64(object);
              }
            } else {
              if (object >= -32) {
                this.writeU8(224 | object + 32);
              } else if (object >= -128) {
                this.writeU8(208);
                this.writeI8(object);
              } else if (object >= -32768) {
                this.writeU8(209);
                this.writeI16(object);
              } else if (object >= -2147483648) {
                this.writeU8(210);
                this.writeI32(object);
              } else {
                this.writeU8(211);
                this.writeI64(object);
              }
            }
          } else {
            if (this.forceFloat32) {
              this.writeU8(202);
              this.writeF32(object);
            } else {
              this.writeU8(203);
              this.writeF64(object);
            }
          }
        }
        encodebigint(object) {
          if (object >= BigInt(0)) {
            if (object < BigInt(128)) {
              this.writeU8(Number(object));
            } else if (object < BigInt(256)) {
              this.writeU8(204);
              this.writeU8(Number(object));
            } else if (object < BigInt(65536)) {
              this.writeU8(205);
              this.writeU16(Number(object));
            } else if (object < BigInt(4294967296)) {
              this.writeU8(206);
              this.writeU32(Number(object));
            } else {
              this.writeU8(207);
              this.writeBig64(object);
            }
          } else {
            if (object >= BigInt(-32)) {
              this.writeU8(224 | Number(object) + 32);
            } else if (object >= BigInt(-128)) {
              this.writeU8(208);
              this.writeI8(Number(object));
            } else if (object >= BigInt(-32768)) {
              this.writeU8(209);
              this.writeI16(Number(object));
            } else if (object >= BigInt(-2147483648)) {
              this.writeU8(210);
              this.writeI32(Number(object));
            } else {
              this.writeU8(211);
              this.writeBig64(object);
            }
          }
        }
        writeStringHeader(byteLength) {
          if (byteLength < 32) {
            this.writeU8(160 + byteLength);
          } else if (byteLength < 256) {
            this.writeU8(217);
            this.writeU8(byteLength);
          } else if (byteLength < 65536) {
            this.writeU8(218);
            this.writeU16(byteLength);
          } else if (byteLength < 4294967296) {
            this.writeU8(219);
            this.writeU32(byteLength);
          } else {
            throw new Error(`Too long string: ${byteLength} bytes in UTF-8`);
          }
        }
        encodeString(object) {
          const maxHeaderSize = 1 + 4;
          const strLength = object.length;
          if (utf8_1.TEXT_ENCODING_AVAILABLE && strLength > utf8_1.TEXT_ENCODER_THRESHOLD) {
            const byteLength = utf8_1.utf8Count(object);
            this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);
            this.writeStringHeader(byteLength);
            utf8_1.utf8EncodeTE(object, this.bytes, this.pos);
            this.pos += byteLength;
          } else {
            const byteLength = utf8_1.utf8Count(object);
            this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);
            this.writeStringHeader(byteLength);
            utf8_1.utf8EncodeJs(object, this.bytes, this.pos);
            this.pos += byteLength;
          }
        }
        encodeObject(object, depth) {
          const ext = this.extensionCodec.tryToEncode(object, this.context);
          if (ext != null) {
            this.encodeExtension(ext);
          } else if (Array.isArray(object)) {
            this.encodeArray(object, depth);
          } else if (ArrayBuffer.isView(object)) {
            this.encodeBinary(object);
          } else if (typeof object === "object") {
            this.encodeMap(object, depth);
          } else {
            throw new Error(`Unrecognized object: ${Object.prototype.toString.apply(object)}`);
          }
        }
        encodeBinary(object) {
          const size = object.byteLength;
          if (size < 256) {
            this.writeU8(196);
            this.writeU8(size);
          } else if (size < 65536) {
            this.writeU8(197);
            this.writeU16(size);
          } else if (size < 4294967296) {
            this.writeU8(198);
            this.writeU32(size);
          } else {
            throw new Error(`Too large binary: ${size}`);
          }
          const bytes = typedArrays_1.ensureUint8Array(object);
          this.writeU8a(bytes);
        }
        encodeArray(object, depth) {
          const size = object.length;
          if (size < 16) {
            this.writeU8(144 + size);
          } else if (size < 65536) {
            this.writeU8(220);
            this.writeU16(size);
          } else if (size < 4294967296) {
            this.writeU8(221);
            this.writeU32(size);
          } else {
            throw new Error(`Too large array: ${size}`);
          }
          for (const item of object) {
            this.doEncode(item, depth + 1);
          }
        }
        countWithoutUndefined(object, keys) {
          let count = 0;
          for (const key of keys) {
            if (object[key] !== void 0) {
              count++;
            }
          }
          return count;
        }
        encodeMap(object, depth) {
          const keys = Object.keys(object);
          if (this.sortKeys) {
            keys.sort();
          }
          const size = this.ignoreUndefined ? this.countWithoutUndefined(object, keys) : keys.length;
          if (size < 16) {
            this.writeU8(128 + size);
          } else if (size < 65536) {
            this.writeU8(222);
            this.writeU16(size);
          } else if (size < 4294967296) {
            this.writeU8(223);
            this.writeU32(size);
          } else {
            throw new Error(`Too large map object: ${size}`);
          }
          for (const key of keys) {
            const value = object[key];
            if (!(this.ignoreUndefined && value === void 0)) {
              this.encodeString(key);
              this.doEncode(value, depth + 1);
            }
          }
        }
        encodeExtension(ext) {
          const size = ext.data.length;
          if (size === 1) {
            this.writeU8(212);
          } else if (size === 2) {
            this.writeU8(213);
          } else if (size === 4) {
            this.writeU8(214);
          } else if (size === 8) {
            this.writeU8(215);
          } else if (size === 16) {
            this.writeU8(216);
          } else if (size < 256) {
            this.writeU8(199);
            this.writeU8(size);
          } else if (size < 65536) {
            this.writeU8(200);
            this.writeU16(size);
          } else if (size < 4294967296) {
            this.writeU8(201);
            this.writeU32(size);
          } else {
            throw new Error(`Too large extension object: ${size}`);
          }
          this.writeI8(ext.type);
          this.writeU8a(ext.data);
        }
        writeU8(value) {
          this.ensureBufferSizeToWrite(1);
          this.view.setUint8(this.pos, value);
          this.pos++;
        }
        writeU8a(values) {
          const size = values.length;
          this.ensureBufferSizeToWrite(size);
          this.bytes.set(values, this.pos);
          this.pos += size;
        }
        writeI8(value) {
          this.ensureBufferSizeToWrite(1);
          this.view.setInt8(this.pos, value);
          this.pos++;
        }
        writeU16(value) {
          this.ensureBufferSizeToWrite(2);
          this.view.setUint16(this.pos, value);
          this.pos += 2;
        }
        writeI16(value) {
          this.ensureBufferSizeToWrite(2);
          this.view.setInt16(this.pos, value);
          this.pos += 2;
        }
        writeU32(value) {
          this.ensureBufferSizeToWrite(4);
          this.view.setUint32(this.pos, value);
          this.pos += 4;
        }
        writeI32(value) {
          this.ensureBufferSizeToWrite(4);
          this.view.setInt32(this.pos, value);
          this.pos += 4;
        }
        writeF32(value) {
          this.ensureBufferSizeToWrite(4);
          this.view.setFloat32(this.pos, value);
          this.pos += 4;
        }
        writeF64(value) {
          this.ensureBufferSizeToWrite(8);
          this.view.setFloat64(this.pos, value);
          this.pos += 8;
        }
        writeU64(value) {
          this.ensureBufferSizeToWrite(8);
          int_1.setUint64(this.view, this.pos, value);
          this.pos += 8;
        }
        writeI64(value) {
          this.ensureBufferSizeToWrite(8);
          int_1.setInt64(this.view, this.pos, value);
          this.pos += 8;
        }
        writeBig64(value) {
          this.ensureBufferSizeToWrite(8);
          int_1.setBigInt64(this.view, this.pos, value);
          this.pos += 8;
        }
      };
      exports2.Encoder = Encoder;
    }
  });

  // node_modules/algo-msgpack-with-bigint/dist/encode.js
  var require_encode = __commonJS({
    "node_modules/algo-msgpack-with-bigint/dist/encode.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.encode = void 0;
      var Encoder_1 = require_Encoder();
      var defaultEncodeOptions = {};
      function encode3(value, options = defaultEncodeOptions) {
        const encoder = new Encoder_1.Encoder(options.extensionCodec, options.context, options.maxDepth, options.initialBufferSize, options.sortKeys, options.forceFloat32, options.ignoreUndefined, options.forceIntegerToFloat);
        return encoder.encode(value);
      }
      exports2.encode = encode3;
    }
  });

  // node_modules/algo-msgpack-with-bigint/dist/utils/prettyByte.js
  var require_prettyByte = __commonJS({
    "node_modules/algo-msgpack-with-bigint/dist/utils/prettyByte.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.prettyByte = void 0;
      function prettyByte(byte) {
        return `${byte < 0 ? "-" : ""}0x${Math.abs(byte).toString(16).padStart(2, "0")}`;
      }
      exports2.prettyByte = prettyByte;
    }
  });

  // node_modules/algo-msgpack-with-bigint/dist/CachedKeyDecoder.js
  var require_CachedKeyDecoder = __commonJS({
    "node_modules/algo-msgpack-with-bigint/dist/CachedKeyDecoder.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.CachedKeyDecoder = void 0;
      var utf8_1 = require_utf8();
      var DEFAULT_MAX_KEY_LENGTH = 16;
      var DEFAULT_MAX_LENGTH_PER_KEY = 16;
      var CachedKeyDecoder = class {
        constructor(maxKeyLength = DEFAULT_MAX_KEY_LENGTH, maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY) {
          this.maxKeyLength = maxKeyLength;
          this.maxLengthPerKey = maxLengthPerKey;
          this.hit = 0;
          this.miss = 0;
          this.caches = [];
          for (let i = 0; i < this.maxKeyLength; i++) {
            this.caches.push([]);
          }
        }
        canBeCached(byteLength) {
          return byteLength > 0 && byteLength <= this.maxKeyLength;
        }
        get(bytes, inputOffset, byteLength) {
          const records = this.caches[byteLength - 1];
          const recordsLength = records.length;
          FIND_CHUNK:
            for (let i = 0; i < recordsLength; i++) {
              const record = records[i];
              const recordBytes = record.bytes;
              for (let j = 0; j < byteLength; j++) {
                if (recordBytes[j] !== bytes[inputOffset + j]) {
                  continue FIND_CHUNK;
                }
              }
              return record.value;
            }
          return null;
        }
        store(bytes, value) {
          const records = this.caches[bytes.length - 1];
          const record = { bytes, value };
          if (records.length >= this.maxLengthPerKey) {
            records[Math.random() * records.length | 0] = record;
          } else {
            records.push(record);
          }
        }
        decode(bytes, inputOffset, byteLength) {
          const cachedValue = this.get(bytes, inputOffset, byteLength);
          if (cachedValue != null) {
            this.hit++;
            return cachedValue;
          }
          this.miss++;
          const value = utf8_1.utf8DecodeJs(bytes, inputOffset, byteLength);
          const slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);
          this.store(slicedCopyOfBytes, value);
          return value;
        }
      };
      exports2.CachedKeyDecoder = CachedKeyDecoder;
    }
  });

  // node_modules/algo-msgpack-with-bigint/dist/Decoder.js
  var require_Decoder = __commonJS({
    "node_modules/algo-msgpack-with-bigint/dist/Decoder.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Decoder = exports2.DataViewIndexOutOfBoundsError = void 0;
      var prettyByte_1 = require_prettyByte();
      var ExtensionCodec_1 = require_ExtensionCodec();
      var int_1 = require_int();
      var utf8_1 = require_utf8();
      var typedArrays_1 = require_typedArrays();
      var CachedKeyDecoder_1 = require_CachedKeyDecoder();
      var isValidMapKeyType = (key) => {
        const keyType = typeof key;
        return keyType === "string" || keyType === "number";
      };
      var HEAD_BYTE_REQUIRED = -1;
      var EMPTY_VIEW = new DataView(new ArrayBuffer(0));
      var EMPTY_BYTES = new Uint8Array(EMPTY_VIEW.buffer);
      exports2.DataViewIndexOutOfBoundsError = (() => {
        try {
          EMPTY_VIEW.getInt8(0);
        } catch (e) {
          return e.constructor;
        }
        throw new Error("never reached");
      })();
      var MORE_DATA = new exports2.DataViewIndexOutOfBoundsError("Insufficient data");
      var DEFAULT_MAX_LENGTH = 4294967295;
      var sharedCachedKeyDecoder = new CachedKeyDecoder_1.CachedKeyDecoder();
      var Decoder = class {
        constructor(extensionCodec = ExtensionCodec_1.ExtensionCodec.defaultCodec, context = void 0, maxStrLength = DEFAULT_MAX_LENGTH, maxBinLength = DEFAULT_MAX_LENGTH, maxArrayLength = DEFAULT_MAX_LENGTH, maxMapLength = DEFAULT_MAX_LENGTH, maxExtLength = DEFAULT_MAX_LENGTH, keyDecoder = sharedCachedKeyDecoder) {
          this.extensionCodec = extensionCodec;
          this.context = context;
          this.maxStrLength = maxStrLength;
          this.maxBinLength = maxBinLength;
          this.maxArrayLength = maxArrayLength;
          this.maxMapLength = maxMapLength;
          this.maxExtLength = maxExtLength;
          this.keyDecoder = keyDecoder;
          this.totalPos = 0;
          this.pos = 0;
          this.view = EMPTY_VIEW;
          this.bytes = EMPTY_BYTES;
          this.headByte = HEAD_BYTE_REQUIRED;
          this.stack = [];
        }
        reinitializeState() {
          this.totalPos = 0;
          this.headByte = HEAD_BYTE_REQUIRED;
        }
        setBuffer(buffer) {
          this.bytes = typedArrays_1.ensureUint8Array(buffer);
          this.view = typedArrays_1.createDataView(this.bytes);
          this.pos = 0;
        }
        appendBuffer(buffer) {
          if (this.headByte === HEAD_BYTE_REQUIRED && !this.hasRemaining()) {
            this.setBuffer(buffer);
          } else {
            const remainingData = this.bytes.subarray(this.pos);
            const newData = typedArrays_1.ensureUint8Array(buffer);
            const concated = new Uint8Array(remainingData.length + newData.length);
            concated.set(remainingData);
            concated.set(newData, remainingData.length);
            this.setBuffer(concated);
          }
        }
        hasRemaining(size = 1) {
          return this.view.byteLength - this.pos >= size;
        }
        createNoExtraBytesError(posToShow) {
          const { view, pos } = this;
          return new RangeError(`Extra ${view.byteLength - pos} of ${view.byteLength} byte(s) found at buffer[${posToShow}]`);
        }
        decode(buffer) {
          this.reinitializeState();
          this.setBuffer(buffer);
          return this.doDecodeSingleSync();
        }
        doDecodeSingleSync() {
          const object = this.doDecodeSync();
          if (this.hasRemaining()) {
            throw this.createNoExtraBytesError(this.pos);
          }
          return object;
        }
        async decodeAsync(stream) {
          let decoded = false;
          let object;
          for await (const buffer of stream) {
            if (decoded) {
              throw this.createNoExtraBytesError(this.totalPos);
            }
            this.appendBuffer(buffer);
            try {
              object = this.doDecodeSync();
              decoded = true;
            } catch (e) {
              if (!(e instanceof exports2.DataViewIndexOutOfBoundsError)) {
                throw e;
              }
            }
            this.totalPos += this.pos;
          }
          if (decoded) {
            if (this.hasRemaining()) {
              throw this.createNoExtraBytesError(this.totalPos);
            }
            return object;
          }
          const { headByte, pos, totalPos } = this;
          throw new RangeError(`Insufficient data in parcing ${prettyByte_1.prettyByte(headByte)} at ${totalPos} (${pos} in the current buffer)`);
        }
        decodeArrayStream(stream) {
          return this.decodeMultiAsync(stream, true);
        }
        decodeStream(stream) {
          return this.decodeMultiAsync(stream, false);
        }
        async *decodeMultiAsync(stream, isArray) {
          let isArrayHeaderRequired = isArray;
          let arrayItemsLeft = -1;
          for await (const buffer of stream) {
            if (isArray && arrayItemsLeft === 0) {
              throw this.createNoExtraBytesError(this.totalPos);
            }
            this.appendBuffer(buffer);
            if (isArrayHeaderRequired) {
              arrayItemsLeft = this.readArraySize();
              isArrayHeaderRequired = false;
              this.complete();
            }
            try {
              while (true) {
                yield this.doDecodeSync();
                if (--arrayItemsLeft === 0) {
                  break;
                }
              }
            } catch (e) {
              if (!(e instanceof exports2.DataViewIndexOutOfBoundsError)) {
                throw e;
              }
            }
            this.totalPos += this.pos;
          }
        }
        doDecodeSync() {
          DECODE:
            while (true) {
              const headByte = this.readHeadByte();
              let object;
              if (headByte >= 224) {
                object = headByte - 256;
              } else if (headByte < 192) {
                if (headByte < 128) {
                  object = headByte;
                } else if (headByte < 144) {
                  const size = headByte - 128;
                  if (size !== 0) {
                    this.pushMapState(size);
                    this.complete();
                    continue DECODE;
                  } else {
                    object = {};
                  }
                } else if (headByte < 160) {
                  const size = headByte - 144;
                  if (size !== 0) {
                    this.pushArrayState(size);
                    this.complete();
                    continue DECODE;
                  } else {
                    object = [];
                  }
                } else {
                  const byteLength = headByte - 160;
                  object = this.decodeUtf8String(byteLength, 0);
                }
              } else if (headByte === 192) {
                object = null;
              } else if (headByte === 194) {
                object = false;
              } else if (headByte === 195) {
                object = true;
              } else if (headByte === 202) {
                object = this.readF32();
              } else if (headByte === 203) {
                object = this.readF64();
              } else if (headByte === 204) {
                object = this.readU8();
              } else if (headByte === 205) {
                object = this.readU16();
              } else if (headByte === 206) {
                object = this.readU32();
              } else if (headByte === 207) {
                object = this.readU64();
              } else if (headByte === 208) {
                object = this.readI8();
              } else if (headByte === 209) {
                object = this.readI16();
              } else if (headByte === 210) {
                object = this.readI32();
              } else if (headByte === 211) {
                object = this.readI64();
              } else if (headByte === 217) {
                const byteLength = this.lookU8();
                object = this.decodeUtf8String(byteLength, 1);
              } else if (headByte === 218) {
                const byteLength = this.lookU16();
                object = this.decodeUtf8String(byteLength, 2);
              } else if (headByte === 219) {
                const byteLength = this.lookU32();
                object = this.decodeUtf8String(byteLength, 4);
              } else if (headByte === 220) {
                const size = this.readU16();
                if (size !== 0) {
                  this.pushArrayState(size);
                  this.complete();
                  continue DECODE;
                } else {
                  object = [];
                }
              } else if (headByte === 221) {
                const size = this.readU32();
                if (size !== 0) {
                  this.pushArrayState(size);
                  this.complete();
                  continue DECODE;
                } else {
                  object = [];
                }
              } else if (headByte === 222) {
                const size = this.readU16();
                if (size !== 0) {
                  this.pushMapState(size);
                  this.complete();
                  continue DECODE;
                } else {
                  object = {};
                }
              } else if (headByte === 223) {
                const size = this.readU32();
                if (size !== 0) {
                  this.pushMapState(size);
                  this.complete();
                  continue DECODE;
                } else {
                  object = {};
                }
              } else if (headByte === 196) {
                const size = this.lookU8();
                object = this.decodeBinary(size, 1);
              } else if (headByte === 197) {
                const size = this.lookU16();
                object = this.decodeBinary(size, 2);
              } else if (headByte === 198) {
                const size = this.lookU32();
                object = this.decodeBinary(size, 4);
              } else if (headByte === 212) {
                object = this.decodeExtension(1, 0);
              } else if (headByte === 213) {
                object = this.decodeExtension(2, 0);
              } else if (headByte === 214) {
                object = this.decodeExtension(4, 0);
              } else if (headByte === 215) {
                object = this.decodeExtension(8, 0);
              } else if (headByte === 216) {
                object = this.decodeExtension(16, 0);
              } else if (headByte === 199) {
                const size = this.lookU8();
                object = this.decodeExtension(size, 1);
              } else if (headByte === 200) {
                const size = this.lookU16();
                object = this.decodeExtension(size, 2);
              } else if (headByte === 201) {
                const size = this.lookU32();
                object = this.decodeExtension(size, 4);
              } else {
                throw new Error(`Unrecognized type byte: ${prettyByte_1.prettyByte(headByte)}`);
              }
              this.complete();
              const stack = this.stack;
              while (stack.length > 0) {
                const state = stack[stack.length - 1];
                if (state.type === 0) {
                  state.array[state.position] = object;
                  state.position++;
                  if (state.position === state.size) {
                    stack.pop();
                    object = state.array;
                  } else {
                    continue DECODE;
                  }
                } else if (state.type === 1) {
                  if (!isValidMapKeyType(object)) {
                    throw new Error("The type of key must be string or number but " + typeof object);
                  }
                  state.key = object;
                  state.type = 2;
                  continue DECODE;
                } else {
                  state.map[state.key] = object;
                  state.readCount++;
                  if (state.readCount === state.size) {
                    stack.pop();
                    object = state.map;
                  } else {
                    state.key = null;
                    state.type = 1;
                    continue DECODE;
                  }
                }
              }
              return object;
            }
        }
        readHeadByte() {
          if (this.headByte === HEAD_BYTE_REQUIRED) {
            this.headByte = this.readU8();
          }
          return this.headByte;
        }
        complete() {
          this.headByte = HEAD_BYTE_REQUIRED;
        }
        readArraySize() {
          const headByte = this.readHeadByte();
          switch (headByte) {
            case 220:
              return this.readU16();
            case 221:
              return this.readU32();
            default: {
              if (headByte < 160) {
                return headByte - 144;
              } else {
                throw new Error(`Unrecognized array type byte: ${prettyByte_1.prettyByte(headByte)}`);
              }
            }
          }
        }
        pushMapState(size) {
          if (size > this.maxMapLength) {
            throw new Error(`Max length exceeded: map length (${size}) > maxMapLengthLength (${this.maxMapLength})`);
          }
          this.stack.push({
            type: 1,
            size,
            key: null,
            readCount: 0,
            map: {}
          });
        }
        pushArrayState(size) {
          if (size > this.maxArrayLength) {
            throw new Error(`Max length exceeded: array length (${size}) > maxArrayLength (${this.maxArrayLength})`);
          }
          this.stack.push({
            type: 0,
            size,
            array: new Array(size),
            position: 0
          });
        }
        decodeUtf8String(byteLength, headerOffset) {
          var _a;
          if (byteLength > this.maxStrLength) {
            throw new Error(`Max length exceeded: UTF-8 byte length (${byteLength}) > maxStrLength (${this.maxStrLength})`);
          }
          if (this.bytes.byteLength < this.pos + headerOffset + byteLength) {
            throw MORE_DATA;
          }
          const offset = this.pos + headerOffset;
          let object;
          if (this.stateIsMapKey() && ((_a = this.keyDecoder) === null || _a === void 0 ? void 0 : _a.canBeCached(byteLength))) {
            object = this.keyDecoder.decode(this.bytes, offset, byteLength);
          } else if (utf8_1.TEXT_ENCODING_AVAILABLE && byteLength > utf8_1.TEXT_DECODER_THRESHOLD) {
            object = utf8_1.utf8DecodeTD(this.bytes, offset, byteLength);
          } else {
            object = utf8_1.utf8DecodeJs(this.bytes, offset, byteLength);
          }
          this.pos += headerOffset + byteLength;
          return object;
        }
        stateIsMapKey() {
          if (this.stack.length > 0) {
            const state = this.stack[this.stack.length - 1];
            return state.type === 1;
          }
          return false;
        }
        decodeBinary(byteLength, headOffset) {
          if (byteLength > this.maxBinLength) {
            throw new Error(`Max length exceeded: bin length (${byteLength}) > maxBinLength (${this.maxBinLength})`);
          }
          if (!this.hasRemaining(byteLength + headOffset)) {
            throw MORE_DATA;
          }
          const offset = this.pos + headOffset;
          const object = this.bytes.subarray(offset, offset + byteLength);
          this.pos += headOffset + byteLength;
          return object;
        }
        decodeExtension(size, headOffset) {
          if (size > this.maxExtLength) {
            throw new Error(`Max length exceeded: ext length (${size}) > maxExtLength (${this.maxExtLength})`);
          }
          const extType = this.view.getInt8(this.pos + headOffset);
          const data = this.decodeBinary(size, headOffset + 1);
          return this.extensionCodec.decode(data, extType, this.context);
        }
        lookU8() {
          return this.view.getUint8(this.pos);
        }
        lookU16() {
          return this.view.getUint16(this.pos);
        }
        lookU32() {
          return this.view.getUint32(this.pos);
        }
        readU8() {
          const value = this.view.getUint8(this.pos);
          this.pos++;
          return value;
        }
        readI8() {
          const value = this.view.getInt8(this.pos);
          this.pos++;
          return value;
        }
        readU16() {
          const value = this.view.getUint16(this.pos);
          this.pos += 2;
          return value;
        }
        readI16() {
          const value = this.view.getInt16(this.pos);
          this.pos += 2;
          return value;
        }
        readU32() {
          const value = this.view.getUint32(this.pos);
          this.pos += 4;
          return value;
        }
        readI32() {
          const value = this.view.getInt32(this.pos);
          this.pos += 4;
          return value;
        }
        readU64() {
          const value = int_1.getUint64(this.view, this.pos);
          this.pos += 8;
          return value;
        }
        readI64() {
          const value = int_1.getInt64(this.view, this.pos);
          this.pos += 8;
          return value;
        }
        readF32() {
          const value = this.view.getFloat32(this.pos);
          this.pos += 4;
          return value;
        }
        readF64() {
          const value = this.view.getFloat64(this.pos);
          this.pos += 8;
          return value;
        }
      };
      exports2.Decoder = Decoder;
    }
  });

  // node_modules/algo-msgpack-with-bigint/dist/decode.js
  var require_decode = __commonJS({
    "node_modules/algo-msgpack-with-bigint/dist/decode.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.decode = exports2.defaultDecodeOptions = void 0;
      var Decoder_1 = require_Decoder();
      exports2.defaultDecodeOptions = {};
      function decode3(buffer, options = exports2.defaultDecodeOptions) {
        const decoder = new Decoder_1.Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);
        return decoder.decode(buffer);
      }
      exports2.decode = decode3;
    }
  });

  // node_modules/algo-msgpack-with-bigint/dist/utils/stream.js
  var require_stream = __commonJS({
    "node_modules/algo-msgpack-with-bigint/dist/utils/stream.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ensureAsyncIterabe = exports2.asyncIterableFromStream = exports2.isAsyncIterable = void 0;
      function isAsyncIterable(object) {
        return object[Symbol.asyncIterator] != null;
      }
      exports2.isAsyncIterable = isAsyncIterable;
      function assertNonNull(value) {
        if (value == null) {
          throw new Error("Assertion Failure: value must not be null nor undefined");
        }
      }
      async function* asyncIterableFromStream(stream) {
        const reader = stream.getReader();
        try {
          while (true) {
            const { done, value } = await reader.read();
            if (done) {
              return;
            }
            assertNonNull(value);
            yield value;
          }
        } finally {
          reader.releaseLock();
        }
      }
      exports2.asyncIterableFromStream = asyncIterableFromStream;
      function ensureAsyncIterabe(streamLike) {
        if (isAsyncIterable(streamLike)) {
          return streamLike;
        } else {
          return asyncIterableFromStream(streamLike);
        }
      }
      exports2.ensureAsyncIterabe = ensureAsyncIterabe;
    }
  });

  // node_modules/algo-msgpack-with-bigint/dist/decodeAsync.js
  var require_decodeAsync = __commonJS({
    "node_modules/algo-msgpack-with-bigint/dist/decodeAsync.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.decodeStream = exports2.decodeArrayStream = exports2.decodeAsync = void 0;
      var Decoder_1 = require_Decoder();
      var decode_1 = require_decode();
      var stream_1 = require_stream();
      async function decodeAsync(streamLike, options = decode_1.defaultDecodeOptions) {
        const stream = stream_1.ensureAsyncIterabe(streamLike);
        const decoder = new Decoder_1.Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);
        return decoder.decodeAsync(stream);
      }
      exports2.decodeAsync = decodeAsync;
      function decodeArrayStream(streamLike, options = decode_1.defaultDecodeOptions) {
        const stream = stream_1.ensureAsyncIterabe(streamLike);
        const decoder = new Decoder_1.Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);
        return decoder.decodeArrayStream(stream);
      }
      exports2.decodeArrayStream = decodeArrayStream;
      function decodeStream(streamLike, options = decode_1.defaultDecodeOptions) {
        const stream = stream_1.ensureAsyncIterabe(streamLike);
        const decoder = new Decoder_1.Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);
        return decoder.decodeStream(stream);
      }
      exports2.decodeStream = decodeStream;
    }
  });

  // node_modules/algo-msgpack-with-bigint/dist/index.js
  var require_dist = __commonJS({
    "node_modules/algo-msgpack-with-bigint/dist/index.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.decodeTimestampExtension = exports2.encodeTimestampExtension = exports2.decodeTimestampToTimeSpec = exports2.encodeTimeSpecToTimestamp = exports2.encodeDateToTimeSpec = exports2.EXT_TIMESTAMP = exports2.ExtData = exports2.ExtensionCodec = exports2.Encoder = exports2.Decoder = exports2.decodeStream = exports2.decodeArrayStream = exports2.decodeAsync = exports2.decode = exports2.encode = void 0;
      var encode_1 = require_encode();
      Object.defineProperty(exports2, "encode", { enumerable: true, get: function() {
        return encode_1.encode;
      } });
      var decode_1 = require_decode();
      Object.defineProperty(exports2, "decode", { enumerable: true, get: function() {
        return decode_1.decode;
      } });
      var decodeAsync_1 = require_decodeAsync();
      Object.defineProperty(exports2, "decodeAsync", { enumerable: true, get: function() {
        return decodeAsync_1.decodeAsync;
      } });
      Object.defineProperty(exports2, "decodeArrayStream", { enumerable: true, get: function() {
        return decodeAsync_1.decodeArrayStream;
      } });
      Object.defineProperty(exports2, "decodeStream", { enumerable: true, get: function() {
        return decodeAsync_1.decodeStream;
      } });
      var Decoder_1 = require_Decoder();
      Object.defineProperty(exports2, "Decoder", { enumerable: true, get: function() {
        return Decoder_1.Decoder;
      } });
      var Encoder_1 = require_Encoder();
      Object.defineProperty(exports2, "Encoder", { enumerable: true, get: function() {
        return Encoder_1.Encoder;
      } });
      var ExtensionCodec_1 = require_ExtensionCodec();
      Object.defineProperty(exports2, "ExtensionCodec", { enumerable: true, get: function() {
        return ExtensionCodec_1.ExtensionCodec;
      } });
      var ExtData_1 = require_ExtData();
      Object.defineProperty(exports2, "ExtData", { enumerable: true, get: function() {
        return ExtData_1.ExtData;
      } });
      var timestamp_1 = require_timestamp();
      Object.defineProperty(exports2, "EXT_TIMESTAMP", { enumerable: true, get: function() {
        return timestamp_1.EXT_TIMESTAMP;
      } });
      Object.defineProperty(exports2, "encodeDateToTimeSpec", { enumerable: true, get: function() {
        return timestamp_1.encodeDateToTimeSpec;
      } });
      Object.defineProperty(exports2, "encodeTimeSpecToTimestamp", { enumerable: true, get: function() {
        return timestamp_1.encodeTimeSpecToTimestamp;
      } });
      Object.defineProperty(exports2, "decodeTimestampToTimeSpec", { enumerable: true, get: function() {
        return timestamp_1.decodeTimestampToTimeSpec;
      } });
      Object.defineProperty(exports2, "encodeTimestampExtension", { enumerable: true, get: function() {
        return timestamp_1.encodeTimestampExtension;
      } });
      Object.defineProperty(exports2, "decodeTimestampExtension", { enumerable: true, get: function() {
        return timestamp_1.decodeTimestampExtension;
      } });
    }
  });

  // node_modules/algosdk/dist/esm/src/encoding/encoding.js
  var encoding_exports = {};
  __export(encoding_exports, {
    ERROR_CONTAINS_EMPTY_STRING: () => ERROR_CONTAINS_EMPTY_STRING,
    decode: () => decode2,
    encode: () => encode2
  });
  function containsEmpty(obj) {
    for (const key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        if (!obj[key] || obj[key].length === 0) {
          return { containsEmpty: true, firstEmptyKey: key };
        }
      }
    }
    return { containsEmpty: false, firstEmptyKey: void 0 };
  }
  function encode2(obj) {
    const emptyCheck = containsEmpty(obj);
    if (emptyCheck.containsEmpty) {
      throw new Error(ERROR_CONTAINS_EMPTY_STRING + emptyCheck.firstEmptyKey);
    }
    const options = { sortKeys: true };
    return msgpack.encode(obj, options);
  }
  function decode2(buffer) {
    return msgpack.decode(buffer);
  }
  var msgpack, ERROR_CONTAINS_EMPTY_STRING;
  var init_encoding = __esm({
    "node_modules/algosdk/dist/esm/src/encoding/encoding.js"() {
      msgpack = __toESM(require_dist());
      ERROR_CONTAINS_EMPTY_STRING = "The object contains empty or 0 values. First empty or 0 value encountered during encoding: ";
    }
  });

  // node_modules/algosdk/dist/esm/src/types/transactions/base.js
  var TransactionType, OnApplicationComplete;
  var init_base = __esm({
    "node_modules/algosdk/dist/esm/src/types/transactions/base.js"() {
      (function(TransactionType2) {
        TransactionType2["pay"] = "pay";
        TransactionType2["keyreg"] = "keyreg";
        TransactionType2["acfg"] = "acfg";
        TransactionType2["axfer"] = "axfer";
        TransactionType2["afrz"] = "afrz";
        TransactionType2["appl"] = "appl";
      })(TransactionType || (TransactionType = {}));
      (function(OnApplicationComplete2) {
        OnApplicationComplete2[OnApplicationComplete2["NoOpOC"] = 0] = "NoOpOC";
        OnApplicationComplete2[OnApplicationComplete2["OptInOC"] = 1] = "OptInOC";
        OnApplicationComplete2[OnApplicationComplete2["CloseOutOC"] = 2] = "CloseOutOC";
        OnApplicationComplete2[OnApplicationComplete2["ClearStateOC"] = 3] = "ClearStateOC";
        OnApplicationComplete2[OnApplicationComplete2["UpdateApplicationOC"] = 4] = "UpdateApplicationOC";
        OnApplicationComplete2[OnApplicationComplete2["DeleteApplicationOC"] = 5] = "DeleteApplicationOC";
      })(OnApplicationComplete || (OnApplicationComplete = {}));
    }
  });

  // node_modules/algosdk/dist/esm/src/transaction.js
  var transaction_exports = {};
  __export(transaction_exports, {
    ALGORAND_MIN_TX_FEE: () => ALGORAND_MIN_TX_FEE,
    Transaction: () => Transaction,
    decodeSignedTransaction: () => decodeSignedTransaction,
    decodeUnsignedTransaction: () => decodeUnsignedTransaction,
    default: () => transaction_default,
    encodeUnsignedTransaction: () => encodeUnsignedTransaction,
    instantiateTxnIfNeeded: () => instantiateTxnIfNeeded
  });
  function encodeUnsignedTransaction(transactionObject) {
    const objToEncode = transactionObject.get_obj_for_encoding();
    return encode2(objToEncode);
  }
  function decodeUnsignedTransaction(transactionBuffer) {
    const partlyDecodedObject = decode2(transactionBuffer);
    return Transaction.from_obj_for_encoding(partlyDecodedObject);
  }
  function decodeSignedTransaction(transactionBuffer) {
    const stxnDecoded = decode2(transactionBuffer);
    const stxn = __spreadProps(__spreadValues({}, stxnDecoded), {
      txn: Transaction.from_obj_for_encoding(stxnDecoded.txn)
    });
    return stxn;
  }
  function instantiateTxnIfNeeded(transactionLike) {
    return transactionLike instanceof Transaction ? transactionLike : new Transaction(transactionLike);
  }
  var import_hi_base322, ALGORAND_TRANSACTION_LENGTH, ALGORAND_MIN_TX_FEE, ALGORAND_TRANSACTION_LEASE_LENGTH, ALGORAND_MAX_ASSET_DECIMALS, NUM_ADDL_BYTES_AFTER_SIGNING, ALGORAND_TRANSACTION_LEASE_LABEL_LENGTH, ALGORAND_TRANSACTION_ADDRESS_LENGTH, ALGORAND_TRANSACTION_REKEY_LABEL_LENGTH, ASSET_METADATA_HASH_LENGTH, Transaction, transaction_default;
  var init_transaction = __esm({
    "node_modules/algosdk/dist/esm/src/transaction.js"() {
      import_hi_base322 = __toESM(require_base32());
      init_address();
      init_encoding();
      init_naclWrappers();
      init_utils();
      init_base();
      ALGORAND_TRANSACTION_LENGTH = 52;
      ALGORAND_MIN_TX_FEE = 1e3;
      ALGORAND_TRANSACTION_LEASE_LENGTH = 32;
      ALGORAND_MAX_ASSET_DECIMALS = 19;
      NUM_ADDL_BYTES_AFTER_SIGNING = 75;
      ALGORAND_TRANSACTION_LEASE_LABEL_LENGTH = 5;
      ALGORAND_TRANSACTION_ADDRESS_LENGTH = 32;
      ALGORAND_TRANSACTION_REKEY_LABEL_LENGTH = 5;
      ASSET_METADATA_HASH_LENGTH = 32;
      Transaction = class {
        constructor(_a) {
          var transaction = __objRest(_a, []);
          this.name = "Transaction";
          this.tag = Buffer.from("TX");
          const defaults = {
            type: TransactionType.pay,
            flatFee: false,
            nonParticipation: false
          };
          if (typeof transaction.type === "undefined") {
            transaction.type = defaults.type;
          }
          if (typeof transaction.flatFee === "undefined") {
            transaction.flatFee = defaults.flatFee;
          }
          if (transaction.type === TransactionType.keyreg && typeof transaction.voteKey !== "undefined" && typeof transaction.nonParticipation === "undefined") {
            transaction.nonParticipation = defaults.nonParticipation;
          }
          if (transaction.suggestedParams !== void 0) {
            const reference = transaction;
            reference.genesisHash = reference.suggestedParams.genesisHash;
            reference.fee = reference.suggestedParams.fee;
            if (reference.suggestedParams.flatFee !== void 0)
              reference.flatFee = reference.suggestedParams.flatFee;
            reference.firstRound = reference.suggestedParams.firstRound;
            reference.lastRound = reference.suggestedParams.lastRound;
            reference.genesisID = reference.suggestedParams.genesisID;
          }
          const txn = transaction;
          txn.from = decodeAddress(txn.from);
          if (txn.to !== void 0)
            txn.to = decodeAddress(txn.to);
          if (txn.closeRemainderTo !== void 0)
            txn.closeRemainderTo = decodeAddress(txn.closeRemainderTo);
          if (txn.assetManager !== void 0)
            txn.assetManager = decodeAddress(txn.assetManager);
          if (txn.assetReserve !== void 0)
            txn.assetReserve = decodeAddress(txn.assetReserve);
          if (txn.assetFreeze !== void 0)
            txn.assetFreeze = decodeAddress(txn.assetFreeze);
          if (txn.assetClawback !== void 0)
            txn.assetClawback = decodeAddress(txn.assetClawback);
          if (txn.assetRevocationTarget !== void 0)
            txn.assetRevocationTarget = decodeAddress(txn.assetRevocationTarget);
          if (txn.freezeAccount !== void 0)
            txn.freezeAccount = decodeAddress(txn.freezeAccount);
          if (txn.reKeyTo !== void 0)
            txn.reKeyTo = decodeAddress(txn.reKeyTo);
          if (txn.genesisHash === void 0)
            throw Error("genesis hash must be specified and in a base64 string.");
          txn.genesisHash = Buffer.from(txn.genesisHash, "base64");
          if (txn.amount !== void 0 && (!(Number.isSafeInteger(txn.amount) || typeof txn.amount === "bigint" && txn.amount <= BigInt("0xffffffffffffffff")) || txn.amount < 0))
            throw Error("Amount must be a positive number and smaller than 2^64-1. If the number is larger than 2^53-1, use bigint.");
          if (!Number.isSafeInteger(txn.fee) || txn.fee < 0)
            throw Error("fee must be a positive number and smaller than 2^53-1");
          if (!Number.isSafeInteger(txn.firstRound) || txn.firstRound < 0)
            throw Error("firstRound must be a positive number");
          if (!Number.isSafeInteger(txn.lastRound) || txn.lastRound < 0)
            throw Error("lastRound must be a positive number");
          if (txn.extraPages !== void 0 && (!Number.isInteger(txn.extraPages) || txn.extraPages < 0 || txn.extraPages > 3))
            throw Error("extraPages must be an Integer between and including 0 to 3");
          if (txn.assetTotal !== void 0 && (!(Number.isSafeInteger(txn.assetTotal) || typeof txn.assetTotal === "bigint" && txn.assetTotal <= BigInt("0xffffffffffffffff")) || txn.assetTotal < 0))
            throw Error("Total asset issuance must be a positive number and smaller than 2^64-1. If the number is larger than 2^53-1, use bigint.");
          if (txn.assetDecimals !== void 0 && (!Number.isSafeInteger(txn.assetDecimals) || txn.assetDecimals < 0 || txn.assetDecimals > ALGORAND_MAX_ASSET_DECIMALS))
            throw Error(`assetDecimals must be a positive number and smaller than ${ALGORAND_MAX_ASSET_DECIMALS.toString()}`);
          if (txn.assetIndex !== void 0 && (!Number.isSafeInteger(txn.assetIndex) || txn.assetIndex < 0))
            throw Error("Asset index must be a positive number and smaller than 2^53-1");
          if (txn.appIndex !== void 0 && (!Number.isSafeInteger(txn.appIndex) || txn.appIndex < 0))
            throw Error("Application index must be a positive number and smaller than 2^53-1");
          if (txn.appLocalInts !== void 0 && (!Number.isSafeInteger(txn.appLocalInts) || txn.appLocalInts < 0))
            throw Error("Application local ints count must be a positive number and smaller than 2^53-1");
          if (txn.appLocalByteSlices !== void 0 && (!Number.isSafeInteger(txn.appLocalByteSlices) || txn.appLocalByteSlices < 0))
            throw Error("Application local byte slices count must be a positive number and smaller than 2^53-1");
          if (txn.appGlobalInts !== void 0 && (!Number.isSafeInteger(txn.appGlobalInts) || txn.appGlobalInts < 0))
            throw Error("Application global ints count must be a positive number and smaller than 2^53-1");
          if (txn.appGlobalByteSlices !== void 0 && (!Number.isSafeInteger(txn.appGlobalByteSlices) || txn.appGlobalByteSlices < 0))
            throw Error("Application global byte slices count must be a positive number and smaller than 2^53-1");
          if (txn.appApprovalProgram !== void 0) {
            if (txn.appApprovalProgram.constructor !== Uint8Array)
              throw Error("appApprovalProgram must be a Uint8Array.");
          }
          if (txn.appClearProgram !== void 0) {
            if (txn.appClearProgram.constructor !== Uint8Array)
              throw Error("appClearProgram must be a Uint8Array.");
          }
          if (txn.appArgs !== void 0) {
            if (!Array.isArray(txn.appArgs))
              throw Error("appArgs must be an Array of Uint8Array.");
            txn.appArgs = txn.appArgs.slice();
            txn.appArgs.forEach((arg) => {
              if (arg.constructor !== Uint8Array)
                throw Error("each element of AppArgs must be a Uint8Array.");
            });
          } else {
            txn.appArgs = [];
          }
          if (txn.appAccounts !== void 0) {
            if (!Array.isArray(txn.appAccounts))
              throw Error("appAccounts must be an Array of addresses.");
            txn.appAccounts = txn.appAccounts.map((addressAsString) => decodeAddress(addressAsString));
          }
          if (txn.appForeignApps !== void 0) {
            if (!Array.isArray(txn.appForeignApps))
              throw Error("appForeignApps must be an Array of integers.");
            txn.appForeignApps = txn.appForeignApps.slice();
            txn.appForeignApps.forEach((foreignAppIndex) => {
              if (!Number.isSafeInteger(foreignAppIndex) || foreignAppIndex < 0)
                throw Error("each foreign application index must be a positive number and smaller than 2^53-1");
            });
          }
          if (txn.appForeignAssets !== void 0) {
            if (!Array.isArray(txn.appForeignAssets))
              throw Error("appForeignAssets must be an Array of integers.");
            txn.appForeignAssets = txn.appForeignAssets.slice();
            txn.appForeignAssets.forEach((foreignAssetIndex) => {
              if (!Number.isSafeInteger(foreignAssetIndex) || foreignAssetIndex < 0)
                throw Error("each foreign asset index must be a positive number and smaller than 2^53-1");
            });
          }
          if (txn.assetMetadataHash !== void 0 && txn.assetMetadataHash.length !== 0) {
            if (typeof txn.assetMetadataHash === "string") {
              txn.assetMetadataHash = new Uint8Array(Buffer.from(txn.assetMetadataHash));
            }
            if (txn.assetMetadataHash.constructor !== Uint8Array || txn.assetMetadataHash.byteLength !== ASSET_METADATA_HASH_LENGTH) {
              throw Error(`assetMetadataHash must be a ${ASSET_METADATA_HASH_LENGTH} byte Uint8Array or string.`);
            }
            if (txn.assetMetadataHash.every((value) => value === 0)) {
              txn.assetMetadataHash = void 0;
            }
          } else {
            txn.assetMetadataHash = void 0;
          }
          if (txn.note !== void 0) {
            if (txn.note.constructor !== Uint8Array)
              throw Error("note must be a Uint8Array.");
          } else {
            txn.note = new Uint8Array(0);
          }
          if (txn.lease !== void 0) {
            if (txn.lease.constructor !== Uint8Array)
              throw Error("lease must be a Uint8Array.");
            if (txn.lease.length !== ALGORAND_TRANSACTION_LEASE_LENGTH)
              throw Error(`lease must be of length ${ALGORAND_TRANSACTION_LEASE_LENGTH.toString()}.`);
            if (txn.lease.every((value) => value === 0)) {
              txn.lease = new Uint8Array(0);
            }
          } else {
            txn.lease = new Uint8Array(0);
          }
          if (typeof txn.voteKey !== "undefined") {
            txn.voteKey = Buffer.from(txn.voteKey, "base64");
          }
          if (txn.selectionKey !== void 0) {
            txn.selectionKey = Buffer.from(txn.selectionKey, "base64");
          }
          if (txn.nonParticipation && (txn.voteKey || txn.selectionKey || txn.voteFirst || txn.voteLast || txn.voteKeyDilution)) {
            throw new Error("nonParticipation is true but participation params are present.");
          }
          if (!txn.nonParticipation && (txn.voteKey || txn.selectionKey || txn.voteFirst || txn.voteLast || txn.voteKeyDilution) && !(txn.voteKey && txn.selectionKey && txn.voteFirst && txn.voteLast && txn.voteKeyDilution)) {
            throw new Error("online key registration missing at least one of the following fields: voteKey, selectionKey, voteFirst, voteLast, voteKeyDilution");
          }
          delete txn.suggestedParams;
          Object.assign(this, removeUndefinedProperties(txn));
          if (!txn.flatFee) {
            this.fee *= this.estimateSize();
            if (this.fee < ALGORAND_MIN_TX_FEE) {
              this.fee = ALGORAND_MIN_TX_FEE;
            }
          }
          this.group = void 0;
        }
        get_obj_for_encoding() {
          if (this.type === "pay") {
            const txn = {
              amt: this.amount,
              fee: this.fee,
              fv: this.firstRound,
              lv: this.lastRound,
              note: Buffer.from(this.note),
              snd: Buffer.from(this.from.publicKey),
              type: "pay",
              gen: this.genesisID,
              gh: this.genesisHash,
              lx: Buffer.from(this.lease),
              grp: this.group
            };
            if (this.closeRemainderTo !== void 0 && encodeAddress(this.closeRemainderTo.publicKey) !== ALGORAND_ZERO_ADDRESS_STRING) {
              txn.close = Buffer.from(this.closeRemainderTo.publicKey);
            }
            if (this.reKeyTo !== void 0) {
              txn.rekey = Buffer.from(this.reKeyTo.publicKey);
            }
            if (this.to !== void 0)
              txn.rcv = Buffer.from(this.to.publicKey);
            if (!txn.note.length)
              delete txn.note;
            if (!txn.amt)
              delete txn.amt;
            if (!txn.fee)
              delete txn.fee;
            if (!txn.fv)
              delete txn.fv;
            if (!txn.gen)
              delete txn.gen;
            if (txn.grp === void 0)
              delete txn.grp;
            if (!txn.lx.length)
              delete txn.lx;
            if (!txn.rekey)
              delete txn.rekey;
            return txn;
          }
          if (this.type === "keyreg") {
            const txn = {
              fee: this.fee,
              fv: this.firstRound,
              lv: this.lastRound,
              note: Buffer.from(this.note),
              snd: Buffer.from(this.from.publicKey),
              type: this.type,
              gen: this.genesisID,
              gh: this.genesisHash,
              lx: Buffer.from(this.lease),
              grp: this.group,
              votekey: this.voteKey,
              selkey: this.selectionKey,
              votefst: this.voteFirst,
              votelst: this.voteLast,
              votekd: this.voteKeyDilution
            };
            if (!txn.note.length)
              delete txn.note;
            if (!txn.lx.length)
              delete txn.lx;
            if (!txn.fee)
              delete txn.fee;
            if (!txn.fv)
              delete txn.fv;
            if (!txn.gen)
              delete txn.gen;
            if (txn.grp === void 0)
              delete txn.grp;
            if (this.reKeyTo !== void 0) {
              txn.rekey = Buffer.from(this.reKeyTo.publicKey);
            }
            if (this.nonParticipation) {
              txn.nonpart = true;
            }
            if (!txn.selkey)
              delete txn.selkey;
            if (!txn.votekey)
              delete txn.votekey;
            if (!txn.votefst)
              delete txn.votefst;
            if (!txn.votelst)
              delete txn.votelst;
            if (!txn.votekd)
              delete txn.votekd;
            return txn;
          }
          if (this.type === "acfg") {
            const txn = {
              fee: this.fee,
              fv: this.firstRound,
              lv: this.lastRound,
              note: Buffer.from(this.note),
              snd: Buffer.from(this.from.publicKey),
              type: this.type,
              gen: this.genesisID,
              gh: this.genesisHash,
              lx: Buffer.from(this.lease),
              grp: this.group,
              caid: this.assetIndex,
              apar: {
                t: this.assetTotal,
                df: this.assetDefaultFrozen,
                dc: this.assetDecimals
              }
            };
            if (this.assetManager !== void 0)
              txn.apar.m = Buffer.from(this.assetManager.publicKey);
            if (this.assetReserve !== void 0)
              txn.apar.r = Buffer.from(this.assetReserve.publicKey);
            if (this.assetFreeze !== void 0)
              txn.apar.f = Buffer.from(this.assetFreeze.publicKey);
            if (this.assetClawback !== void 0)
              txn.apar.c = Buffer.from(this.assetClawback.publicKey);
            if (this.assetName !== void 0)
              txn.apar.an = this.assetName;
            if (this.assetUnitName !== void 0)
              txn.apar.un = this.assetUnitName;
            if (this.assetURL !== void 0)
              txn.apar.au = this.assetURL;
            if (this.assetMetadataHash !== void 0)
              txn.apar.am = Buffer.from(this.assetMetadataHash);
            if (!txn.note.length)
              delete txn.note;
            if (!txn.lx.length)
              delete txn.lx;
            if (!txn.amt)
              delete txn.amt;
            if (!txn.fee)
              delete txn.fee;
            if (!txn.fv)
              delete txn.fv;
            if (!txn.gen)
              delete txn.gen;
            if (this.reKeyTo !== void 0) {
              txn.rekey = Buffer.from(this.reKeyTo.publicKey);
            }
            if (!txn.caid)
              delete txn.caid;
            if (!txn.apar.t && !txn.apar.un && !txn.apar.an && !txn.apar.df && !txn.apar.m && !txn.apar.r && !txn.apar.f && !txn.apar.c && !txn.apar.au && !txn.apar.am && !txn.apar.dc) {
              delete txn.apar;
            } else {
              if (!txn.apar.t)
                delete txn.apar.t;
              if (!txn.apar.dc)
                delete txn.apar.dc;
              if (!txn.apar.un)
                delete txn.apar.un;
              if (!txn.apar.an)
                delete txn.apar.an;
              if (!txn.apar.df)
                delete txn.apar.df;
              if (!txn.apar.m)
                delete txn.apar.m;
              if (!txn.apar.r)
                delete txn.apar.r;
              if (!txn.apar.f)
                delete txn.apar.f;
              if (!txn.apar.c)
                delete txn.apar.c;
              if (!txn.apar.au)
                delete txn.apar.au;
              if (!txn.apar.am)
                delete txn.apar.am;
            }
            if (txn.grp === void 0)
              delete txn.grp;
            return txn;
          }
          if (this.type === "axfer") {
            const txn = {
              aamt: this.amount,
              fee: this.fee,
              fv: this.firstRound,
              lv: this.lastRound,
              note: Buffer.from(this.note),
              snd: Buffer.from(this.from.publicKey),
              arcv: Buffer.from(this.to.publicKey),
              type: this.type,
              gen: this.genesisID,
              gh: this.genesisHash,
              lx: Buffer.from(this.lease),
              grp: this.group,
              xaid: this.assetIndex
            };
            if (this.closeRemainderTo !== void 0)
              txn.aclose = Buffer.from(this.closeRemainderTo.publicKey);
            if (this.assetRevocationTarget !== void 0)
              txn.asnd = Buffer.from(this.assetRevocationTarget.publicKey);
            if (!txn.note.length)
              delete txn.note;
            if (!txn.lx.length)
              delete txn.lx;
            if (!txn.aamt)
              delete txn.aamt;
            if (!txn.amt)
              delete txn.amt;
            if (!txn.fee)
              delete txn.fee;
            if (!txn.fv)
              delete txn.fv;
            if (!txn.gen)
              delete txn.gen;
            if (txn.grp === void 0)
              delete txn.grp;
            if (!txn.aclose)
              delete txn.aclose;
            if (!txn.asnd)
              delete txn.asnd;
            if (!txn.rekey)
              delete txn.rekey;
            if (this.reKeyTo !== void 0) {
              txn.rekey = Buffer.from(this.reKeyTo.publicKey);
            }
            return txn;
          }
          if (this.type === "afrz") {
            const txn = {
              fee: this.fee,
              fv: this.firstRound,
              lv: this.lastRound,
              note: Buffer.from(this.note),
              snd: Buffer.from(this.from.publicKey),
              type: this.type,
              gen: this.genesisID,
              gh: this.genesisHash,
              lx: Buffer.from(this.lease),
              grp: this.group,
              faid: this.assetIndex,
              afrz: this.freezeState
            };
            if (this.freezeAccount !== void 0)
              txn.fadd = Buffer.from(this.freezeAccount.publicKey);
            if (!txn.note.length)
              delete txn.note;
            if (!txn.lx.length)
              delete txn.lx;
            if (!txn.amt)
              delete txn.amt;
            if (!txn.fee)
              delete txn.fee;
            if (!txn.fv)
              delete txn.fv;
            if (!txn.gen)
              delete txn.gen;
            if (!txn.afrz)
              delete txn.afrz;
            if (txn.grp === void 0)
              delete txn.grp;
            if (this.reKeyTo !== void 0) {
              txn.rekey = Buffer.from(this.reKeyTo.publicKey);
            }
            return txn;
          }
          if (this.type === "appl") {
            const txn = {
              fee: this.fee,
              fv: this.firstRound,
              lv: this.lastRound,
              note: Buffer.from(this.note),
              snd: Buffer.from(this.from.publicKey),
              type: this.type,
              gen: this.genesisID,
              gh: this.genesisHash,
              lx: Buffer.from(this.lease),
              grp: this.group,
              apid: this.appIndex,
              apan: this.appOnComplete,
              apls: {
                nui: this.appLocalInts,
                nbs: this.appLocalByteSlices
              },
              apgs: {
                nui: this.appGlobalInts,
                nbs: this.appGlobalByteSlices
              },
              apfa: this.appForeignApps,
              apas: this.appForeignAssets,
              apep: this.extraPages
            };
            if (this.reKeyTo !== void 0) {
              txn.rekey = Buffer.from(this.reKeyTo.publicKey);
            }
            if (this.appApprovalProgram !== void 0) {
              txn.apap = Buffer.from(this.appApprovalProgram);
            }
            if (this.appClearProgram !== void 0) {
              txn.apsu = Buffer.from(this.appClearProgram);
            }
            if (this.appArgs !== void 0) {
              txn.apaa = this.appArgs.map((arg) => Buffer.from(arg));
            }
            if (this.appAccounts !== void 0) {
              txn.apat = this.appAccounts.map((decodedAddress) => Buffer.from(decodedAddress.publicKey));
            }
            if (!txn.note.length)
              delete txn.note;
            if (!txn.lx.length)
              delete txn.lx;
            if (!txn.amt)
              delete txn.amt;
            if (!txn.fee)
              delete txn.fee;
            if (!txn.fv)
              delete txn.fv;
            if (!txn.gen)
              delete txn.gen;
            if (!txn.apid)
              delete txn.apid;
            if (!txn.apls.nui)
              delete txn.apls.nui;
            if (!txn.apls.nbs)
              delete txn.apls.nbs;
            if (!txn.apls.nui && !txn.apls.nbs)
              delete txn.apls;
            if (!txn.apgs.nui)
              delete txn.apgs.nui;
            if (!txn.apgs.nbs)
              delete txn.apgs.nbs;
            if (!txn.apaa || !txn.apaa.length)
              delete txn.apaa;
            if (!txn.apgs.nui && !txn.apgs.nbs)
              delete txn.apgs;
            if (!txn.apap)
              delete txn.apap;
            if (!txn.apsu)
              delete txn.apsu;
            if (!txn.apan)
              delete txn.apan;
            if (!txn.apfa || !txn.apfa.length)
              delete txn.apfa;
            if (!txn.apas || !txn.apas.length)
              delete txn.apas;
            if (!txn.apat || !txn.apat.length)
              delete txn.apat;
            if (!txn.apep)
              delete txn.apep;
            if (txn.grp === void 0)
              delete txn.grp;
            return txn;
          }
          return void 0;
        }
        static from_obj_for_encoding(txnForEnc) {
          const txn = Object.create(this.prototype);
          txn.name = "Transaction";
          txn.tag = Buffer.from("TX");
          txn.genesisID = txnForEnc.gen;
          txn.genesisHash = Buffer.from(txnForEnc.gh);
          txn.type = txnForEnc.type;
          txn.fee = txnForEnc.fee;
          txn.firstRound = txnForEnc.fv;
          txn.lastRound = txnForEnc.lv;
          txn.note = new Uint8Array(txnForEnc.note);
          txn.lease = new Uint8Array(txnForEnc.lx);
          txn.from = decodeAddress(encodeAddress(new Uint8Array(txnForEnc.snd)));
          if (txnForEnc.grp !== void 0)
            txn.group = Buffer.from(txnForEnc.grp);
          if (txnForEnc.rekey !== void 0)
            txn.reKeyTo = decodeAddress(encodeAddress(new Uint8Array(txnForEnc.rekey)));
          if (txnForEnc.type === "pay") {
            txn.amount = txnForEnc.amt;
            txn.to = decodeAddress(encodeAddress(new Uint8Array(txnForEnc.rcv)));
            if (txnForEnc.close !== void 0)
              txn.closeRemainderTo = decodeAddress(encodeAddress(txnForEnc.close));
          } else if (txnForEnc.type === "keyreg") {
            if (txnForEnc.votekey !== void 0) {
              txn.voteKey = Buffer.from(txnForEnc.votekey);
            }
            if (txnForEnc.selkey !== void 0) {
              txn.selectionKey = Buffer.from(txnForEnc.selkey);
            }
            if (txnForEnc.votekd !== void 0) {
              txn.voteKeyDilution = txnForEnc.votekd;
            }
            if (txnForEnc.votefst !== void 0) {
              txn.voteFirst = txnForEnc.votefst;
            }
            if (txnForEnc.votelst !== void 0) {
              txn.voteLast = txnForEnc.votelst;
            }
            if (txnForEnc.nonpart !== void 0) {
              txn.nonParticipation = txnForEnc.nonpart;
            }
          } else if (txnForEnc.type === "acfg") {
            if (txnForEnc.caid !== void 0) {
              txn.assetIndex = txnForEnc.caid;
            }
            if (txnForEnc.apar !== void 0) {
              txn.assetTotal = txnForEnc.apar.t;
              txn.assetDefaultFrozen = txnForEnc.apar.df;
              if (txnForEnc.apar.dc !== void 0)
                txn.assetDecimals = txnForEnc.apar.dc;
              if (txnForEnc.apar.m !== void 0)
                txn.assetManager = decodeAddress(encodeAddress(new Uint8Array(txnForEnc.apar.m)));
              if (txnForEnc.apar.r !== void 0)
                txn.assetReserve = decodeAddress(encodeAddress(new Uint8Array(txnForEnc.apar.r)));
              if (txnForEnc.apar.f !== void 0)
                txn.assetFreeze = decodeAddress(encodeAddress(new Uint8Array(txnForEnc.apar.f)));
              if (txnForEnc.apar.c !== void 0)
                txn.assetClawback = decodeAddress(encodeAddress(new Uint8Array(txnForEnc.apar.c)));
              if (txnForEnc.apar.un !== void 0)
                txn.assetUnitName = txnForEnc.apar.un;
              if (txnForEnc.apar.an !== void 0)
                txn.assetName = txnForEnc.apar.an;
              if (txnForEnc.apar.au !== void 0)
                txn.assetURL = txnForEnc.apar.au;
              if (txnForEnc.apar.am !== void 0)
                txn.assetMetadataHash = txnForEnc.apar.am;
            }
          } else if (txnForEnc.type === "axfer") {
            if (txnForEnc.xaid !== void 0) {
              txn.assetIndex = txnForEnc.xaid;
            }
            if (txnForEnc.aamt !== void 0)
              txn.amount = txnForEnc.aamt;
            if (txnForEnc.aclose !== void 0) {
              txn.closeRemainderTo = decodeAddress(encodeAddress(new Uint8Array(txnForEnc.aclose)));
            }
            if (txnForEnc.asnd !== void 0) {
              txn.assetRevocationTarget = decodeAddress(encodeAddress(new Uint8Array(txnForEnc.asnd)));
            }
            txn.to = decodeAddress(encodeAddress(new Uint8Array(txnForEnc.arcv)));
          } else if (txnForEnc.type === "afrz") {
            if (txnForEnc.afrz !== void 0) {
              txn.freezeState = txnForEnc.afrz;
            }
            if (txnForEnc.faid !== void 0) {
              txn.assetIndex = txnForEnc.faid;
            }
            txn.freezeAccount = decodeAddress(encodeAddress(new Uint8Array(txnForEnc.fadd)));
          } else if (txnForEnc.type === "appl") {
            if (txnForEnc.apid !== void 0) {
              txn.appIndex = txnForEnc.apid;
            }
            if (txnForEnc.apan !== void 0) {
              txn.appOnComplete = txnForEnc.apan;
            }
            if (txnForEnc.apls !== void 0) {
              if (txnForEnc.apls.nui !== void 0)
                txn.appLocalInts = txnForEnc.apls.nui;
              if (txnForEnc.apls.nbs !== void 0)
                txn.appLocalByteSlices = txnForEnc.apls.nbs;
            }
            if (txnForEnc.apgs !== void 0) {
              if (txnForEnc.apgs.nui !== void 0)
                txn.appGlobalInts = txnForEnc.apgs.nui;
              if (txnForEnc.apgs.nbs !== void 0)
                txn.appGlobalByteSlices = txnForEnc.apgs.nbs;
            }
            if (txnForEnc.apep !== void 0) {
              txn.extraPages = txnForEnc.apep;
            }
            if (txnForEnc.apap !== void 0) {
              txn.appApprovalProgram = new Uint8Array(txnForEnc.apap);
            }
            if (txnForEnc.apsu !== void 0) {
              txn.appClearProgram = new Uint8Array(txnForEnc.apsu);
            }
            if (txnForEnc.apaa !== void 0) {
              txn.appArgs = txnForEnc.apaa.map((arg) => new Uint8Array(arg));
            }
            if (txnForEnc.apat !== void 0) {
              txn.appAccounts = txnForEnc.apat.map((addressBytes) => decodeAddress(encodeAddress(new Uint8Array(addressBytes))));
            }
            if (txnForEnc.apfa !== void 0) {
              txn.appForeignApps = txnForEnc.apfa;
            }
            if (txnForEnc.apas !== void 0) {
              txn.appForeignAssets = txnForEnc.apas;
            }
          }
          return txn;
        }
        estimateSize() {
          return this.toByte().length + NUM_ADDL_BYTES_AFTER_SIGNING;
        }
        bytesToSign() {
          const encodedMsg = this.toByte();
          return Buffer.from(concatArrays(this.tag, encodedMsg));
        }
        toByte() {
          return encode2(this.get_obj_for_encoding());
        }
        rawSignTxn(sk) {
          const toBeSigned = this.bytesToSign();
          const sig = sign(toBeSigned, sk);
          return Buffer.from(sig);
        }
        signTxn(sk) {
          const sTxn = {
            sig: this.rawSignTxn(sk),
            txn: this.get_obj_for_encoding()
          };
          const keypair = keyPairFromSecretKey(sk);
          const pubKeyFromSk = keypair.publicKey;
          if (encodeAddress(pubKeyFromSk) !== encodeAddress(this.from.publicKey)) {
            sTxn.sgnr = Buffer.from(pubKeyFromSk);
          }
          return new Uint8Array(encode2(sTxn));
        }
        rawTxID() {
          const enMsg = this.toByte();
          const gh = Buffer.from(concatArrays(this.tag, enMsg));
          return Buffer.from(genericHash(gh));
        }
        txID() {
          const hash = this.rawTxID();
          return import_hi_base322.default.encode(hash).slice(0, ALGORAND_TRANSACTION_LENGTH);
        }
        addLease(lease, feePerByte = 0) {
          let mutableLease;
          if (lease !== void 0) {
            if (lease.constructor !== Uint8Array)
              throw Error("lease must be a Uint8Array.");
            if (lease.length !== ALGORAND_TRANSACTION_LEASE_LENGTH)
              throw Error(`lease must be of length ${ALGORAND_TRANSACTION_LEASE_LENGTH.toString()}.`);
            mutableLease = new Uint8Array(lease);
          } else {
            mutableLease = new Uint8Array(0);
          }
          this.lease = mutableLease;
          if (feePerByte !== 0) {
            this.fee += (ALGORAND_TRANSACTION_LEASE_LABEL_LENGTH + ALGORAND_TRANSACTION_LEASE_LENGTH) * feePerByte;
          }
        }
        addRekey(reKeyTo, feePerByte = 0) {
          if (reKeyTo !== void 0) {
            this.reKeyTo = decodeAddress(reKeyTo);
          }
          if (feePerByte !== 0) {
            this.fee += (ALGORAND_TRANSACTION_REKEY_LABEL_LENGTH + ALGORAND_TRANSACTION_ADDRESS_LENGTH) * feePerByte;
          }
        }
        _getDictForDisplay() {
          const forPrinting = __spreadValues({}, this);
          forPrinting.tag = forPrinting.tag.toString();
          forPrinting.from = encodeAddress(forPrinting.from.publicKey);
          if (forPrinting.to !== void 0)
            forPrinting.to = encodeAddress(forPrinting.to.publicKey);
          if (forPrinting.freezeAccount !== void 0)
            forPrinting.freezeAccount = encodeAddress(forPrinting.freezeAccount.publicKey);
          if (forPrinting.closeRemainderTo !== void 0)
            forPrinting.closeRemainderTo = encodeAddress(forPrinting.closeRemainderTo.publicKey);
          if (forPrinting.assetManager !== void 0)
            forPrinting.assetManager = encodeAddress(forPrinting.assetManager.publicKey);
          if (forPrinting.assetReserve !== void 0)
            forPrinting.assetReserve = encodeAddress(forPrinting.assetReserve.publicKey);
          if (forPrinting.assetFreeze !== void 0)
            forPrinting.assetFreeze = encodeAddress(forPrinting.assetFreeze.publicKey);
          if (forPrinting.assetClawback !== void 0)
            forPrinting.assetClawback = encodeAddress(forPrinting.assetClawback.publicKey);
          if (forPrinting.assetRevocationTarget !== void 0)
            forPrinting.assetRevocationTarget = encodeAddress(forPrinting.assetRevocationTarget.publicKey);
          if (forPrinting.reKeyTo !== void 0)
            forPrinting.reKeyTo = encodeAddress(forPrinting.reKeyTo.publicKey);
          forPrinting.genesisHash = forPrinting.genesisHash.toString("base64");
          return forPrinting;
        }
        prettyPrint() {
          console.log(this._getDictForDisplay());
        }
        toString() {
          return JSON.stringify(this._getDictForDisplay());
        }
      };
      transaction_default = Transaction;
    }
  });

  // node_modules/algosdk/dist/esm/src/group.js
  var group_exports = {};
  __export(group_exports, {
    TxGroup: () => TxGroup,
    assignGroupID: () => assignGroupID,
    computeGroupID: () => computeGroupID,
    default: () => group_default
  });
  function computeGroupID(txns) {
    const hashes = [];
    for (const txn of txns) {
      const tx = instantiateTxnIfNeeded(txn);
      hashes.push(tx.rawTxID());
    }
    const txgroup = new TxGroup(hashes);
    const bytes = txgroup.toByte();
    const toBeHashed = Buffer.from(concatArrays(txgroup.tag, bytes));
    const gid = genericHash(toBeHashed);
    return Buffer.from(gid);
  }
  function assignGroupID(txns, from) {
    const gid = computeGroupID(txns);
    const result = [];
    for (const txn of txns) {
      const tx = instantiateTxnIfNeeded(txn);
      if (!from || encodeAddress(tx.from.publicKey) === from) {
        tx.group = gid;
        result.push(tx);
      }
    }
    return result;
  }
  var ALGORAND_MAX_TX_GROUP_SIZE, TxGroup, group_default;
  var init_group = __esm({
    "node_modules/algosdk/dist/esm/src/group.js"() {
      init_transaction();
      init_naclWrappers();
      init_encoding();
      init_address();
      init_utils();
      ALGORAND_MAX_TX_GROUP_SIZE = 16;
      TxGroup = class {
        constructor(hashes) {
          this.name = "Transaction group";
          this.tag = Buffer.from("TG");
          if (hashes.length > ALGORAND_MAX_TX_GROUP_SIZE) {
            const errorMsg = `${hashes.length.toString()} transactions grouped together but max group size is ${ALGORAND_MAX_TX_GROUP_SIZE.toString()}`;
            throw Error(errorMsg);
          }
          this.txGroupHashes = hashes;
        }
        get_obj_for_encoding() {
          const txgroup = {
            txlist: this.txGroupHashes
          };
          return txgroup;
        }
        static from_obj_for_encoding(txgroupForEnc) {
          const txn = Object.create(this.prototype);
          txn.name = "Transaction group";
          txn.tag = Buffer.from("TG");
          txn.txGroupHashes = [];
          for (const hash of txgroupForEnc.txlist) {
            txn.txGroupHashes.push(Buffer.from(hash));
          }
          return txn;
        }
        toByte() {
          return encode2(this.get_obj_for_encoding());
        }
      };
      group_default = TxGroup;
    }
  });

  // node_modules/algosdk/dist/esm/src/logic/langspec.json
  var EvalMaxVersion, LogicSigVersion, Ops, langspec_default;
  var init_langspec = __esm({
    "node_modules/algosdk/dist/esm/src/logic/langspec.json"() {
      EvalMaxVersion = 5;
      LogicSigVersion = 5;
      Ops = [
        {
          Opcode: 0,
          Name: "err",
          Cost: 1,
          Size: 1,
          Doc: "Error. Fail immediately. This is primarily a fencepost against accidental zero bytes getting compiled into programs.",
          Groups: ["Flow Control"]
        },
        {
          Opcode: 1,
          Name: "sha256",
          Args: "B",
          Returns: "B",
          Cost: 35,
          Size: 1,
          Doc: "SHA256 hash of value X, yields [32]byte",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 2,
          Name: "keccak256",
          Args: "B",
          Returns: "B",
          Cost: 130,
          Size: 1,
          Doc: "Keccak256 hash of value X, yields [32]byte",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 3,
          Name: "sha512_256",
          Args: "B",
          Returns: "B",
          Cost: 45,
          Size: 1,
          Doc: "SHA512_256 hash of value X, yields [32]byte",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 4,
          Name: "ed25519verify",
          Args: "BBB",
          Returns: "U",
          Cost: 1900,
          Size: 1,
          Doc: 'for (data A, signature B, pubkey C) verify the signature of ("ProgData" || program_hash || data) against the pubkey => {0 or 1}',
          DocExtra: "The 32 byte public key is the last element on the stack, preceded by the 64 byte signature at the second-to-last element on the stack, preceded by the data which was signed at the third-to-last element on the stack.",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 5,
          Name: "ecdsa_verify",
          Args: "BBBBB",
          Returns: "U",
          Cost: 1700,
          Size: 2,
          Doc: "for (data A, signature B, C and pubkey D, E) verify the signature of the data against the pubkey => {0 or 1}",
          DocExtra: "The 32 byte Y-component of a public key is the last element on the stack, preceded by X-component of a pubkey, preceded by S and R components of a signature, preceded by the data that is fifth element on the stack. All values are big-endian encoded. The signed data must be 32 bytes long, and signatures in lower-S form are only accepted.",
          ImmediateNote: "{uint8 curve index}",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 6,
          Name: "ecdsa_pk_decompress",
          Args: "B",
          Returns: "BB",
          Cost: 650,
          Size: 2,
          Doc: "decompress pubkey A into components X, Y => [*... stack*, X, Y]",
          DocExtra: "The 33 byte public key in a compressed form to be decompressed into X and Y (top) components. All values are big-endian encoded.",
          ImmediateNote: "{uint8 curve index}",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 7,
          Name: "ecdsa_pk_recover",
          Args: "BUBB",
          Returns: "BB",
          Cost: 2e3,
          Size: 2,
          Doc: "for (data A, recovery id B, signature C, D) recover a public key => [*... stack*, X, Y]",
          DocExtra: "S (top) and R elements of a signature, recovery id and data (bottom) are expected on the stack and used to deriver a public key. All values are big-endian encoded. The signed data must be 32 bytes long.",
          ImmediateNote: "{uint8 curve index}",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 8,
          Name: "+",
          Args: "UU",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A plus B. Fail on overflow.",
          DocExtra: "Overflow is an error condition which halts execution and fails the transaction. Full precision is available from `addw`.",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 9,
          Name: "-",
          Args: "UU",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A minus B. Fail if B > A.",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 10,
          Name: "/",
          Args: "UU",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A divided by B (truncated division). Fail if B == 0.",
          DocExtra: "`divmodw` is available to divide the two-element values produced by `mulw` and `addw`.",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 11,
          Name: "*",
          Args: "UU",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A times B. Fail on overflow.",
          DocExtra: "Overflow is an error condition which halts execution and fails the transaction. Full precision is available from `mulw`.",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 12,
          Name: "<",
          Args: "UU",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A less than B => {0 or 1}",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 13,
          Name: ">",
          Args: "UU",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A greater than B => {0 or 1}",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 14,
          Name: "<=",
          Args: "UU",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A less than or equal to B => {0 or 1}",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 15,
          Name: ">=",
          Args: "UU",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A greater than or equal to B => {0 or 1}",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 16,
          Name: "&&",
          Args: "UU",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A is not zero and B is not zero => {0 or 1}",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 17,
          Name: "||",
          Args: "UU",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A is not zero or B is not zero => {0 or 1}",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 18,
          Name: "==",
          Args: "..",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A is equal to B => {0 or 1}",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 19,
          Name: "!=",
          Args: "..",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A is not equal to B => {0 or 1}",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 20,
          Name: "!",
          Args: "U",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "X == 0 yields 1; else 0",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 21,
          Name: "len",
          Args: "B",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "yields length of byte value X",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 22,
          Name: "itob",
          Args: "U",
          Returns: "B",
          Cost: 1,
          Size: 1,
          Doc: "converts uint64 X to big endian bytes",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 23,
          Name: "btoi",
          Args: "B",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "converts bytes X as big endian to uint64",
          DocExtra: "`btoi` fails if the input is longer than 8 bytes.",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 24,
          Name: "%",
          Args: "UU",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A modulo B. Fail if B == 0.",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 25,
          Name: "|",
          Args: "UU",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A bitwise-or B",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 26,
          Name: "&",
          Args: "UU",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A bitwise-and B",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 27,
          Name: "^",
          Args: "UU",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A bitwise-xor B",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 28,
          Name: "~",
          Args: "U",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "bitwise invert value X",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 29,
          Name: "mulw",
          Args: "UU",
          Returns: "UU",
          Cost: 1,
          Size: 1,
          Doc: "A times B out to 128-bit long result as low (top) and high uint64 values on the stack",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 30,
          Name: "addw",
          Args: "UU",
          Returns: "UU",
          Cost: 1,
          Size: 1,
          Doc: "A plus B out to 128-bit long result as sum (top) and carry-bit uint64 values on the stack",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 31,
          Name: "divmodw",
          Args: "UUUU",
          Returns: "UUUU",
          Cost: 20,
          Size: 1,
          Doc: "Pop four uint64 values.  The deepest two are interpreted as a uint128 dividend (deepest value is high word), the top two are interpreted as a uint128 divisor.  Four uint64 values are pushed to the stack. The deepest two are the quotient (deeper value is the high uint64). The top two are the remainder, low bits on top.",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 32,
          Name: "intcblock",
          Cost: 1,
          Size: 0,
          Doc: "prepare block of uint64 constants for use by intc",
          DocExtra: "`intcblock` loads following program bytes into an array of integer constants in the evaluator. These integer constants can be referred to by `intc` and `intc_*` which will push the value onto the stack. Subsequent calls to `intcblock` reset and replace the integer constants available to the script.",
          ImmediateNote: "{varuint length} [{varuint value}, ...]",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 33,
          Name: "intc",
          Returns: "U",
          Cost: 1,
          Size: 2,
          Doc: "push Ith constant from intcblock to stack",
          ImmediateNote: "{uint8 int constant index}",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 34,
          Name: "intc_0",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "push constant 0 from intcblock to stack",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 35,
          Name: "intc_1",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "push constant 1 from intcblock to stack",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 36,
          Name: "intc_2",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "push constant 2 from intcblock to stack",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 37,
          Name: "intc_3",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "push constant 3 from intcblock to stack",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 38,
          Name: "bytecblock",
          Cost: 1,
          Size: 0,
          Doc: "prepare block of byte-array constants for use by bytec",
          DocExtra: "`bytecblock` loads the following program bytes into an array of byte-array constants in the evaluator. These constants can be referred to by `bytec` and `bytec_*` which will push the value onto the stack. Subsequent calls to `bytecblock` reset and replace the bytes constants available to the script.",
          ImmediateNote: "{varuint length} [({varuint value length} bytes), ...]",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 39,
          Name: "bytec",
          Returns: "B",
          Cost: 1,
          Size: 2,
          Doc: "push Ith constant from bytecblock to stack",
          ImmediateNote: "{uint8 byte constant index}",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 40,
          Name: "bytec_0",
          Returns: "B",
          Cost: 1,
          Size: 1,
          Doc: "push constant 0 from bytecblock to stack",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 41,
          Name: "bytec_1",
          Returns: "B",
          Cost: 1,
          Size: 1,
          Doc: "push constant 1 from bytecblock to stack",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 42,
          Name: "bytec_2",
          Returns: "B",
          Cost: 1,
          Size: 1,
          Doc: "push constant 2 from bytecblock to stack",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 43,
          Name: "bytec_3",
          Returns: "B",
          Cost: 1,
          Size: 1,
          Doc: "push constant 3 from bytecblock to stack",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 44,
          Name: "arg",
          Returns: "B",
          Cost: 1,
          Size: 2,
          Doc: "push Nth LogicSig argument to stack",
          ImmediateNote: "{uint8 arg index N}",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 45,
          Name: "arg_0",
          Returns: "B",
          Cost: 1,
          Size: 1,
          Doc: "push LogicSig argument 0 to stack",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 46,
          Name: "arg_1",
          Returns: "B",
          Cost: 1,
          Size: 1,
          Doc: "push LogicSig argument 1 to stack",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 47,
          Name: "arg_2",
          Returns: "B",
          Cost: 1,
          Size: 1,
          Doc: "push LogicSig argument 2 to stack",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 48,
          Name: "arg_3",
          Returns: "B",
          Cost: 1,
          Size: 1,
          Doc: "push LogicSig argument 3 to stack",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 49,
          Name: "txn",
          Returns: ".",
          Cost: 1,
          Size: 2,
          ArgEnum: [
            "Sender",
            "Fee",
            "FirstValid",
            "FirstValidTime",
            "LastValid",
            "Note",
            "Lease",
            "Receiver",
            "Amount",
            "CloseRemainderTo",
            "VotePK",
            "SelectionPK",
            "VoteFirst",
            "VoteLast",
            "VoteKeyDilution",
            "Type",
            "TypeEnum",
            "XferAsset",
            "AssetAmount",
            "AssetSender",
            "AssetReceiver",
            "AssetCloseTo",
            "GroupIndex",
            "TxID",
            "ApplicationID",
            "OnCompletion",
            "ApplicationArgs",
            "NumAppArgs",
            "Accounts",
            "NumAccounts",
            "ApprovalProgram",
            "ClearStateProgram",
            "RekeyTo",
            "ConfigAsset",
            "ConfigAssetTotal",
            "ConfigAssetDecimals",
            "ConfigAssetDefaultFrozen",
            "ConfigAssetUnitName",
            "ConfigAssetName",
            "ConfigAssetURL",
            "ConfigAssetMetadataHash",
            "ConfigAssetManager",
            "ConfigAssetReserve",
            "ConfigAssetFreeze",
            "ConfigAssetClawback",
            "FreezeAsset",
            "FreezeAssetAccount",
            "FreezeAssetFrozen",
            "Assets",
            "NumAssets",
            "Applications",
            "NumApplications",
            "GlobalNumUint",
            "GlobalNumByteSlice",
            "LocalNumUint",
            "LocalNumByteSlice",
            "ExtraProgramPages",
            "Nonparticipation",
            "Logs",
            "NumLogs",
            "CreatedAssetID",
            "CreatedApplicationID"
          ],
          ArgEnumTypes: "BUUUUBBBUBBBUUUBUUUBBBUBUUBUBUBBBUUUUBBBBBBBBUBUUUUUUUUUUUBUUU",
          Doc: "push field F of current transaction to stack",
          DocExtra: "FirstValidTime causes the program to fail. The field is reserved for future use.",
          ImmediateNote: "{uint8 transaction field index}",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 50,
          Name: "global",
          Returns: ".",
          Cost: 1,
          Size: 2,
          ArgEnum: [
            "MinTxnFee",
            "MinBalance",
            "MaxTxnLife",
            "ZeroAddress",
            "GroupSize",
            "LogicSigVersion",
            "Round",
            "LatestTimestamp",
            "CurrentApplicationID",
            "CreatorAddress",
            "CurrentApplicationAddress",
            "GroupID"
          ],
          ArgEnumTypes: "UUUBUUUUUBBB",
          Doc: "push value from globals to stack",
          ImmediateNote: "{uint8 global field index}",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 51,
          Name: "gtxn",
          Returns: ".",
          Cost: 1,
          Size: 3,
          ArgEnum: [
            "Sender",
            "Fee",
            "FirstValid",
            "FirstValidTime",
            "LastValid",
            "Note",
            "Lease",
            "Receiver",
            "Amount",
            "CloseRemainderTo",
            "VotePK",
            "SelectionPK",
            "VoteFirst",
            "VoteLast",
            "VoteKeyDilution",
            "Type",
            "TypeEnum",
            "XferAsset",
            "AssetAmount",
            "AssetSender",
            "AssetReceiver",
            "AssetCloseTo",
            "GroupIndex",
            "TxID",
            "ApplicationID",
            "OnCompletion",
            "ApplicationArgs",
            "NumAppArgs",
            "Accounts",
            "NumAccounts",
            "ApprovalProgram",
            "ClearStateProgram",
            "RekeyTo",
            "ConfigAsset",
            "ConfigAssetTotal",
            "ConfigAssetDecimals",
            "ConfigAssetDefaultFrozen",
            "ConfigAssetUnitName",
            "ConfigAssetName",
            "ConfigAssetURL",
            "ConfigAssetMetadataHash",
            "ConfigAssetManager",
            "ConfigAssetReserve",
            "ConfigAssetFreeze",
            "ConfigAssetClawback",
            "FreezeAsset",
            "FreezeAssetAccount",
            "FreezeAssetFrozen",
            "Assets",
            "NumAssets",
            "Applications",
            "NumApplications",
            "GlobalNumUint",
            "GlobalNumByteSlice",
            "LocalNumUint",
            "LocalNumByteSlice",
            "ExtraProgramPages",
            "Nonparticipation",
            "Logs",
            "NumLogs",
            "CreatedAssetID",
            "CreatedApplicationID"
          ],
          ArgEnumTypes: "BUUUUBBBUBBBUUUBUUUBBBUBUUBUBUBBBUUUUBBBBBBBBUBUUUUUUUUUUUBUUU",
          Doc: "push field F of the Tth transaction in the current group",
          DocExtra: "for notes on transaction fields available, see `txn`. If this transaction is _i_ in the group, `gtxn i field` is equivalent to `txn field`.",
          ImmediateNote: "{uint8 transaction group index} {uint8 transaction field index}",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 52,
          Name: "load",
          Returns: ".",
          Cost: 1,
          Size: 2,
          Doc: "copy a value from scratch space to the stack. All scratch spaces are 0 at program start.",
          ImmediateNote: "{uint8 position in scratch space to load from}",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 53,
          Name: "store",
          Args: ".",
          Cost: 1,
          Size: 2,
          Doc: "pop value X. store X to the Ith scratch space",
          ImmediateNote: "{uint8 position in scratch space to store to}",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 54,
          Name: "txna",
          Returns: ".",
          Cost: 1,
          Size: 3,
          ArgEnum: [
            "ApplicationArgs",
            "Accounts",
            "Assets",
            "Applications",
            "Logs"
          ],
          ArgEnumTypes: "BBUUB",
          Doc: "push Ith value of the array field F of the current transaction",
          ImmediateNote: "{uint8 transaction field index} {uint8 transaction field array index}",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 55,
          Name: "gtxna",
          Returns: ".",
          Cost: 1,
          Size: 4,
          ArgEnum: [
            "ApplicationArgs",
            "Accounts",
            "Assets",
            "Applications",
            "Logs"
          ],
          ArgEnumTypes: "BBUUB",
          Doc: "push Ith value of the array field F from the Tth transaction in the current group",
          ImmediateNote: "{uint8 transaction group index} {uint8 transaction field index} {uint8 transaction field array index}",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 56,
          Name: "gtxns",
          Args: "U",
          Returns: ".",
          Cost: 1,
          Size: 2,
          ArgEnum: [
            "Sender",
            "Fee",
            "FirstValid",
            "FirstValidTime",
            "LastValid",
            "Note",
            "Lease",
            "Receiver",
            "Amount",
            "CloseRemainderTo",
            "VotePK",
            "SelectionPK",
            "VoteFirst",
            "VoteLast",
            "VoteKeyDilution",
            "Type",
            "TypeEnum",
            "XferAsset",
            "AssetAmount",
            "AssetSender",
            "AssetReceiver",
            "AssetCloseTo",
            "GroupIndex",
            "TxID",
            "ApplicationID",
            "OnCompletion",
            "ApplicationArgs",
            "NumAppArgs",
            "Accounts",
            "NumAccounts",
            "ApprovalProgram",
            "ClearStateProgram",
            "RekeyTo",
            "ConfigAsset",
            "ConfigAssetTotal",
            "ConfigAssetDecimals",
            "ConfigAssetDefaultFrozen",
            "ConfigAssetUnitName",
            "ConfigAssetName",
            "ConfigAssetURL",
            "ConfigAssetMetadataHash",
            "ConfigAssetManager",
            "ConfigAssetReserve",
            "ConfigAssetFreeze",
            "ConfigAssetClawback",
            "FreezeAsset",
            "FreezeAssetAccount",
            "FreezeAssetFrozen",
            "Assets",
            "NumAssets",
            "Applications",
            "NumApplications",
            "GlobalNumUint",
            "GlobalNumByteSlice",
            "LocalNumUint",
            "LocalNumByteSlice",
            "ExtraProgramPages",
            "Nonparticipation",
            "Logs",
            "NumLogs",
            "CreatedAssetID",
            "CreatedApplicationID"
          ],
          ArgEnumTypes: "BUUUUBBBUBBBUUUBUUUBBBUBUUBUBUBBBUUUUBBBBBBBBUBUUUUUUUUUUUBUUU",
          Doc: "push field F of the Xth transaction in the current group",
          DocExtra: "for notes on transaction fields available, see `txn`. If top of stack is _i_, `gtxns field` is equivalent to `gtxn _i_ field`. gtxns exists so that _i_ can be calculated, often based on the index of the current transaction.",
          ImmediateNote: "{uint8 transaction field index}",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 57,
          Name: "gtxnsa",
          Args: "U",
          Returns: ".",
          Cost: 1,
          Size: 3,
          ArgEnum: [
            "ApplicationArgs",
            "Accounts",
            "Assets",
            "Applications",
            "Logs"
          ],
          ArgEnumTypes: "BBUUB",
          Doc: "push Ith value of the array field F from the Xth transaction in the current group",
          ImmediateNote: "{uint8 transaction field index} {uint8 transaction field array index}",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 58,
          Name: "gload",
          Returns: ".",
          Cost: 1,
          Size: 3,
          Doc: "push Ith scratch space index of the Tth transaction in the current group",
          DocExtra: "`gload` fails unless the requested transaction is an ApplicationCall and T < GroupIndex.",
          ImmediateNote: "{uint8 transaction group index} {uint8 position in scratch space to load from}",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 59,
          Name: "gloads",
          Args: "U",
          Returns: ".",
          Cost: 1,
          Size: 2,
          Doc: "push Ith scratch space index of the Xth transaction in the current group",
          DocExtra: "`gloads` fails unless the requested transaction is an ApplicationCall and X < GroupIndex.",
          ImmediateNote: "{uint8 position in scratch space to load from}",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 60,
          Name: "gaid",
          Returns: "U",
          Cost: 1,
          Size: 2,
          Doc: "push the ID of the asset or application created in the Tth transaction of the current group",
          DocExtra: "`gaid` fails unless the requested transaction created an asset or application and T < GroupIndex.",
          ImmediateNote: "{uint8 transaction group index}",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 61,
          Name: "gaids",
          Args: "U",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "push the ID of the asset or application created in the Xth transaction of the current group",
          DocExtra: "`gaids` fails unless the requested transaction created an asset or application and X < GroupIndex.",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 62,
          Name: "loads",
          Args: "U",
          Returns: ".",
          Cost: 1,
          Size: 1,
          Doc: "copy a value from the Xth scratch space to the stack.  All scratch spaces are 0 at program start.",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 63,
          Name: "stores",
          Args: "U.",
          Cost: 1,
          Size: 1,
          Doc: "pop indexes A and B. store B to the Ath scratch space",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 64,
          Name: "bnz",
          Args: "U",
          Cost: 1,
          Size: 3,
          Doc: "branch to TARGET if value X is not zero",
          DocExtra: "The `bnz` instruction opcode 0x40 is followed by two immediate data bytes which are a high byte first and low byte second which together form a 16 bit offset which the instruction may branch to. For a bnz instruction at `pc`, if the last element of the stack is not zero then branch to instruction at `pc + 3 + N`, else proceed to next instruction at `pc + 3`. Branch targets must be aligned instructions. (e.g. Branching to the second byte of a 2 byte op will be rejected.) Starting at v4, the offset is treated as a signed 16 bit integer allowing for backward branches and looping. In prior version (v1 to v3), branch offsets are limited to forward branches only, 0-0x7fff.\n\nAt v2 it became allowed to branch to the end of the program exactly after the last instruction: bnz to byte N (with 0-indexing) was illegal for a TEAL program with N bytes before v2, and is legal after it. This change eliminates the need for a last instruction of no-op as a branch target at the end. (Branching beyond the end--in other words, to a byte larger than N--is still illegal and will cause the program to fail.)",
          ImmediateNote: "{int16 branch offset, big endian}",
          Groups: ["Flow Control"]
        },
        {
          Opcode: 65,
          Name: "bz",
          Args: "U",
          Cost: 1,
          Size: 3,
          Doc: "branch to TARGET if value X is zero",
          DocExtra: "See `bnz` for details on how branches work. `bz` inverts the behavior of `bnz`.",
          ImmediateNote: "{int16 branch offset, big endian}",
          Groups: ["Flow Control"]
        },
        {
          Opcode: 66,
          Name: "b",
          Cost: 1,
          Size: 3,
          Doc: "branch unconditionally to TARGET",
          DocExtra: "See `bnz` for details on how branches work. `b` always jumps to the offset.",
          ImmediateNote: "{int16 branch offset, big endian}",
          Groups: ["Flow Control"]
        },
        {
          Opcode: 67,
          Name: "return",
          Args: "U",
          Cost: 1,
          Size: 1,
          Doc: "use last value on stack as success value; end",
          Groups: ["Flow Control"]
        },
        {
          Opcode: 68,
          Name: "assert",
          Args: "U",
          Cost: 1,
          Size: 1,
          Doc: "immediately fail unless value X is a non-zero number",
          Groups: ["Flow Control"]
        },
        {
          Opcode: 72,
          Name: "pop",
          Args: ".",
          Cost: 1,
          Size: 1,
          Doc: "discard value X from stack",
          Groups: ["Flow Control"]
        },
        {
          Opcode: 73,
          Name: "dup",
          Args: ".",
          Returns: "..",
          Cost: 1,
          Size: 1,
          Doc: "duplicate last value on stack",
          Groups: ["Flow Control"]
        },
        {
          Opcode: 74,
          Name: "dup2",
          Args: "..",
          Returns: "....",
          Cost: 1,
          Size: 1,
          Doc: "duplicate two last values on stack: A, B -> A, B, A, B",
          Groups: ["Flow Control"]
        },
        {
          Opcode: 75,
          Name: "dig",
          Args: ".",
          Returns: "..",
          Cost: 1,
          Size: 2,
          Doc: "push the Nth value from the top of the stack. dig 0 is equivalent to dup",
          ImmediateNote: "{uint8 depth}",
          Groups: ["Flow Control"]
        },
        {
          Opcode: 76,
          Name: "swap",
          Args: "..",
          Returns: "..",
          Cost: 1,
          Size: 1,
          Doc: "swaps two last values on stack: A, B -> B, A",
          Groups: ["Flow Control"]
        },
        {
          Opcode: 77,
          Name: "select",
          Args: "..U",
          Returns: ".",
          Cost: 1,
          Size: 1,
          Doc: "selects one of two values based on top-of-stack: A, B, C -> (if C != 0 then B else A)",
          Groups: ["Flow Control"]
        },
        {
          Opcode: 78,
          Name: "cover",
          Args: ".",
          Returns: ".",
          Cost: 1,
          Size: 2,
          Doc: "remove top of stack, and place it deeper in the stack such that N elements are above it. Fails if stack depth <= N.",
          ImmediateNote: "{uint8 depth}",
          Groups: ["Flow Control"]
        },
        {
          Opcode: 79,
          Name: "uncover",
          Args: ".",
          Returns: ".",
          Cost: 1,
          Size: 2,
          Doc: "remove the value at depth N in the stack and shift above items down so the Nth deep value is on top of the stack. Fails if stack depth <= N.",
          ImmediateNote: "{uint8 depth}",
          Groups: ["Flow Control"]
        },
        {
          Opcode: 80,
          Name: "concat",
          Args: "BB",
          Returns: "B",
          Cost: 1,
          Size: 1,
          Doc: "pop two byte-arrays A and B and join them, push the result",
          DocExtra: "`concat` fails if the result would be greater than 4096 bytes.",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 81,
          Name: "substring",
          Args: "B",
          Returns: "B",
          Cost: 1,
          Size: 3,
          Doc: "pop a byte-array A. For immediate values in 0..255 S and E: extract a range of bytes from A starting at S up to but not including E, push the substring result. If E < S, or either is larger than the array length, the program fails",
          ImmediateNote: "{uint8 start position} {uint8 end position}",
          Groups: ["Byte Array Slicing"]
        },
        {
          Opcode: 82,
          Name: "substring3",
          Args: "BUU",
          Returns: "B",
          Cost: 1,
          Size: 1,
          Doc: "pop a byte-array A and two integers B and C. Extract a range of bytes from A starting at B up to but not including C, push the substring result. If C < B, or either is larger than the array length, the program fails",
          Groups: ["Byte Array Slicing"]
        },
        {
          Opcode: 83,
          Name: "getbit",
          Args: ".U",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "pop a target A (integer or byte-array), and index B. Push the Bth bit of A.",
          DocExtra: "see explanation of bit ordering in setbit",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 84,
          Name: "setbit",
          Args: ".UU",
          Returns: ".",
          Cost: 1,
          Size: 1,
          Doc: "pop a target A, index B, and bit C. Set the Bth bit of A to C, and push the result",
          DocExtra: "When A is a uint64, index 0 is the least significant bit. Setting bit 3 to 1 on the integer 0 yields 8, or 2^3. When A is a byte array, index 0 is the leftmost bit of the leftmost byte. Setting bits 0 through 11 to 1 in a 4-byte-array of 0s yields the byte array 0xfff00000. Setting bit 3 to 1 on the 1-byte-array 0x00 yields the byte array 0x10.",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 85,
          Name: "getbyte",
          Args: "BU",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "pop a byte-array A and integer B. Extract the Bth byte of A and push it as an integer",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 86,
          Name: "setbyte",
          Args: "BUU",
          Returns: "B",
          Cost: 1,
          Size: 1,
          Doc: "pop a byte-array A, integer B, and small integer C (between 0..255). Set the Bth byte of A to C, and push the result",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 87,
          Name: "extract",
          Args: "B",
          Returns: "B",
          Cost: 1,
          Size: 3,
          Doc: "pop a byte-array A. For immediate values in 0..255 S and L: extract a range of bytes from A starting at S up to but not including S+L, push the substring result. If L is 0, then extract to the end of the string. If S or S+L is larger than the array length, the program fails",
          ImmediateNote: "{uint8 start position} {uint8 length}",
          Groups: ["Byte Array Slicing"]
        },
        {
          Opcode: 88,
          Name: "extract3",
          Args: "BUU",
          Returns: "B",
          Cost: 1,
          Size: 1,
          Doc: "pop a byte-array A and two integers B and C. Extract a range of bytes from A starting at B up to but not including B+C, push the substring result. If B+C is larger than the array length, the program fails",
          Groups: ["Byte Array Slicing"]
        },
        {
          Opcode: 89,
          Name: "extract_uint16",
          Args: "BU",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "pop a byte-array A and integer B. Extract a range of bytes from A starting at B up to but not including B+2, convert bytes as big endian and push the uint64 result. If B+2 is larger than the array length, the program fails",
          Groups: ["Byte Array Slicing"]
        },
        {
          Opcode: 90,
          Name: "extract_uint32",
          Args: "BU",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "pop a byte-array A and integer B. Extract a range of bytes from A starting at B up to but not including B+4, convert bytes as big endian and push the uint64 result. If B+4 is larger than the array length, the program fails",
          Groups: ["Byte Array Slicing"]
        },
        {
          Opcode: 91,
          Name: "extract_uint64",
          Args: "BU",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "pop a byte-array A and integer B. Extract a range of bytes from A starting at B up to but not including B+8, convert bytes as big endian and push the uint64 result. If B+8 is larger than the array length, the program fails",
          Groups: ["Byte Array Slicing"]
        },
        {
          Opcode: 96,
          Name: "balance",
          Args: ".",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "get balance for account A, in microalgos. The balance is observed after the effects of previous transactions in the group, and after the fee for the current transaction is deducted.",
          DocExtra: "params: Before v4, Txn.Accounts offset. Since v4, Txn.Accounts offset or an account address that appears in Txn.Accounts or is Txn.Sender). Return: value.",
          Groups: ["State Access"]
        },
        {
          Opcode: 97,
          Name: "app_opted_in",
          Args: ".U",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "check if account A opted in for the application B => {0 or 1}",
          DocExtra: "params: Txn.Accounts offset (or, since v4, an account address that appears in Txn.Accounts or is Txn.Sender), application id (or, since v4, a Txn.ForeignApps offset). Return: 1 if opted in and 0 otherwise.",
          Groups: ["State Access"]
        },
        {
          Opcode: 98,
          Name: "app_local_get",
          Args: ".B",
          Returns: ".",
          Cost: 1,
          Size: 1,
          Doc: "read from account A from local state of the current application key B => value",
          DocExtra: "params: Txn.Accounts offset (or, since v4, an account address that appears in Txn.Accounts or is Txn.Sender), state key. Return: value. The value is zero (of type uint64) if the key does not exist.",
          Groups: ["State Access"]
        },
        {
          Opcode: 99,
          Name: "app_local_get_ex",
          Args: ".UB",
          Returns: ".U",
          Cost: 1,
          Size: 1,
          Doc: "read from account A from local state of the application B key C => [*... stack*, value, 0 or 1]",
          DocExtra: "params: Txn.Accounts offset (or, since v4, an account address that appears in Txn.Accounts or is Txn.Sender), application id (or, since v4, a Txn.ForeignApps offset), state key. Return: did_exist flag (top of the stack, 1 if the application existed and 0 otherwise), value. The value is zero (of type uint64) if the key does not exist.",
          Groups: ["State Access"]
        },
        {
          Opcode: 100,
          Name: "app_global_get",
          Args: "B",
          Returns: ".",
          Cost: 1,
          Size: 1,
          Doc: "read key A from global state of a current application => value",
          DocExtra: "params: state key. Return: value. The value is zero (of type uint64) if the key does not exist.",
          Groups: ["State Access"]
        },
        {
          Opcode: 101,
          Name: "app_global_get_ex",
          Args: "UB",
          Returns: ".U",
          Cost: 1,
          Size: 1,
          Doc: "read from application A global state key B => [*... stack*, value, 0 or 1]",
          DocExtra: "params: Txn.ForeignApps offset (or, since v4, an application id that appears in Txn.ForeignApps or is the CurrentApplicationID), state key. Return: did_exist flag (top of the stack, 1 if the application existed and 0 otherwise), value. The value is zero (of type uint64) if the key does not exist.",
          Groups: ["State Access"]
        },
        {
          Opcode: 102,
          Name: "app_local_put",
          Args: ".B.",
          Cost: 1,
          Size: 1,
          Doc: "write to account specified by A to local state of a current application key B with value C",
          DocExtra: "params: Txn.Accounts offset (or, since v4, an account address that appears in Txn.Accounts or is Txn.Sender), state key, value.",
          Groups: ["State Access"]
        },
        {
          Opcode: 103,
          Name: "app_global_put",
          Args: "B.",
          Cost: 1,
          Size: 1,
          Doc: "write key A and value B to global state of the current application",
          Groups: ["State Access"]
        },
        {
          Opcode: 104,
          Name: "app_local_del",
          Args: ".B",
          Cost: 1,
          Size: 1,
          Doc: "delete from account A local state key B of the current application",
          DocExtra: "params: Txn.Accounts offset (or, since v4, an account address that appears in Txn.Accounts or is Txn.Sender), state key.\n\nDeleting a key which is already absent has no effect on the application local state. (In particular, it does _not_ cause the program to fail.)",
          Groups: ["State Access"]
        },
        {
          Opcode: 105,
          Name: "app_global_del",
          Args: "B",
          Cost: 1,
          Size: 1,
          Doc: "delete key A from a global state of the current application",
          DocExtra: "params: state key.\n\nDeleting a key which is already absent has no effect on the application global state. (In particular, it does _not_ cause the program to fail.)",
          Groups: ["State Access"]
        },
        {
          Opcode: 112,
          Name: "asset_holding_get",
          Args: ".U",
          Returns: ".U",
          Cost: 1,
          Size: 2,
          ArgEnum: ["AssetBalance", "AssetFrozen"],
          ArgEnumTypes: "UU",
          Doc: "read from account A and asset B holding field X (imm arg) => {0 or 1 (top), value}",
          DocExtra: "params: Txn.Accounts offset (or, since v4, an account address that appears in Txn.Accounts or is Txn.Sender), asset id (or, since v4, a Txn.ForeignAssets offset). Return: did_exist flag (1 if the asset existed and 0 otherwise), value.",
          ImmediateNote: "{uint8 asset holding field index}",
          Groups: ["State Access"]
        },
        {
          Opcode: 113,
          Name: "asset_params_get",
          Args: "U",
          Returns: ".U",
          Cost: 1,
          Size: 2,
          ArgEnum: [
            "AssetTotal",
            "AssetDecimals",
            "AssetDefaultFrozen",
            "AssetUnitName",
            "AssetName",
            "AssetURL",
            "AssetMetadataHash",
            "AssetManager",
            "AssetReserve",
            "AssetFreeze",
            "AssetClawback",
            "AssetCreator"
          ],
          ArgEnumTypes: "UUUBBBBBBBBB",
          Doc: "read from asset A params field X (imm arg) => {0 or 1 (top), value}",
          DocExtra: "params: Before v4, Txn.ForeignAssets offset. Since v4, Txn.ForeignAssets offset or an asset id that appears in Txn.ForeignAssets. Return: did_exist flag (1 if the asset existed and 0 otherwise), value.",
          ImmediateNote: "{uint8 asset params field index}",
          Groups: ["State Access"]
        },
        {
          Opcode: 114,
          Name: "app_params_get",
          Args: "U",
          Returns: ".U",
          Cost: 1,
          Size: 2,
          ArgEnum: [
            "AppApprovalProgram",
            "AppClearStateProgram",
            "AppGlobalNumUint",
            "AppGlobalNumByteSlice",
            "AppLocalNumUint",
            "AppLocalNumByteSlice",
            "AppExtraProgramPages",
            "AppCreator",
            "AppAddress"
          ],
          ArgEnumTypes: "BBUUUUUBB",
          Doc: "read from app A params field X (imm arg) => {0 or 1 (top), value}",
          DocExtra: "params: Txn.ForeignApps offset or an app id that appears in Txn.ForeignApps. Return: did_exist flag (1 if the application existed and 0 otherwise), value.",
          ImmediateNote: "{uint8 app params field index}",
          Groups: ["State Access"]
        },
        {
          Opcode: 120,
          Name: "min_balance",
          Args: ".",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "get minimum required balance for account A, in microalgos. Required balance is affected by [ASA](https://developer.algorand.org/docs/features/asa/#assets-overview) and [App](https://developer.algorand.org/docs/features/asc1/stateful/#minimum-balance-requirement-for-a-smart-contract) usage. When creating or opting into an app, the minimum balance grows before the app code runs, therefore the increase is visible there. When deleting or closing out, the minimum balance decreases after the app executes.",
          DocExtra: "params: Before v4, Txn.Accounts offset. Since v4, Txn.Accounts offset or an account address that appears in Txn.Accounts or is Txn.Sender). Return: value.",
          Groups: ["State Access"]
        },
        {
          Opcode: 128,
          Name: "pushbytes",
          Returns: "B",
          Cost: 1,
          Size: 0,
          Doc: "push the following program bytes to the stack",
          DocExtra: "pushbytes args are not added to the bytecblock during assembly processes",
          ImmediateNote: "{varuint length} {bytes}",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 129,
          Name: "pushint",
          Returns: "U",
          Cost: 1,
          Size: 0,
          Doc: "push immediate UINT to the stack as an integer",
          DocExtra: "pushint args are not added to the intcblock during assembly processes",
          ImmediateNote: "{varuint int}",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 136,
          Name: "callsub",
          Cost: 1,
          Size: 3,
          Doc: "branch unconditionally to TARGET, saving the next instruction on the call stack",
          DocExtra: "The call stack is separate from the data stack. Only `callsub` and `retsub` manipulate it.",
          ImmediateNote: "{int16 branch offset, big endian}",
          Groups: ["Flow Control"]
        },
        {
          Opcode: 137,
          Name: "retsub",
          Cost: 1,
          Size: 1,
          Doc: "pop the top instruction from the call stack and branch to it",
          DocExtra: "The call stack is separate from the data stack. Only `callsub` and `retsub` manipulate it.",
          Groups: ["Flow Control"]
        },
        {
          Opcode: 144,
          Name: "shl",
          Args: "UU",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A times 2^B, modulo 2^64",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 145,
          Name: "shr",
          Args: "UU",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A divided by 2^B",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 146,
          Name: "sqrt",
          Args: "U",
          Returns: "U",
          Cost: 4,
          Size: 1,
          Doc: "The largest integer B such that B^2 <= X",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 147,
          Name: "bitlen",
          Args: ".",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "The highest set bit in X. If X is a byte-array, it is interpreted as a big-endian unsigned integer. bitlen of 0 is 0, bitlen of 8 is 4",
          DocExtra: "bitlen interprets arrays as big-endian integers, unlike setbit/getbit",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 148,
          Name: "exp",
          Args: "UU",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A raised to the Bth power. Fail if A == B == 0 and on overflow",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 149,
          Name: "expw",
          Args: "UU",
          Returns: "UU",
          Cost: 10,
          Size: 1,
          Doc: "A raised to the Bth power as a 128-bit long result as low (top) and high uint64 values on the stack. Fail if A == B == 0 or if the results exceeds 2^128-1",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 160,
          Name: "b+",
          Args: "BB",
          Returns: "B",
          Cost: 10,
          Size: 1,
          Doc: "A plus B, where A and B are byte-arrays interpreted as big-endian unsigned integers",
          Groups: ["Byte Array Arithmetic"]
        },
        {
          Opcode: 161,
          Name: "b-",
          Args: "BB",
          Returns: "B",
          Cost: 10,
          Size: 1,
          Doc: "A minus B, where A and B are byte-arrays interpreted as big-endian unsigned integers. Fail on underflow.",
          Groups: ["Byte Array Arithmetic"]
        },
        {
          Opcode: 162,
          Name: "b/",
          Args: "BB",
          Returns: "B",
          Cost: 20,
          Size: 1,
          Doc: "A divided by B (truncated division), where A and B are byte-arrays interpreted as big-endian unsigned integers. Fail if B is zero.",
          Groups: ["Byte Array Arithmetic"]
        },
        {
          Opcode: 163,
          Name: "b*",
          Args: "BB",
          Returns: "B",
          Cost: 20,
          Size: 1,
          Doc: "A times B, where A and B are byte-arrays interpreted as big-endian unsigned integers.",
          Groups: ["Byte Array Arithmetic"]
        },
        {
          Opcode: 164,
          Name: "b<",
          Args: "BB",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A is less than B, where A and B are byte-arrays interpreted as big-endian unsigned integers => { 0 or 1}",
          Groups: ["Byte Array Arithmetic"]
        },
        {
          Opcode: 165,
          Name: "b>",
          Args: "BB",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A is greater than B, where A and B are byte-arrays interpreted as big-endian unsigned integers => { 0 or 1}",
          Groups: ["Byte Array Arithmetic"]
        },
        {
          Opcode: 166,
          Name: "b<=",
          Args: "BB",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A is less than or equal to B, where A and B are byte-arrays interpreted as big-endian unsigned integers => { 0 or 1}",
          Groups: ["Byte Array Arithmetic"]
        },
        {
          Opcode: 167,
          Name: "b>=",
          Args: "BB",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A is greater than or equal to B, where A and B are byte-arrays interpreted as big-endian unsigned integers => { 0 or 1}",
          Groups: ["Byte Array Arithmetic"]
        },
        {
          Opcode: 168,
          Name: "b==",
          Args: "BB",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A is equals to B, where A and B are byte-arrays interpreted as big-endian unsigned integers => { 0 or 1}",
          Groups: ["Byte Array Arithmetic"]
        },
        {
          Opcode: 169,
          Name: "b!=",
          Args: "BB",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A is not equal to B, where A and B are byte-arrays interpreted as big-endian unsigned integers => { 0 or 1}",
          Groups: ["Byte Array Arithmetic"]
        },
        {
          Opcode: 170,
          Name: "b%",
          Args: "BB",
          Returns: "B",
          Cost: 20,
          Size: 1,
          Doc: "A modulo B, where A and B are byte-arrays interpreted as big-endian unsigned integers. Fail if B is zero.",
          Groups: ["Byte Array Arithmetic"]
        },
        {
          Opcode: 171,
          Name: "b|",
          Args: "BB",
          Returns: "B",
          Cost: 6,
          Size: 1,
          Doc: "A bitwise-or B, where A and B are byte-arrays, zero-left extended to the greater of their lengths",
          Groups: ["Byte Array Logic"]
        },
        {
          Opcode: 172,
          Name: "b&",
          Args: "BB",
          Returns: "B",
          Cost: 6,
          Size: 1,
          Doc: "A bitwise-and B, where A and B are byte-arrays, zero-left extended to the greater of their lengths",
          Groups: ["Byte Array Logic"]
        },
        {
          Opcode: 173,
          Name: "b^",
          Args: "BB",
          Returns: "B",
          Cost: 6,
          Size: 1,
          Doc: "A bitwise-xor B, where A and B are byte-arrays, zero-left extended to the greater of their lengths",
          Groups: ["Byte Array Logic"]
        },
        {
          Opcode: 174,
          Name: "b~",
          Args: "B",
          Returns: "B",
          Cost: 4,
          Size: 1,
          Doc: "X with all bits inverted",
          Groups: ["Byte Array Logic"]
        },
        {
          Opcode: 175,
          Name: "bzero",
          Args: "U",
          Returns: "B",
          Cost: 1,
          Size: 1,
          Doc: "push a byte-array of length X, containing all zero bytes",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 176,
          Name: "log",
          Args: "B",
          Cost: 1,
          Size: 1,
          Doc: "write bytes to log state of the current application",
          DocExtra: "`log` fails if called more than MaxLogCalls times in a program, or if the sum of logged bytes exceeds 1024 bytes.",
          Groups: ["State Access"]
        },
        {
          Opcode: 177,
          Name: "itxn_begin",
          Cost: 1,
          Size: 1,
          Doc: "Begin preparation of a new inner transaction",
          DocExtra: "`itxn_begin` initializes Sender to the application address; Fee to the minimum allowable, taking into account MinTxnFee and credit from overpaying in earlier transactions; FirstValid/LastValid to the values in the top-level transaction, and all other fields to zero values.",
          Groups: ["Inner Transactions"]
        },
        {
          Opcode: 178,
          Name: "itxn_field",
          Args: ".",
          Cost: 1,
          Size: 2,
          Doc: "Set field F of the current inner transaction to X",
          DocExtra: "`itxn_field` fails if X is of the wrong type for F, including a byte array of the wrong size for use as an address when F is an address field. `itxn_field` also fails if X is an account or asset that does not appear in `txn.Accounts` or `txn.ForeignAssets` of the top-level transaction. (Setting addresses in asset creation are exempted from this requirement.)",
          ImmediateNote: "{uint8 transaction field index}",
          Groups: ["Inner Transactions"]
        },
        {
          Opcode: 179,
          Name: "itxn_submit",
          Cost: 1,
          Size: 1,
          Doc: "Execute the current inner transaction. Fail if 16 inner transactions have already been executed, or if the transaction itself fails.",
          Groups: ["Inner Transactions"]
        },
        {
          Opcode: 180,
          Name: "itxn",
          Returns: ".",
          Cost: 1,
          Size: 2,
          Doc: "push field F of the last inner transaction to stack",
          ImmediateNote: "{uint8 transaction field index}",
          Groups: ["Inner Transactions"]
        },
        {
          Opcode: 181,
          Name: "itxna",
          Returns: ".",
          Cost: 1,
          Size: 3,
          Doc: "push Ith value of the array field F of the last inner transaction to stack",
          ImmediateNote: "{uint8 transaction field index} {uint8 transaction field array index}",
          Groups: ["Inner Transactions"]
        },
        {
          Opcode: 192,
          Name: "txnas",
          Args: "U",
          Returns: ".",
          Cost: 1,
          Size: 2,
          ArgEnum: [
            "ApplicationArgs",
            "Accounts",
            "Assets",
            "Applications",
            "Logs"
          ],
          ArgEnumTypes: "BBUUB",
          Doc: "push Xth value of the array field F of the current transaction",
          ImmediateNote: "{uint8 transaction field index}",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 193,
          Name: "gtxnas",
          Args: "U",
          Returns: ".",
          Cost: 1,
          Size: 3,
          ArgEnum: [
            "ApplicationArgs",
            "Accounts",
            "Assets",
            "Applications",
            "Logs"
          ],
          ArgEnumTypes: "BBUUB",
          Doc: "push Xth value of the array field F from the Tth transaction in the current group",
          ImmediateNote: "{uint8 transaction group index} {uint8 transaction field index}",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 194,
          Name: "gtxnsas",
          Args: "UU",
          Returns: ".",
          Cost: 1,
          Size: 2,
          ArgEnum: [
            "ApplicationArgs",
            "Accounts",
            "Assets",
            "Applications",
            "Logs"
          ],
          ArgEnumTypes: "BBUUB",
          Doc: "pop an index A and an index B. push Bth value of the array field F from the Ath transaction in the current group",
          ImmediateNote: "{uint8 transaction field index}",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 195,
          Name: "args",
          Args: "U",
          Returns: "B",
          Cost: 1,
          Size: 1,
          Doc: "push Xth LogicSig argument to stack",
          Groups: ["Loading Values"]
        }
      ];
      langspec_default = {
        EvalMaxVersion,
        LogicSigVersion,
        Ops
      };
    }
  });

  // node_modules/algosdk/dist/esm/src/logic/logic.js
  var logic_exports = {};
  __export(logic_exports, {
    checkByteConstBlock: () => checkByteConstBlock,
    checkIntConstBlock: () => checkIntConstBlock,
    checkProgram: () => checkProgram,
    checkPushByteOp: () => checkPushByteOp,
    checkPushIntOp: () => checkPushIntOp,
    langspecEvalMaxVersion: () => langspecEvalMaxVersion,
    langspecLogicSigVersion: () => langspecLogicSigVersion,
    parseUvarint: () => parseUvarint,
    readProgram: () => readProgram
  });
  function parseUvarint(array) {
    let x = 0;
    let s = 0;
    for (let i = 0; i < array.length; i++) {
      const b = array[i];
      if (b < 128) {
        if (i > 9 || i === 9 && b > 1) {
          return [0, -(i + 1)];
        }
        return [x | b << s, i + 1];
      }
      x += (b & 127) << s;
      s += 7;
    }
    return [0, 0];
  }
  function readIntConstBlock(program, pc) {
    let size = 1;
    const parsed = parseUvarint(program.slice(pc + size));
    const numInts = parsed[0];
    let bytesUsed = parsed[1];
    if (bytesUsed <= 0) {
      throw new Error(`could not decode int const block size at pc=${pc + size}`);
    }
    const ints = [];
    size += bytesUsed;
    for (let i = 0; i < numInts; i++) {
      if (pc + size >= program.length) {
        throw new Error("intcblock ran past end of program");
      }
      let numberFound;
      [numberFound, bytesUsed] = parseUvarint(program.slice(pc + size));
      if (bytesUsed <= 0) {
        throw new Error(`could not decode int const[${i}] block size at pc=${pc + size}`);
      }
      ints.push(numberFound);
      size += bytesUsed;
    }
    return [size, ints];
  }
  function readByteConstBlock(program, pc) {
    let size = 1;
    const parsed = parseUvarint(program.slice(pc + size));
    const numInts = parsed[0];
    let bytesUsed = parsed[1];
    if (bytesUsed <= 0) {
      throw new Error(`could not decode []byte const block size at pc=${pc + size}`);
    }
    const byteArrays = [];
    size += bytesUsed;
    for (let i = 0; i < numInts; i++) {
      if (pc + size >= program.length) {
        throw new Error("bytecblock ran past end of program");
      }
      let itemLen;
      [itemLen, bytesUsed] = parseUvarint(program.slice(pc + size));
      if (bytesUsed <= 0) {
        throw new Error(`could not decode []byte] const[${i}] block size at pc=${pc + size}`);
      }
      size += bytesUsed;
      if (pc + size + itemLen > program.length) {
        throw new Error("bytecblock ran past end of program");
      }
      const byteArray = program.slice(pc + size, pc + size + itemLen);
      byteArrays.push(byteArray);
      size += itemLen;
    }
    return [size, byteArrays];
  }
  function readPushIntOp(program, pc) {
    let size = 1;
    const [numberFound, bytesUsed] = parseUvarint(program.slice(pc + size));
    if (bytesUsed <= 0) {
      throw new Error(`could not decode push int const at pc=${pc + size}`);
    }
    size += bytesUsed;
    return [size, numberFound];
  }
  function readPushByteOp(program, pc) {
    let size = 1;
    const [itemLen, bytesUsed] = parseUvarint(program.slice(pc + size));
    if (bytesUsed <= 0) {
      throw new Error(`could not decode push []byte const size at pc=${pc + size}`);
    }
    size += bytesUsed;
    if (pc + size + itemLen > program.length) {
      throw new Error("pushbytes ran past end of program");
    }
    const byteArray = program.slice(pc + size, pc + size + itemLen);
    size += itemLen;
    return [size, byteArray];
  }
  function readProgram(program, args) {
    const intcblockOpcode = 32;
    const bytecblockOpcode = 38;
    const pushbytesOpcode = 128;
    const pushintOpcode = 129;
    if (!program) {
      throw new Error("empty program");
    }
    if (typeof args === "undefined") {
      args = [];
    }
    if (!Array.isArray(args)) {
      throw new Error("invalid arguments");
    }
    const [version, vlen] = parseUvarint(program);
    if (vlen <= 0) {
      throw new Error("version parsing error");
    }
    if (version > langspec_default.EvalMaxVersion) {
      throw new Error("unsupported version");
    }
    let cost = 0;
    let { length } = program;
    for (const arg of args) {
      length += arg.length;
    }
    if (length > maxLength) {
      throw new Error("program too long");
    }
    if (!opcodes) {
      opcodes = {};
      for (const op of langspec_default.Ops) {
        opcodes[op.Opcode] = op;
      }
    }
    let pc = vlen;
    let ints = [];
    let byteArrays = [];
    while (pc < program.length) {
      const op = opcodes[program[pc]];
      if (op === void 0) {
        throw new Error("invalid instruction");
      }
      cost += op.Cost;
      let size = op.Size;
      if (size === 0) {
        switch (op.Opcode) {
          case intcblockOpcode: {
            let foundInts;
            [size, foundInts] = readIntConstBlock(program, pc);
            ints = ints.concat(foundInts);
            break;
          }
          case bytecblockOpcode: {
            let foundByteArrays;
            [size, foundByteArrays] = readByteConstBlock(program, pc);
            byteArrays = byteArrays.concat(foundByteArrays);
            break;
          }
          case pushintOpcode: {
            let foundInt;
            [size, foundInt] = readPushIntOp(program, pc);
            ints.push(foundInt);
            break;
          }
          case pushbytesOpcode: {
            let foundByteArray;
            [size, foundByteArray] = readPushByteOp(program, pc);
            byteArrays.push(foundByteArray);
            break;
          }
          default: {
            throw new Error("invalid instruction");
          }
        }
      }
      pc += size;
    }
    if (version < 4 && cost > maxCost) {
      throw new Error("program too costly for Teal version < 4. consider using v4.");
    }
    return [ints, byteArrays, true];
  }
  function checkProgram(program, args) {
    const [, , success] = readProgram(program, args);
    return success;
  }
  function checkIntConstBlock(program, pc) {
    const [size] = readIntConstBlock(program, pc);
    return size;
  }
  function checkByteConstBlock(program, pc) {
    const [size] = readByteConstBlock(program, pc);
    return size;
  }
  function checkPushIntOp(program, pc) {
    const [size] = readPushIntOp(program, pc);
    return size;
  }
  function checkPushByteOp(program, pc) {
    const [size] = readPushByteOp(program, pc);
    return size;
  }
  var opcodes, maxCost, maxLength, langspecEvalMaxVersion, langspecLogicSigVersion;
  var init_logic = __esm({
    "node_modules/algosdk/dist/esm/src/logic/logic.js"() {
      init_langspec();
      maxCost = 2e4;
      maxLength = 1e3;
      langspecEvalMaxVersion = langspec_default.EvalMaxVersion;
      langspecLogicSigVersion = langspec_default.LogicSigVersion;
    }
  });

  // node_modules/algosdk/dist/esm/src/multisig.js
  function createMultisigTransaction(txnForEncoding, { rawSig, myPk }, { version, threshold, pks }) {
    let keyExist = false;
    const subsigs = pks.map((pk) => {
      if (bytesEqual(pk, myPk)) {
        keyExist = true;
        return {
          pk: Buffer.from(pk),
          s: rawSig
        };
      }
      return { pk: Buffer.from(pk) };
    });
    if (keyExist === false) {
      throw new Error(MULTISIG_KEY_NOT_EXIST_ERROR_MSG);
    }
    const msig = {
      v: version,
      thr: threshold,
      subsig: subsigs
    };
    const signedTxn = {
      msig,
      txn: txnForEncoding
    };
    const msigAddr = fromMultisigPreImg({
      version,
      threshold,
      pks
    });
    if (encodeAddress(txnForEncoding.snd) !== encodeAddress(msigAddr)) {
      signedTxn.sgnr = Buffer.from(msigAddr);
    }
    return new Uint8Array(encode2(signedTxn));
  }
  function mergeMultisigTransactions(multisigTxnBlobs) {
    if (multisigTxnBlobs.length < 2) {
      throw new Error(MULTISIG_MERGE_LESSTHANTWO_ERROR_MSG);
    }
    const refSigTx = decode2(multisigTxnBlobs[0]);
    const refTxID = MultisigTransaction.from_obj_for_encoding(refSigTx.txn).txID();
    const refAuthAddr = refSigTx.sgnr ? encodeAddress(refSigTx.sgnr) : void 0;
    const refPreImage = {
      version: refSigTx.msig.v,
      threshold: refSigTx.msig.thr,
      pks: refSigTx.msig.subsig.map((subsig) => subsig.pk)
    };
    const refMsigAddr = encodeAddress(fromMultisigPreImg(refPreImage));
    let newSubsigs = refSigTx.msig.subsig;
    for (let i = 0; i < multisigTxnBlobs.length; i++) {
      const unisig = decode2(multisigTxnBlobs[i]);
      const unisigAlgoTxn = MultisigTransaction.from_obj_for_encoding(unisig.txn);
      if (unisigAlgoTxn.txID() !== refTxID) {
        throw new Error(MULTISIG_MERGE_MISMATCH_ERROR_MSG);
      }
      const authAddr = unisig.sgnr ? encodeAddress(unisig.sgnr) : void 0;
      if (refAuthAddr !== authAddr) {
        throw new Error(MULTISIG_MERGE_MISMATCH_AUTH_ADDR_MSG);
      }
      if (unisig.msig.subsig.length !== refSigTx.msig.subsig.length) {
        throw new Error(MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG);
      }
      const preimg = {
        version: unisig.msig.v,
        threshold: unisig.msig.thr,
        pks: unisig.msig.subsig.map((subsig) => subsig.pk)
      };
      const msgigAddr = encodeAddress(fromMultisigPreImg(preimg));
      if (refMsigAddr !== msgigAddr) {
        throw new Error(MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG);
      }
      newSubsigs = unisig.msig.subsig.map((uniSubsig, index) => {
        const current = refSigTx.msig.subsig[index];
        if (current.s) {
          if (uniSubsig.s && Buffer.compare(Buffer.from(uniSubsig.s), Buffer.from(current.s)) !== 0) {
            throw new Error(MULTISIG_MERGE_SIG_MISMATCH_ERROR_MSG);
          }
          return {
            pk: current.pk,
            s: current.s
          };
        }
        if (uniSubsig.s) {
          return {
            pk: current.pk,
            s: uniSubsig.s
          };
        }
        return current;
      });
    }
    const msig = {
      v: refSigTx.msig.v,
      thr: refSigTx.msig.thr,
      subsig: newSubsigs
    };
    const signedTxn = {
      msig,
      txn: refSigTx.txn
    };
    if (typeof refAuthAddr !== "undefined") {
      signedTxn.sgnr = Buffer.from(decodeAddress(refAuthAddr).publicKey);
    }
    return new Uint8Array(encode2(signedTxn));
  }
  function verifyMultisig(toBeVerified, msig, publicKey) {
    const version = msig.v;
    const threshold = msig.thr;
    const subsigs = msig.subsig;
    const pks = subsigs.map((subsig) => subsig.pk);
    if (msig.subsig.length < threshold) {
      return false;
    }
    let pk;
    try {
      pk = fromMultisigPreImg({ version, threshold, pks });
    } catch (e) {
      return false;
    }
    if (!arrayEqual(pk, publicKey)) {
      return false;
    }
    let counter = 0;
    for (const subsig of subsigs) {
      if (subsig.s !== void 0) {
        counter += 1;
      }
    }
    if (counter < threshold) {
      return false;
    }
    let verifiedCounter = 0;
    for (const subsig of subsigs) {
      if (subsig.s !== void 0) {
        if (verify(toBeVerified, subsig.s, subsig.pk)) {
          verifiedCounter += 1;
        }
      }
    }
    if (verifiedCounter < threshold) {
      return false;
    }
    return true;
  }
  function signMultisigTransaction(txn, { version, threshold, addrs }, sk) {
    const expectedFromRaw = fromMultisigPreImgAddrs({
      version,
      threshold,
      addrs
    });
    if (!Object.prototype.hasOwnProperty.call(txn, "from")) {
      txn.from = expectedFromRaw;
    }
    const pks = addrs.map((addr) => decodeAddress(addr).publicKey);
    const txnAlreadyBuilt = txn instanceof Transaction;
    let algoTxn;
    let blob;
    if (txnAlreadyBuilt) {
      algoTxn = txn;
      blob = MultisigTransaction.prototype.partialSignTxn.call(algoTxn, { version, threshold, pks }, sk);
    } else {
      algoTxn = new MultisigTransaction(txn);
      blob = algoTxn.partialSignTxn({ version, threshold, pks }, sk);
    }
    return {
      txID: algoTxn.txID().toString(),
      blob
    };
  }
  function appendSignMultisigTransaction(multisigTxnBlob, { version, threshold, addrs }, sk) {
    const pks = addrs.map((addr) => decodeAddress(addr).publicKey);
    const multisigTxObj = decode2(multisigTxnBlob);
    const msigTxn = MultisigTransaction.from_obj_for_encoding(multisigTxObj.txn);
    const partialSignedBlob = msigTxn.partialSignTxn({ version, threshold, pks }, sk);
    return {
      txID: msigTxn.txID().toString(),
      blob: mergeMultisigTransactions([multisigTxnBlob, partialSignedBlob])
    };
  }
  function multisigAddress({ version, threshold, addrs }) {
    return fromMultisigPreImgAddrs({ version, threshold, addrs });
  }
  var MULTISIG_MERGE_LESSTHANTWO_ERROR_MSG, MULTISIG_MERGE_MISMATCH_ERROR_MSG, MULTISIG_MERGE_MISMATCH_AUTH_ADDR_MSG, MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG, MULTISIG_MERGE_SIG_MISMATCH_ERROR_MSG, MULTISIG_KEY_NOT_EXIST_ERROR_MSG, MULTISIG_NO_MUTATE_ERROR_MSG, MULTISIG_USE_PARTIAL_SIGN_ERROR_MSG, MultisigTransaction;
  var init_multisig = __esm({
    "node_modules/algosdk/dist/esm/src/multisig.js"() {
      init_naclWrappers();
      init_address();
      init_encoding();
      init_transaction();
      init_utils();
      MULTISIG_MERGE_LESSTHANTWO_ERROR_MSG = "Not enough multisig transactions to merge. Need at least two";
      MULTISIG_MERGE_MISMATCH_ERROR_MSG = "Cannot merge txs. txIDs differ";
      MULTISIG_MERGE_MISMATCH_AUTH_ADDR_MSG = "Cannot merge txs. Auth addrs differ";
      MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG = "Cannot merge txs. Multisig preimages differ";
      MULTISIG_MERGE_SIG_MISMATCH_ERROR_MSG = "Cannot merge txs. subsigs are mismatched.";
      MULTISIG_KEY_NOT_EXIST_ERROR_MSG = "Key does not exist";
      MULTISIG_NO_MUTATE_ERROR_MSG = "Cannot mutate a multisig field as it would invalidate all existing signatures.";
      MULTISIG_USE_PARTIAL_SIGN_ERROR_MSG = "Cannot sign a multisig transaction using `signTxn`. Use `partialSignTxn` instead.";
      MultisigTransaction = class extends Transaction {
        addLease() {
          throw new Error(MULTISIG_NO_MUTATE_ERROR_MSG);
        }
        addRekey() {
          throw new Error(MULTISIG_NO_MUTATE_ERROR_MSG);
        }
        signTxn(sk) {
          throw new Error(MULTISIG_USE_PARTIAL_SIGN_ERROR_MSG);
        }
        partialSignTxn({ version, threshold, pks }, sk) {
          const myPk = keyPairFromSecretKey(sk).publicKey;
          return createMultisigTransaction(this.get_obj_for_encoding(), { rawSig: this.rawSignTxn(sk), myPk }, { version, threshold, pks });
        }
        static from_obj_for_encoding(txnForEnc) {
          return super.from_obj_for_encoding(txnForEnc);
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/src/logicsig.js
  var logicsig_exports = {};
  __export(logicsig_exports, {
    LogicSig: () => LogicSig,
    LogicSigAccount: () => LogicSigAccount,
    logicSigFromByte: () => logicSigFromByte,
    makeLogicSig: () => makeLogicSig,
    signLogicSigTransaction: () => signLogicSigTransaction,
    signLogicSigTransactionObject: () => signLogicSigTransactionObject,
    tealSign: () => tealSign,
    tealSignFromProgram: () => tealSignFromProgram
  });
  function makeLogicSig(program, args) {
    return new LogicSig(program, args);
  }
  function signLogicSigTransactionWithAddress(txn, lsig, lsigAddress) {
    if (!lsig.verify(lsigAddress)) {
      throw new Error("Logic signature verification failed. Ensure the program and signature are valid.");
    }
    const signedTxn = {
      lsig: lsig.get_obj_for_encoding(),
      txn: txn.get_obj_for_encoding()
    };
    if (!bytesEqual(lsigAddress, txn.from.publicKey)) {
      signedTxn.sgnr = Buffer.from(lsigAddress);
    }
    return {
      txID: txn.txID().toString(),
      blob: encode2(signedTxn)
    };
  }
  function signLogicSigTransactionObject(txn, lsigObject) {
    let lsig;
    let lsigAddress;
    if (lsigObject instanceof LogicSigAccount) {
      lsig = lsigObject.lsig;
      lsigAddress = decodeAddress(lsigObject.address()).publicKey;
    } else {
      lsig = lsigObject;
      if (lsig.sig) {
        lsigAddress = txn.from.publicKey;
      } else if (lsig.msig) {
        const msigMetadata = {
          version: lsig.msig.v,
          threshold: lsig.msig.thr,
          pks: lsig.msig.subsig.map((subsig) => subsig.pk)
        };
        lsigAddress = fromMultisigPreImg(msigMetadata);
      } else {
        lsigAddress = decodeAddress(lsig.address()).publicKey;
      }
    }
    return signLogicSigTransactionWithAddress(txn, lsig, lsigAddress);
  }
  function signLogicSigTransaction(txn, lsigObject) {
    const algoTxn = instantiateTxnIfNeeded(txn);
    return signLogicSigTransactionObject(algoTxn, lsigObject);
  }
  function logicSigFromByte(encoded) {
    return LogicSig.fromByte(encoded);
  }
  function tealSign(sk, data, contractAddress) {
    const parts = concatArrays(decodeAddress(contractAddress).publicKey, data);
    const toBeSigned = Buffer.from(concatArrays(SIGN_PROGRAM_DATA_PREFIX, parts));
    return sign(toBeSigned, sk);
  }
  function tealSignFromProgram(sk, data, program) {
    const lsig = new LogicSig(program);
    const contractAddress = lsig.address();
    return tealSign(sk, data, contractAddress);
  }
  var LogicSig, LogicSigAccount, SIGN_PROGRAM_DATA_PREFIX;
  var init_logicsig = __esm({
    "node_modules/algosdk/dist/esm/src/logicsig.js"() {
      init_naclWrappers();
      init_address();
      init_encoding();
      init_logic();
      init_multisig();
      init_utils();
      init_transaction();
      LogicSig = class {
        constructor(program, programArgs) {
          this.tag = Buffer.from("Program");
          if (programArgs && (!Array.isArray(programArgs) || !programArgs.every((arg) => arg.constructor === Uint8Array || Buffer.isBuffer(arg)))) {
            throw new TypeError("Invalid arguments");
          }
          let args;
          if (programArgs != null)
            args = programArgs.map((arg) => new Uint8Array(arg));
          if (!checkProgram(program, args)) {
            throw new Error("Invalid program");
          }
          this.logic = program;
          this.args = args;
          this.sig = void 0;
          this.msig = void 0;
        }
        get_obj_for_encoding() {
          const obj = {
            l: this.logic
          };
          if (this.args) {
            obj.arg = this.args;
          }
          if (this.sig) {
            obj.sig = this.sig;
          } else if (this.msig) {
            obj.msig = this.msig;
          }
          return obj;
        }
        static from_obj_for_encoding(encoded) {
          const lsig = new LogicSig(encoded.l, encoded.arg);
          lsig.sig = encoded.sig;
          lsig.msig = encoded.msig;
          return lsig;
        }
        verify(publicKey) {
          if (this.sig && this.msig) {
            return false;
          }
          try {
            checkProgram(this.logic, this.args);
          } catch (e) {
            return false;
          }
          const toBeSigned = concatArrays(this.tag, this.logic);
          if (!this.sig && !this.msig) {
            const hash = genericHash(toBeSigned);
            return arrayEqual(hash, publicKey);
          }
          if (this.sig) {
            return verify(toBeSigned, this.sig, publicKey);
          }
          return verifyMultisig(toBeSigned, this.msig, publicKey);
        }
        address() {
          const toBeSigned = concatArrays(this.tag, this.logic);
          const hash = genericHash(toBeSigned);
          return encodeAddress(new Uint8Array(hash));
        }
        sign(secretKey, msig) {
          if (msig == null) {
            this.sig = this.signProgram(secretKey);
          } else {
            const subsigs = msig.addrs.map((addr) => ({
              pk: decodeAddress(addr).publicKey
            }));
            this.msig = {
              v: msig.version,
              thr: msig.threshold,
              subsig: subsigs
            };
            const [sig, index] = this.singleSignMultisig(secretKey, this.msig);
            this.msig.subsig[index].s = sig;
          }
        }
        appendToMultisig(secretKey) {
          if (this.msig === void 0) {
            throw new Error("no multisig present");
          }
          const [sig, index] = this.singleSignMultisig(secretKey, this.msig);
          this.msig.subsig[index].s = sig;
        }
        signProgram(secretKey) {
          const toBeSigned = concatArrays(this.tag, this.logic);
          const sig = sign(toBeSigned, secretKey);
          return sig;
        }
        singleSignMultisig(secretKey, msig) {
          let index = -1;
          const myPk = keyPairFromSecretKey(secretKey).publicKey;
          for (let i = 0; i < msig.subsig.length; i++) {
            const { pk } = msig.subsig[i];
            if (arrayEqual(pk, myPk)) {
              index = i;
              break;
            }
          }
          if (index === -1) {
            throw new Error("invalid secret key");
          }
          const sig = this.signProgram(secretKey);
          return [sig, index];
        }
        toByte() {
          return encode2(this.get_obj_for_encoding());
        }
        static fromByte(encoded) {
          const decodedObj = decode2(encoded);
          return LogicSig.from_obj_for_encoding(decodedObj);
        }
      };
      LogicSigAccount = class {
        constructor(program, args) {
          this.lsig = new LogicSig(program, args);
          this.sigkey = void 0;
        }
        get_obj_for_encoding() {
          const obj = {
            lsig: this.lsig.get_obj_for_encoding()
          };
          if (this.sigkey) {
            obj.sigkey = this.sigkey;
          }
          return obj;
        }
        static from_obj_for_encoding(encoded) {
          const lsigAccount = new LogicSigAccount(encoded.lsig.l, encoded.lsig.arg);
          lsigAccount.lsig = LogicSig.from_obj_for_encoding(encoded.lsig);
          lsigAccount.sigkey = encoded.sigkey;
          return lsigAccount;
        }
        toByte() {
          return encode2(this.get_obj_for_encoding());
        }
        static fromByte(encoded) {
          const decodedObj = decode2(encoded);
          return LogicSigAccount.from_obj_for_encoding(decodedObj);
        }
        isDelegated() {
          return !!(this.lsig.sig || this.lsig.msig);
        }
        verify() {
          const addr = this.address();
          return this.lsig.verify(decodeAddress(addr).publicKey);
        }
        address() {
          if (this.lsig.sig && this.lsig.msig) {
            throw new Error("LogicSig has too many signatures. At most one of sig or msig may be present");
          }
          if (this.lsig.sig) {
            if (!this.sigkey) {
              throw new Error("Signing key for delegated account is missing");
            }
            return encodeAddress(this.sigkey);
          }
          if (this.lsig.msig) {
            const msigMetadata = {
              version: this.lsig.msig.v,
              threshold: this.lsig.msig.thr,
              pks: this.lsig.msig.subsig.map((subsig) => subsig.pk)
            };
            return encodeAddress(fromMultisigPreImg(msigMetadata));
          }
          return this.lsig.address();
        }
        signMultisig(msig, secretKey) {
          this.lsig.sign(secretKey, msig);
        }
        appendToMultisig(secretKey) {
          this.lsig.appendToMultisig(secretKey);
        }
        sign(secretKey) {
          this.lsig.sign(secretKey);
          this.sigkey = keyPairFromSecretKey(secretKey).publicKey;
        }
      };
      SIGN_PROGRAM_DATA_PREFIX = Buffer.from("ProgData");
    }
  });

  // node_modules/algosdk/dist/esm/src/logicTemplates/templates.js
  var require_templates = __commonJS({
    "node_modules/algosdk/dist/esm/src/logicTemplates/templates.js"(exports2, module2) {
      var address = (init_address(), __toCommonJS(address_exports));
      function putUvarint(buf, x) {
        let i = 0;
        while (x > 128) {
          buf.push(x & 255 | 128);
          x >>= 7;
          i += 1;
        }
        buf.push(x & 255);
        return i + 1;
      }
      var valTypes = {
        INT: 1,
        ADDRESS: 2,
        BASE64: 3
      };
      function inject(orig, offsets, values, valueTypes) {
        if (offsets.length !== values.length || offsets.length !== valueTypes.length) {
          throw new Error("Lengths do not match");
        }
        let res = orig;
        function replace(arr, newVal, offset, placeholderLength) {
          const beforeReplacement = arr.slice(0, offset);
          const afterReplacement = arr.slice(offset + placeholderLength, arr.length);
          const chunks = [beforeReplacement, Buffer.from(newVal), afterReplacement];
          return Buffer.concat(chunks);
        }
        for (let i = 0; i < offsets.length; i++) {
          let decodedLength = 0;
          let val = values[i];
          const valType = valueTypes[i];
          switch (valType) {
            case valTypes.INT:
              const intBuf = [];
              decodedLength = putUvarint(intBuf, val);
              res = replace(res, intBuf, offsets[i], 1);
              break;
            case valTypes.ADDRESS:
              val = address.decodeAddress(val);
              res = replace(res, val.publicKey, offsets[i], 32);
              break;
            case valTypes.BASE64:
              const lenBuf = [];
              val = Buffer.from(val, "base64");
              putUvarint(lenBuf, val.length);
              val = Buffer.concat([Buffer.from(lenBuf), val]);
              res = replace(res, val, offsets[i], 33);
              break;
            default:
              throw new Error("unrecognized value type");
          }
          if (decodedLength !== 0) {
            for (let o = 0; o < offsets.length; o++) {
              offsets[o] += decodedLength - 1;
            }
          }
        }
        return res;
      }
      module2.exports = { inject, valTypes };
    }
  });

  // node_modules/algosdk/dist/esm/src/logicTemplates/dynamicfee.js
  var require_dynamicfee = __commonJS({
    "node_modules/algosdk/dist/esm/src/logicTemplates/dynamicfee.js"(exports2, module2) {
      var address = (init_address(), __toCommonJS(address_exports));
      var encoding = (init_encoding(), __toCommonJS(encoding_exports));
      var group = (init_group(), __toCommonJS(group_exports));
      var logic = (init_logic(), __toCommonJS(logic_exports));
      var logicSig = (init_logicsig(), __toCommonJS(logicsig_exports));
      var nacl2 = (init_naclWrappers(), __toCommonJS(naclWrappers_exports));
      var templates = require_templates();
      var transaction = (init_transaction(), __toCommonJS(transaction_exports));
      var DynamicFee = class {
        constructor(receiver, amount, firstValid, lastValid, closeRemainder, lease) {
          if (!Number.isSafeInteger(amount) || amount < 0)
            throw Error("amount must be a positive number and smaller than 2^53-1");
          if (!Number.isSafeInteger(firstValid) || firstValid < 0)
            throw Error("firstValid must be a positive number and smaller than 2^53-1");
          if (!Number.isSafeInteger(lastValid) || lastValid < 0)
            throw Error("lastValid must be a positive number and smaller than 2^53-1");
          if (typeof closeRemainder === "undefined") {
            closeRemainder = address.ALGORAND_ZERO_ADDRESS_STRING;
          }
          if (typeof lease === "undefined") {
            const leaseBytes = nacl2.randomBytes(32);
            lease = Buffer.from(leaseBytes).toString("base64");
          }
          const referenceProgramB64 = "ASAFAgEHBgUmAyD+vKC7FEpaTqe0OKRoGsgObKEFvLYH/FZTJclWlfaiEyDmmpYeby1feshmB5JlUr6YI17TM2PKiJGLuck4qRW2+SB/g7Flf/H8U7ktwYFIodZd/C1LH6PWdyhK3dIAEm2QaTIEIhIzABAjEhAzAAcxABIQMwAIMQESEDEWIxIQMRAjEhAxBygSEDEJKRIQMQgkEhAxAiUSEDEEIQQSEDEGKhIQ";
          const referenceProgramBytes = Buffer.from(referenceProgramB64, "base64");
          const referenceOffsets = [
            5,
            6,
            7,
            11,
            44,
            76
          ];
          const injectionVector = [
            amount,
            firstValid,
            lastValid,
            receiver,
            closeRemainder,
            lease
          ];
          const injectionTypes = [
            templates.valTypes.INT,
            templates.valTypes.INT,
            templates.valTypes.INT,
            templates.valTypes.ADDRESS,
            templates.valTypes.ADDRESS,
            templates.valTypes.BASE64
          ];
          const injectedBytes = templates.inject(referenceProgramBytes, referenceOffsets, injectionVector, injectionTypes);
          this.programBytes = injectedBytes;
          const lsig = new logicSig.LogicSig(injectedBytes, void 0);
          this.address = lsig.address();
        }
        getProgram() {
          return this.programBytes;
        }
        getAddress() {
          return this.address;
        }
      };
      function signDynamicFee(contract, secretKey, genesisHash) {
        const programOutputs = logic.readProgram(contract, void 0);
        const ints = programOutputs[0];
        const byteArrays = programOutputs[1];
        const keys = nacl2.keyPairFromSecretKey(secretKey);
        const from = address.encodeAddress(keys.publicKey);
        const to = address.encodeAddress(byteArrays[0]);
        const fee = 0;
        const amount = ints[2];
        const closeRemainderTo = address.encodeAddress(byteArrays[1]);
        const firstRound = ints[3];
        const lastRound = ints[4];
        const lease = new Uint8Array(byteArrays[2]);
        const txn = {
          from,
          to,
          fee,
          amount,
          closeRemainderTo,
          firstRound,
          lastRound,
          genesisHash,
          type: "pay",
          lease
        };
        const lsig = new logicSig.LogicSig(contract, void 0);
        lsig.sign(secretKey);
        return { txn, lsig };
      }
      function getDynamicFeeTransactions(txn, lsig, privateKey, fee) {
        if (!lsig.verify(address.decodeAddress(txn.from).publicKey)) {
          throw new Error("invalid signature");
        }
        txn.fee = fee;
        if (txn.fee < transaction.ALGORAND_MIN_TX_FEE) {
          txn.fee = transaction.ALGORAND_MIN_TX_FEE;
        }
        const keys = nacl2.keyPairFromSecretKey(privateKey);
        const from = address.encodeAddress(keys.publicKey);
        const { lease } = txn;
        delete txn.lease;
        const txnObj = new transaction.Transaction(txn);
        txnObj.addLease(lease, fee);
        const feePayTxn = {
          from,
          to: txn.from,
          fee,
          amount: txnObj.fee,
          firstRound: txn.firstRound,
          lastRound: txn.lastRound,
          genesisHash: txn.genesisHash,
          type: "pay"
        };
        const feePayTxnObj = new transaction.Transaction(feePayTxn);
        feePayTxnObj.addLease(lease, fee);
        const txnGroup = group.assignGroupID([feePayTxnObj, txnObj], void 0);
        const feePayTxnWithGroup = txnGroup[0];
        const txnObjWithGroup = txnGroup[1];
        const lstx = {
          lsig: lsig.get_obj_for_encoding(),
          txn: txnObjWithGroup.get_obj_for_encoding()
        };
        const stx1 = feePayTxnWithGroup.signTxn(privateKey);
        const stx2 = encoding.encode(lstx);
        const concatStx = new Uint8Array(stx1.length + stx2.length);
        concatStx.set(stx1);
        concatStx.set(stx2, stx1.length);
        return concatStx;
      }
      module2.exports = {
        DynamicFee,
        getDynamicFeeTransactions,
        signDynamicFee
      };
    }
  });

  // node_modules/js-sha256/src/sha256.js
  var require_sha256 = __commonJS({
    "node_modules/js-sha256/src/sha256.js"(exports, module) {
      (function() {
        "use strict";
        var ERROR = "input is invalid type";
        var WINDOW = typeof window === "object";
        var root = WINDOW ? window : {};
        if (root.JS_SHA256_NO_WINDOW) {
          WINDOW = false;
        }
        var WEB_WORKER = !WINDOW && typeof self === "object";
        var NODE_JS = !root.JS_SHA256_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
        if (NODE_JS) {
          root = global;
        } else if (WEB_WORKER) {
          root = self;
        }
        var COMMON_JS = !root.JS_SHA256_NO_COMMON_JS && typeof module === "object" && module.exports;
        var AMD = typeof define === "function" && define.amd;
        var ARRAY_BUFFER = !root.JS_SHA256_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
        var HEX_CHARS = "0123456789abcdef".split("");
        var EXTRA = [-2147483648, 8388608, 32768, 128];
        var SHIFT = [24, 16, 8, 0];
        var K = [
          1116352408,
          1899447441,
          3049323471,
          3921009573,
          961987163,
          1508970993,
          2453635748,
          2870763221,
          3624381080,
          310598401,
          607225278,
          1426881987,
          1925078388,
          2162078206,
          2614888103,
          3248222580,
          3835390401,
          4022224774,
          264347078,
          604807628,
          770255983,
          1249150122,
          1555081692,
          1996064986,
          2554220882,
          2821834349,
          2952996808,
          3210313671,
          3336571891,
          3584528711,
          113926993,
          338241895,
          666307205,
          773529912,
          1294757372,
          1396182291,
          1695183700,
          1986661051,
          2177026350,
          2456956037,
          2730485921,
          2820302411,
          3259730800,
          3345764771,
          3516065817,
          3600352804,
          4094571909,
          275423344,
          430227734,
          506948616,
          659060556,
          883997877,
          958139571,
          1322822218,
          1537002063,
          1747873779,
          1955562222,
          2024104815,
          2227730452,
          2361852424,
          2428436474,
          2756734187,
          3204031479,
          3329325298
        ];
        var OUTPUT_TYPES = ["hex", "array", "digest", "arrayBuffer"];
        var blocks = [];
        if (root.JS_SHA256_NO_NODE_JS || !Array.isArray) {
          Array.isArray = function(obj) {
            return Object.prototype.toString.call(obj) === "[object Array]";
          };
        }
        if (ARRAY_BUFFER && (root.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
          ArrayBuffer.isView = function(obj) {
            return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
          };
        }
        var createOutputMethod = function(outputType, is2242) {
          return function(message) {
            return new Sha256(is2242, true).update(message)[outputType]();
          };
        };
        var createMethod = function(is2242) {
          var method2 = createOutputMethod("hex", is2242);
          if (NODE_JS) {
            method2 = nodeWrap(method2, is2242);
          }
          method2.create = function() {
            return new Sha256(is2242);
          };
          method2.update = function(message) {
            return method2.create().update(message);
          };
          for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
            var type = OUTPUT_TYPES[i];
            method2[type] = createOutputMethod(type, is2242);
          }
          return method2;
        };
        var nodeWrap = function(method, is224) {
          var crypto = eval("require('crypto')");
          var Buffer = eval("require('buffer').Buffer");
          var algorithm = is224 ? "sha224" : "sha256";
          var nodeMethod = function(message) {
            if (typeof message === "string") {
              return crypto.createHash(algorithm).update(message, "utf8").digest("hex");
            } else {
              if (message === null || message === void 0) {
                throw new Error(ERROR);
              } else if (message.constructor === ArrayBuffer) {
                message = new Uint8Array(message);
              }
            }
            if (Array.isArray(message) || ArrayBuffer.isView(message) || message.constructor === Buffer) {
              return crypto.createHash(algorithm).update(new Buffer(message)).digest("hex");
            } else {
              return method(message);
            }
          };
          return nodeMethod;
        };
        var createHmacOutputMethod = function(outputType, is2242) {
          return function(key, message) {
            return new HmacSha256(key, is2242, true).update(message)[outputType]();
          };
        };
        var createHmacMethod = function(is2242) {
          var method2 = createHmacOutputMethod("hex", is2242);
          method2.create = function(key) {
            return new HmacSha256(key, is2242);
          };
          method2.update = function(key, message) {
            return method2.create(key).update(message);
          };
          for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
            var type = OUTPUT_TYPES[i];
            method2[type] = createHmacOutputMethod(type, is2242);
          }
          return method2;
        };
        function Sha256(is2242, sharedMemory) {
          if (sharedMemory) {
            blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
            this.blocks = blocks;
          } else {
            this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
          }
          if (is2242) {
            this.h0 = 3238371032;
            this.h1 = 914150663;
            this.h2 = 812702999;
            this.h3 = 4144912697;
            this.h4 = 4290775857;
            this.h5 = 1750603025;
            this.h6 = 1694076839;
            this.h7 = 3204075428;
          } else {
            this.h0 = 1779033703;
            this.h1 = 3144134277;
            this.h2 = 1013904242;
            this.h3 = 2773480762;
            this.h4 = 1359893119;
            this.h5 = 2600822924;
            this.h6 = 528734635;
            this.h7 = 1541459225;
          }
          this.block = this.start = this.bytes = this.hBytes = 0;
          this.finalized = this.hashed = false;
          this.first = true;
          this.is224 = is2242;
        }
        Sha256.prototype.update = function(message) {
          if (this.finalized) {
            return;
          }
          var notString, type = typeof message;
          if (type !== "string") {
            if (type === "object") {
              if (message === null) {
                throw new Error(ERROR);
              } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
                message = new Uint8Array(message);
              } else if (!Array.isArray(message)) {
                if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
                  throw new Error(ERROR);
                }
              }
            } else {
              throw new Error(ERROR);
            }
            notString = true;
          }
          var code, index = 0, i, length = message.length, blocks2 = this.blocks;
          while (index < length) {
            if (this.hashed) {
              this.hashed = false;
              blocks2[0] = this.block;
              blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
            }
            if (notString) {
              for (i = this.start; index < length && i < 64; ++index) {
                blocks2[i >> 2] |= message[index] << SHIFT[i++ & 3];
              }
            } else {
              for (i = this.start; index < length && i < 64; ++index) {
                code = message.charCodeAt(index);
                if (code < 128) {
                  blocks2[i >> 2] |= code << SHIFT[i++ & 3];
                } else if (code < 2048) {
                  blocks2[i >> 2] |= (192 | code >> 6) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
                } else if (code < 55296 || code >= 57344) {
                  blocks2[i >> 2] |= (224 | code >> 12) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
                } else {
                  code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                  blocks2[i >> 2] |= (240 | code >> 18) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code >> 12 & 63) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
                }
              }
            }
            this.lastByteIndex = i;
            this.bytes += i - this.start;
            if (i >= 64) {
              this.block = blocks2[16];
              this.start = i - 64;
              this.hash();
              this.hashed = true;
            } else {
              this.start = i;
            }
          }
          if (this.bytes > 4294967295) {
            this.hBytes += this.bytes / 4294967296 << 0;
            this.bytes = this.bytes % 4294967296;
          }
          return this;
        };
        Sha256.prototype.finalize = function() {
          if (this.finalized) {
            return;
          }
          this.finalized = true;
          var blocks2 = this.blocks, i = this.lastByteIndex;
          blocks2[16] = this.block;
          blocks2[i >> 2] |= EXTRA[i & 3];
          this.block = blocks2[16];
          if (i >= 56) {
            if (!this.hashed) {
              this.hash();
            }
            blocks2[0] = this.block;
            blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
          }
          blocks2[14] = this.hBytes << 3 | this.bytes >>> 29;
          blocks2[15] = this.bytes << 3;
          this.hash();
        };
        Sha256.prototype.hash = function() {
          var a = this.h0, b = this.h1, c = this.h2, d = this.h3, e = this.h4, f = this.h5, g = this.h6, h = this.h7, blocks2 = this.blocks, j, s0, s1, maj, t1, t2, ch, ab, da, cd, bc;
          for (j = 16; j < 64; ++j) {
            t1 = blocks2[j - 15];
            s0 = (t1 >>> 7 | t1 << 25) ^ (t1 >>> 18 | t1 << 14) ^ t1 >>> 3;
            t1 = blocks2[j - 2];
            s1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;
            blocks2[j] = blocks2[j - 16] + s0 + blocks2[j - 7] + s1 << 0;
          }
          bc = b & c;
          for (j = 0; j < 64; j += 4) {
            if (this.first) {
              if (this.is224) {
                ab = 300032;
                t1 = blocks2[0] - 1413257819;
                h = t1 - 150054599 << 0;
                d = t1 + 24177077 << 0;
              } else {
                ab = 704751109;
                t1 = blocks2[0] - 210244248;
                h = t1 - 1521486534 << 0;
                d = t1 + 143694565 << 0;
              }
              this.first = false;
            } else {
              s0 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10);
              s1 = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);
              ab = a & b;
              maj = ab ^ a & c ^ bc;
              ch = e & f ^ ~e & g;
              t1 = h + s1 + ch + K[j] + blocks2[j];
              t2 = s0 + maj;
              h = d + t1 << 0;
              d = t1 + t2 << 0;
            }
            s0 = (d >>> 2 | d << 30) ^ (d >>> 13 | d << 19) ^ (d >>> 22 | d << 10);
            s1 = (h >>> 6 | h << 26) ^ (h >>> 11 | h << 21) ^ (h >>> 25 | h << 7);
            da = d & a;
            maj = da ^ d & b ^ ab;
            ch = h & e ^ ~h & f;
            t1 = g + s1 + ch + K[j + 1] + blocks2[j + 1];
            t2 = s0 + maj;
            g = c + t1 << 0;
            c = t1 + t2 << 0;
            s0 = (c >>> 2 | c << 30) ^ (c >>> 13 | c << 19) ^ (c >>> 22 | c << 10);
            s1 = (g >>> 6 | g << 26) ^ (g >>> 11 | g << 21) ^ (g >>> 25 | g << 7);
            cd = c & d;
            maj = cd ^ c & a ^ da;
            ch = g & h ^ ~g & e;
            t1 = f + s1 + ch + K[j + 2] + blocks2[j + 2];
            t2 = s0 + maj;
            f = b + t1 << 0;
            b = t1 + t2 << 0;
            s0 = (b >>> 2 | b << 30) ^ (b >>> 13 | b << 19) ^ (b >>> 22 | b << 10);
            s1 = (f >>> 6 | f << 26) ^ (f >>> 11 | f << 21) ^ (f >>> 25 | f << 7);
            bc = b & c;
            maj = bc ^ b & d ^ cd;
            ch = f & g ^ ~f & h;
            t1 = e + s1 + ch + K[j + 3] + blocks2[j + 3];
            t2 = s0 + maj;
            e = a + t1 << 0;
            a = t1 + t2 << 0;
          }
          this.h0 = this.h0 + a << 0;
          this.h1 = this.h1 + b << 0;
          this.h2 = this.h2 + c << 0;
          this.h3 = this.h3 + d << 0;
          this.h4 = this.h4 + e << 0;
          this.h5 = this.h5 + f << 0;
          this.h6 = this.h6 + g << 0;
          this.h7 = this.h7 + h << 0;
        };
        Sha256.prototype.hex = function() {
          this.finalize();
          var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
          var hex = HEX_CHARS[h0 >> 28 & 15] + HEX_CHARS[h0 >> 24 & 15] + HEX_CHARS[h0 >> 20 & 15] + HEX_CHARS[h0 >> 16 & 15] + HEX_CHARS[h0 >> 12 & 15] + HEX_CHARS[h0 >> 8 & 15] + HEX_CHARS[h0 >> 4 & 15] + HEX_CHARS[h0 & 15] + HEX_CHARS[h1 >> 28 & 15] + HEX_CHARS[h1 >> 24 & 15] + HEX_CHARS[h1 >> 20 & 15] + HEX_CHARS[h1 >> 16 & 15] + HEX_CHARS[h1 >> 12 & 15] + HEX_CHARS[h1 >> 8 & 15] + HEX_CHARS[h1 >> 4 & 15] + HEX_CHARS[h1 & 15] + HEX_CHARS[h2 >> 28 & 15] + HEX_CHARS[h2 >> 24 & 15] + HEX_CHARS[h2 >> 20 & 15] + HEX_CHARS[h2 >> 16 & 15] + HEX_CHARS[h2 >> 12 & 15] + HEX_CHARS[h2 >> 8 & 15] + HEX_CHARS[h2 >> 4 & 15] + HEX_CHARS[h2 & 15] + HEX_CHARS[h3 >> 28 & 15] + HEX_CHARS[h3 >> 24 & 15] + HEX_CHARS[h3 >> 20 & 15] + HEX_CHARS[h3 >> 16 & 15] + HEX_CHARS[h3 >> 12 & 15] + HEX_CHARS[h3 >> 8 & 15] + HEX_CHARS[h3 >> 4 & 15] + HEX_CHARS[h3 & 15] + HEX_CHARS[h4 >> 28 & 15] + HEX_CHARS[h4 >> 24 & 15] + HEX_CHARS[h4 >> 20 & 15] + HEX_CHARS[h4 >> 16 & 15] + HEX_CHARS[h4 >> 12 & 15] + HEX_CHARS[h4 >> 8 & 15] + HEX_CHARS[h4 >> 4 & 15] + HEX_CHARS[h4 & 15] + HEX_CHARS[h5 >> 28 & 15] + HEX_CHARS[h5 >> 24 & 15] + HEX_CHARS[h5 >> 20 & 15] + HEX_CHARS[h5 >> 16 & 15] + HEX_CHARS[h5 >> 12 & 15] + HEX_CHARS[h5 >> 8 & 15] + HEX_CHARS[h5 >> 4 & 15] + HEX_CHARS[h5 & 15] + HEX_CHARS[h6 >> 28 & 15] + HEX_CHARS[h6 >> 24 & 15] + HEX_CHARS[h6 >> 20 & 15] + HEX_CHARS[h6 >> 16 & 15] + HEX_CHARS[h6 >> 12 & 15] + HEX_CHARS[h6 >> 8 & 15] + HEX_CHARS[h6 >> 4 & 15] + HEX_CHARS[h6 & 15];
          if (!this.is224) {
            hex += HEX_CHARS[h7 >> 28 & 15] + HEX_CHARS[h7 >> 24 & 15] + HEX_CHARS[h7 >> 20 & 15] + HEX_CHARS[h7 >> 16 & 15] + HEX_CHARS[h7 >> 12 & 15] + HEX_CHARS[h7 >> 8 & 15] + HEX_CHARS[h7 >> 4 & 15] + HEX_CHARS[h7 & 15];
          }
          return hex;
        };
        Sha256.prototype.toString = Sha256.prototype.hex;
        Sha256.prototype.digest = function() {
          this.finalize();
          var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
          var arr = [
            h0 >> 24 & 255,
            h0 >> 16 & 255,
            h0 >> 8 & 255,
            h0 & 255,
            h1 >> 24 & 255,
            h1 >> 16 & 255,
            h1 >> 8 & 255,
            h1 & 255,
            h2 >> 24 & 255,
            h2 >> 16 & 255,
            h2 >> 8 & 255,
            h2 & 255,
            h3 >> 24 & 255,
            h3 >> 16 & 255,
            h3 >> 8 & 255,
            h3 & 255,
            h4 >> 24 & 255,
            h4 >> 16 & 255,
            h4 >> 8 & 255,
            h4 & 255,
            h5 >> 24 & 255,
            h5 >> 16 & 255,
            h5 >> 8 & 255,
            h5 & 255,
            h6 >> 24 & 255,
            h6 >> 16 & 255,
            h6 >> 8 & 255,
            h6 & 255
          ];
          if (!this.is224) {
            arr.push(h7 >> 24 & 255, h7 >> 16 & 255, h7 >> 8 & 255, h7 & 255);
          }
          return arr;
        };
        Sha256.prototype.array = Sha256.prototype.digest;
        Sha256.prototype.arrayBuffer = function() {
          this.finalize();
          var buffer = new ArrayBuffer(this.is224 ? 28 : 32);
          var dataView = new DataView(buffer);
          dataView.setUint32(0, this.h0);
          dataView.setUint32(4, this.h1);
          dataView.setUint32(8, this.h2);
          dataView.setUint32(12, this.h3);
          dataView.setUint32(16, this.h4);
          dataView.setUint32(20, this.h5);
          dataView.setUint32(24, this.h6);
          if (!this.is224) {
            dataView.setUint32(28, this.h7);
          }
          return buffer;
        };
        function HmacSha256(key, is2242, sharedMemory) {
          var i, type = typeof key;
          if (type === "string") {
            var bytes = [], length = key.length, index = 0, code;
            for (i = 0; i < length; ++i) {
              code = key.charCodeAt(i);
              if (code < 128) {
                bytes[index++] = code;
              } else if (code < 2048) {
                bytes[index++] = 192 | code >> 6;
                bytes[index++] = 128 | code & 63;
              } else if (code < 55296 || code >= 57344) {
                bytes[index++] = 224 | code >> 12;
                bytes[index++] = 128 | code >> 6 & 63;
                bytes[index++] = 128 | code & 63;
              } else {
                code = 65536 + ((code & 1023) << 10 | key.charCodeAt(++i) & 1023);
                bytes[index++] = 240 | code >> 18;
                bytes[index++] = 128 | code >> 12 & 63;
                bytes[index++] = 128 | code >> 6 & 63;
                bytes[index++] = 128 | code & 63;
              }
            }
            key = bytes;
          } else {
            if (type === "object") {
              if (key === null) {
                throw new Error(ERROR);
              } else if (ARRAY_BUFFER && key.constructor === ArrayBuffer) {
                key = new Uint8Array(key);
              } else if (!Array.isArray(key)) {
                if (!ARRAY_BUFFER || !ArrayBuffer.isView(key)) {
                  throw new Error(ERROR);
                }
              }
            } else {
              throw new Error(ERROR);
            }
          }
          if (key.length > 64) {
            key = new Sha256(is2242, true).update(key).array();
          }
          var oKeyPad = [], iKeyPad = [];
          for (i = 0; i < 64; ++i) {
            var b = key[i] || 0;
            oKeyPad[i] = 92 ^ b;
            iKeyPad[i] = 54 ^ b;
          }
          Sha256.call(this, is2242, sharedMemory);
          this.update(iKeyPad);
          this.oKeyPad = oKeyPad;
          this.inner = true;
          this.sharedMemory = sharedMemory;
        }
        HmacSha256.prototype = new Sha256();
        HmacSha256.prototype.finalize = function() {
          Sha256.prototype.finalize.call(this);
          if (this.inner) {
            this.inner = false;
            var innerHash = this.array();
            Sha256.call(this, this.is224, this.sharedMemory);
            this.update(this.oKeyPad);
            this.update(innerHash);
            Sha256.prototype.finalize.call(this);
          }
        };
        var exports = createMethod();
        exports.sha256 = exports;
        exports.sha224 = createMethod(true);
        exports.sha256.hmac = createHmacMethod();
        exports.sha224.hmac = createHmacMethod(true);
        if (COMMON_JS) {
          module.exports = exports;
        } else {
          root.sha256 = exports.sha256;
          root.sha224 = exports.sha224;
          if (AMD) {
            define(function() {
              return exports;
            });
          }
        }
      })();
    }
  });

  // node_modules/js-sha3/src/sha3.js
  var require_sha3 = __commonJS({
    "node_modules/js-sha3/src/sha3.js"(exports2, module2) {
      (function() {
        "use strict";
        var INPUT_ERROR = "input is invalid type";
        var FINALIZE_ERROR = "finalize already called";
        var WINDOW2 = typeof window === "object";
        var root2 = WINDOW2 ? window : {};
        if (root2.JS_SHA3_NO_WINDOW) {
          WINDOW2 = false;
        }
        var WEB_WORKER2 = !WINDOW2 && typeof self === "object";
        var NODE_JS2 = !root2.JS_SHA3_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
        if (NODE_JS2) {
          root2 = global;
        } else if (WEB_WORKER2) {
          root2 = self;
        }
        var COMMON_JS2 = !root2.JS_SHA3_NO_COMMON_JS && typeof module2 === "object" && module2.exports;
        var AMD2 = typeof define === "function" && define.amd;
        var ARRAY_BUFFER2 = !root2.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
        var HEX_CHARS2 = "0123456789abcdef".split("");
        var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
        var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
        var KECCAK_PADDING = [1, 256, 65536, 16777216];
        var PADDING = [6, 1536, 393216, 100663296];
        var SHIFT2 = [0, 8, 16, 24];
        var RC = [
          1,
          0,
          32898,
          0,
          32906,
          2147483648,
          2147516416,
          2147483648,
          32907,
          0,
          2147483649,
          0,
          2147516545,
          2147483648,
          32777,
          2147483648,
          138,
          0,
          136,
          0,
          2147516425,
          0,
          2147483658,
          0,
          2147516555,
          0,
          139,
          2147483648,
          32905,
          2147483648,
          32771,
          2147483648,
          32770,
          2147483648,
          128,
          2147483648,
          32778,
          0,
          2147483658,
          2147483648,
          2147516545,
          2147483648,
          32896,
          2147483648,
          2147483649,
          0,
          2147516424,
          2147483648
        ];
        var BITS = [224, 256, 384, 512];
        var SHAKE_BITS = [128, 256];
        var OUTPUT_TYPES2 = ["hex", "buffer", "arrayBuffer", "array", "digest"];
        var CSHAKE_BYTEPAD = {
          "128": 168,
          "256": 136
        };
        if (root2.JS_SHA3_NO_NODE_JS || !Array.isArray) {
          Array.isArray = function(obj) {
            return Object.prototype.toString.call(obj) === "[object Array]";
          };
        }
        if (ARRAY_BUFFER2 && (root2.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
          ArrayBuffer.isView = function(obj) {
            return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
          };
        }
        var createOutputMethod2 = function(bits2, padding, outputType) {
          return function(message) {
            return new Keccak(bits2, padding, bits2).update(message)[outputType]();
          };
        };
        var createShakeOutputMethod = function(bits2, padding, outputType) {
          return function(message, outputBits) {
            return new Keccak(bits2, padding, outputBits).update(message)[outputType]();
          };
        };
        var createCshakeOutputMethod = function(bits2, padding, outputType) {
          return function(message, outputBits, n, s) {
            return methods["cshake" + bits2].update(message, outputBits, n, s)[outputType]();
          };
        };
        var createKmacOutputMethod = function(bits2, padding, outputType) {
          return function(key, message, outputBits, s) {
            return methods["kmac" + bits2].update(key, message, outputBits, s)[outputType]();
          };
        };
        var createOutputMethods = function(method2, createMethod3, bits2, padding) {
          for (var i2 = 0; i2 < OUTPUT_TYPES2.length; ++i2) {
            var type = OUTPUT_TYPES2[i2];
            method2[type] = createMethod3(bits2, padding, type);
          }
          return method2;
        };
        var createMethod2 = function(bits2, padding) {
          var method2 = createOutputMethod2(bits2, padding, "hex");
          method2.create = function() {
            return new Keccak(bits2, padding, bits2);
          };
          method2.update = function(message) {
            return method2.create().update(message);
          };
          return createOutputMethods(method2, createOutputMethod2, bits2, padding);
        };
        var createShakeMethod = function(bits2, padding) {
          var method2 = createShakeOutputMethod(bits2, padding, "hex");
          method2.create = function(outputBits) {
            return new Keccak(bits2, padding, outputBits);
          };
          method2.update = function(message, outputBits) {
            return method2.create(outputBits).update(message);
          };
          return createOutputMethods(method2, createShakeOutputMethod, bits2, padding);
        };
        var createCshakeMethod = function(bits2, padding) {
          var w = CSHAKE_BYTEPAD[bits2];
          var method2 = createCshakeOutputMethod(bits2, padding, "hex");
          method2.create = function(outputBits, n, s) {
            if (!n && !s) {
              return methods["shake" + bits2].create(outputBits);
            } else {
              return new Keccak(bits2, padding, outputBits).bytepad([n, s], w);
            }
          };
          method2.update = function(message, outputBits, n, s) {
            return method2.create(outputBits, n, s).update(message);
          };
          return createOutputMethods(method2, createCshakeOutputMethod, bits2, padding);
        };
        var createKmacMethod = function(bits2, padding) {
          var w = CSHAKE_BYTEPAD[bits2];
          var method2 = createKmacOutputMethod(bits2, padding, "hex");
          method2.create = function(key, outputBits, s) {
            return new Kmac(bits2, padding, outputBits).bytepad(["KMAC", s], w).bytepad([key], w);
          };
          method2.update = function(key, message, outputBits, s) {
            return method2.create(key, outputBits, s).update(message);
          };
          return createOutputMethods(method2, createKmacOutputMethod, bits2, padding);
        };
        var algorithms = [
          { name: "keccak", padding: KECCAK_PADDING, bits: BITS, createMethod: createMethod2 },
          { name: "sha3", padding: PADDING, bits: BITS, createMethod: createMethod2 },
          { name: "shake", padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
          { name: "cshake", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
          { name: "kmac", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
        ];
        var methods = {}, methodNames = [];
        for (var i = 0; i < algorithms.length; ++i) {
          var algorithm2 = algorithms[i];
          var bits = algorithm2.bits;
          for (var j = 0; j < bits.length; ++j) {
            var methodName = algorithm2.name + "_" + bits[j];
            methodNames.push(methodName);
            methods[methodName] = algorithm2.createMethod(bits[j], algorithm2.padding);
            if (algorithm2.name !== "sha3") {
              var newMethodName = algorithm2.name + bits[j];
              methodNames.push(newMethodName);
              methods[newMethodName] = methods[methodName];
            }
          }
        }
        function Keccak(bits2, padding, outputBits) {
          this.blocks = [];
          this.s = [];
          this.padding = padding;
          this.outputBits = outputBits;
          this.reset = true;
          this.finalized = false;
          this.block = 0;
          this.start = 0;
          this.blockCount = 1600 - (bits2 << 1) >> 5;
          this.byteCount = this.blockCount << 2;
          this.outputBlocks = outputBits >> 5;
          this.extraBytes = (outputBits & 31) >> 3;
          for (var i2 = 0; i2 < 50; ++i2) {
            this.s[i2] = 0;
          }
        }
        Keccak.prototype.update = function(message) {
          if (this.finalized) {
            throw new Error(FINALIZE_ERROR);
          }
          var notString, type = typeof message;
          if (type !== "string") {
            if (type === "object") {
              if (message === null) {
                throw new Error(INPUT_ERROR);
              } else if (ARRAY_BUFFER2 && message.constructor === ArrayBuffer) {
                message = new Uint8Array(message);
              } else if (!Array.isArray(message)) {
                if (!ARRAY_BUFFER2 || !ArrayBuffer.isView(message)) {
                  throw new Error(INPUT_ERROR);
                }
              }
            } else {
              throw new Error(INPUT_ERROR);
            }
            notString = true;
          }
          var blocks2 = this.blocks, byteCount = this.byteCount, length = message.length, blockCount = this.blockCount, index = 0, s = this.s, i2, code;
          while (index < length) {
            if (this.reset) {
              this.reset = false;
              blocks2[0] = this.block;
              for (i2 = 1; i2 < blockCount + 1; ++i2) {
                blocks2[i2] = 0;
              }
            }
            if (notString) {
              for (i2 = this.start; index < length && i2 < byteCount; ++index) {
                blocks2[i2 >> 2] |= message[index] << SHIFT2[i2++ & 3];
              }
            } else {
              for (i2 = this.start; index < length && i2 < byteCount; ++index) {
                code = message.charCodeAt(index);
                if (code < 128) {
                  blocks2[i2 >> 2] |= code << SHIFT2[i2++ & 3];
                } else if (code < 2048) {
                  blocks2[i2 >> 2] |= (192 | code >> 6) << SHIFT2[i2++ & 3];
                  blocks2[i2 >> 2] |= (128 | code & 63) << SHIFT2[i2++ & 3];
                } else if (code < 55296 || code >= 57344) {
                  blocks2[i2 >> 2] |= (224 | code >> 12) << SHIFT2[i2++ & 3];
                  blocks2[i2 >> 2] |= (128 | code >> 6 & 63) << SHIFT2[i2++ & 3];
                  blocks2[i2 >> 2] |= (128 | code & 63) << SHIFT2[i2++ & 3];
                } else {
                  code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                  blocks2[i2 >> 2] |= (240 | code >> 18) << SHIFT2[i2++ & 3];
                  blocks2[i2 >> 2] |= (128 | code >> 12 & 63) << SHIFT2[i2++ & 3];
                  blocks2[i2 >> 2] |= (128 | code >> 6 & 63) << SHIFT2[i2++ & 3];
                  blocks2[i2 >> 2] |= (128 | code & 63) << SHIFT2[i2++ & 3];
                }
              }
            }
            this.lastByteIndex = i2;
            if (i2 >= byteCount) {
              this.start = i2 - byteCount;
              this.block = blocks2[blockCount];
              for (i2 = 0; i2 < blockCount; ++i2) {
                s[i2] ^= blocks2[i2];
              }
              f(s);
              this.reset = true;
            } else {
              this.start = i2;
            }
          }
          return this;
        };
        Keccak.prototype.encode = function(x, right) {
          var o = x & 255, n = 1;
          var bytes = [o];
          x = x >> 8;
          o = x & 255;
          while (o > 0) {
            bytes.unshift(o);
            x = x >> 8;
            o = x & 255;
            ++n;
          }
          if (right) {
            bytes.push(n);
          } else {
            bytes.unshift(n);
          }
          this.update(bytes);
          return bytes.length;
        };
        Keccak.prototype.encodeString = function(str) {
          var notString, type = typeof str;
          if (type !== "string") {
            if (type === "object") {
              if (str === null) {
                throw new Error(INPUT_ERROR);
              } else if (ARRAY_BUFFER2 && str.constructor === ArrayBuffer) {
                str = new Uint8Array(str);
              } else if (!Array.isArray(str)) {
                if (!ARRAY_BUFFER2 || !ArrayBuffer.isView(str)) {
                  throw new Error(INPUT_ERROR);
                }
              }
            } else {
              throw new Error(INPUT_ERROR);
            }
            notString = true;
          }
          var bytes = 0, length = str.length;
          if (notString) {
            bytes = length;
          } else {
            for (var i2 = 0; i2 < str.length; ++i2) {
              var code = str.charCodeAt(i2);
              if (code < 128) {
                bytes += 1;
              } else if (code < 2048) {
                bytes += 2;
              } else if (code < 55296 || code >= 57344) {
                bytes += 3;
              } else {
                code = 65536 + ((code & 1023) << 10 | str.charCodeAt(++i2) & 1023);
                bytes += 4;
              }
            }
          }
          bytes += this.encode(bytes * 8);
          this.update(str);
          return bytes;
        };
        Keccak.prototype.bytepad = function(strs, w) {
          var bytes = this.encode(w);
          for (var i2 = 0; i2 < strs.length; ++i2) {
            bytes += this.encodeString(strs[i2]);
          }
          var paddingBytes = w - bytes % w;
          var zeros = [];
          zeros.length = paddingBytes;
          this.update(zeros);
          return this;
        };
        Keccak.prototype.finalize = function() {
          if (this.finalized) {
            return;
          }
          this.finalized = true;
          var blocks2 = this.blocks, i2 = this.lastByteIndex, blockCount = this.blockCount, s = this.s;
          blocks2[i2 >> 2] |= this.padding[i2 & 3];
          if (this.lastByteIndex === this.byteCount) {
            blocks2[0] = blocks2[blockCount];
            for (i2 = 1; i2 < blockCount + 1; ++i2) {
              blocks2[i2] = 0;
            }
          }
          blocks2[blockCount - 1] |= 2147483648;
          for (i2 = 0; i2 < blockCount; ++i2) {
            s[i2] ^= blocks2[i2];
          }
          f(s);
        };
        Keccak.prototype.toString = Keccak.prototype.hex = function() {
          this.finalize();
          var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
          var hex = "", block;
          while (j2 < outputBlocks) {
            for (i2 = 0; i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
              block = s[i2];
              hex += HEX_CHARS2[block >> 4 & 15] + HEX_CHARS2[block & 15] + HEX_CHARS2[block >> 12 & 15] + HEX_CHARS2[block >> 8 & 15] + HEX_CHARS2[block >> 20 & 15] + HEX_CHARS2[block >> 16 & 15] + HEX_CHARS2[block >> 28 & 15] + HEX_CHARS2[block >> 24 & 15];
            }
            if (j2 % blockCount === 0) {
              f(s);
              i2 = 0;
            }
          }
          if (extraBytes) {
            block = s[i2];
            hex += HEX_CHARS2[block >> 4 & 15] + HEX_CHARS2[block & 15];
            if (extraBytes > 1) {
              hex += HEX_CHARS2[block >> 12 & 15] + HEX_CHARS2[block >> 8 & 15];
            }
            if (extraBytes > 2) {
              hex += HEX_CHARS2[block >> 20 & 15] + HEX_CHARS2[block >> 16 & 15];
            }
          }
          return hex;
        };
        Keccak.prototype.arrayBuffer = function() {
          this.finalize();
          var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
          var bytes = this.outputBits >> 3;
          var buffer;
          if (extraBytes) {
            buffer = new ArrayBuffer(outputBlocks + 1 << 2);
          } else {
            buffer = new ArrayBuffer(bytes);
          }
          var array = new Uint32Array(buffer);
          while (j2 < outputBlocks) {
            for (i2 = 0; i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
              array[j2] = s[i2];
            }
            if (j2 % blockCount === 0) {
              f(s);
            }
          }
          if (extraBytes) {
            array[i2] = s[i2];
            buffer = buffer.slice(0, bytes);
          }
          return buffer;
        };
        Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;
        Keccak.prototype.digest = Keccak.prototype.array = function() {
          this.finalize();
          var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
          var array = [], offset, block;
          while (j2 < outputBlocks) {
            for (i2 = 0; i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
              offset = j2 << 2;
              block = s[i2];
              array[offset] = block & 255;
              array[offset + 1] = block >> 8 & 255;
              array[offset + 2] = block >> 16 & 255;
              array[offset + 3] = block >> 24 & 255;
            }
            if (j2 % blockCount === 0) {
              f(s);
            }
          }
          if (extraBytes) {
            offset = j2 << 2;
            block = s[i2];
            array[offset] = block & 255;
            if (extraBytes > 1) {
              array[offset + 1] = block >> 8 & 255;
            }
            if (extraBytes > 2) {
              array[offset + 2] = block >> 16 & 255;
            }
          }
          return array;
        };
        function Kmac(bits2, padding, outputBits) {
          Keccak.call(this, bits2, padding, outputBits);
        }
        Kmac.prototype = new Keccak();
        Kmac.prototype.finalize = function() {
          this.encode(this.outputBits, true);
          return Keccak.prototype.finalize.call(this);
        };
        var f = function(s) {
          var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
          for (n = 0; n < 48; n += 2) {
            c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
            c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
            c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
            c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
            c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
            c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
            c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
            c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
            c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
            c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];
            h = c8 ^ (c2 << 1 | c3 >>> 31);
            l = c9 ^ (c3 << 1 | c2 >>> 31);
            s[0] ^= h;
            s[1] ^= l;
            s[10] ^= h;
            s[11] ^= l;
            s[20] ^= h;
            s[21] ^= l;
            s[30] ^= h;
            s[31] ^= l;
            s[40] ^= h;
            s[41] ^= l;
            h = c0 ^ (c4 << 1 | c5 >>> 31);
            l = c1 ^ (c5 << 1 | c4 >>> 31);
            s[2] ^= h;
            s[3] ^= l;
            s[12] ^= h;
            s[13] ^= l;
            s[22] ^= h;
            s[23] ^= l;
            s[32] ^= h;
            s[33] ^= l;
            s[42] ^= h;
            s[43] ^= l;
            h = c2 ^ (c6 << 1 | c7 >>> 31);
            l = c3 ^ (c7 << 1 | c6 >>> 31);
            s[4] ^= h;
            s[5] ^= l;
            s[14] ^= h;
            s[15] ^= l;
            s[24] ^= h;
            s[25] ^= l;
            s[34] ^= h;
            s[35] ^= l;
            s[44] ^= h;
            s[45] ^= l;
            h = c4 ^ (c8 << 1 | c9 >>> 31);
            l = c5 ^ (c9 << 1 | c8 >>> 31);
            s[6] ^= h;
            s[7] ^= l;
            s[16] ^= h;
            s[17] ^= l;
            s[26] ^= h;
            s[27] ^= l;
            s[36] ^= h;
            s[37] ^= l;
            s[46] ^= h;
            s[47] ^= l;
            h = c6 ^ (c0 << 1 | c1 >>> 31);
            l = c7 ^ (c1 << 1 | c0 >>> 31);
            s[8] ^= h;
            s[9] ^= l;
            s[18] ^= h;
            s[19] ^= l;
            s[28] ^= h;
            s[29] ^= l;
            s[38] ^= h;
            s[39] ^= l;
            s[48] ^= h;
            s[49] ^= l;
            b0 = s[0];
            b1 = s[1];
            b32 = s[11] << 4 | s[10] >>> 28;
            b33 = s[10] << 4 | s[11] >>> 28;
            b14 = s[20] << 3 | s[21] >>> 29;
            b15 = s[21] << 3 | s[20] >>> 29;
            b46 = s[31] << 9 | s[30] >>> 23;
            b47 = s[30] << 9 | s[31] >>> 23;
            b28 = s[40] << 18 | s[41] >>> 14;
            b29 = s[41] << 18 | s[40] >>> 14;
            b20 = s[2] << 1 | s[3] >>> 31;
            b21 = s[3] << 1 | s[2] >>> 31;
            b2 = s[13] << 12 | s[12] >>> 20;
            b3 = s[12] << 12 | s[13] >>> 20;
            b34 = s[22] << 10 | s[23] >>> 22;
            b35 = s[23] << 10 | s[22] >>> 22;
            b16 = s[33] << 13 | s[32] >>> 19;
            b17 = s[32] << 13 | s[33] >>> 19;
            b48 = s[42] << 2 | s[43] >>> 30;
            b49 = s[43] << 2 | s[42] >>> 30;
            b40 = s[5] << 30 | s[4] >>> 2;
            b41 = s[4] << 30 | s[5] >>> 2;
            b22 = s[14] << 6 | s[15] >>> 26;
            b23 = s[15] << 6 | s[14] >>> 26;
            b4 = s[25] << 11 | s[24] >>> 21;
            b5 = s[24] << 11 | s[25] >>> 21;
            b36 = s[34] << 15 | s[35] >>> 17;
            b37 = s[35] << 15 | s[34] >>> 17;
            b18 = s[45] << 29 | s[44] >>> 3;
            b19 = s[44] << 29 | s[45] >>> 3;
            b10 = s[6] << 28 | s[7] >>> 4;
            b11 = s[7] << 28 | s[6] >>> 4;
            b42 = s[17] << 23 | s[16] >>> 9;
            b43 = s[16] << 23 | s[17] >>> 9;
            b24 = s[26] << 25 | s[27] >>> 7;
            b25 = s[27] << 25 | s[26] >>> 7;
            b6 = s[36] << 21 | s[37] >>> 11;
            b7 = s[37] << 21 | s[36] >>> 11;
            b38 = s[47] << 24 | s[46] >>> 8;
            b39 = s[46] << 24 | s[47] >>> 8;
            b30 = s[8] << 27 | s[9] >>> 5;
            b31 = s[9] << 27 | s[8] >>> 5;
            b12 = s[18] << 20 | s[19] >>> 12;
            b13 = s[19] << 20 | s[18] >>> 12;
            b44 = s[29] << 7 | s[28] >>> 25;
            b45 = s[28] << 7 | s[29] >>> 25;
            b26 = s[38] << 8 | s[39] >>> 24;
            b27 = s[39] << 8 | s[38] >>> 24;
            b8 = s[48] << 14 | s[49] >>> 18;
            b9 = s[49] << 14 | s[48] >>> 18;
            s[0] = b0 ^ ~b2 & b4;
            s[1] = b1 ^ ~b3 & b5;
            s[10] = b10 ^ ~b12 & b14;
            s[11] = b11 ^ ~b13 & b15;
            s[20] = b20 ^ ~b22 & b24;
            s[21] = b21 ^ ~b23 & b25;
            s[30] = b30 ^ ~b32 & b34;
            s[31] = b31 ^ ~b33 & b35;
            s[40] = b40 ^ ~b42 & b44;
            s[41] = b41 ^ ~b43 & b45;
            s[2] = b2 ^ ~b4 & b6;
            s[3] = b3 ^ ~b5 & b7;
            s[12] = b12 ^ ~b14 & b16;
            s[13] = b13 ^ ~b15 & b17;
            s[22] = b22 ^ ~b24 & b26;
            s[23] = b23 ^ ~b25 & b27;
            s[32] = b32 ^ ~b34 & b36;
            s[33] = b33 ^ ~b35 & b37;
            s[42] = b42 ^ ~b44 & b46;
            s[43] = b43 ^ ~b45 & b47;
            s[4] = b4 ^ ~b6 & b8;
            s[5] = b5 ^ ~b7 & b9;
            s[14] = b14 ^ ~b16 & b18;
            s[15] = b15 ^ ~b17 & b19;
            s[24] = b24 ^ ~b26 & b28;
            s[25] = b25 ^ ~b27 & b29;
            s[34] = b34 ^ ~b36 & b38;
            s[35] = b35 ^ ~b37 & b39;
            s[44] = b44 ^ ~b46 & b48;
            s[45] = b45 ^ ~b47 & b49;
            s[6] = b6 ^ ~b8 & b0;
            s[7] = b7 ^ ~b9 & b1;
            s[16] = b16 ^ ~b18 & b10;
            s[17] = b17 ^ ~b19 & b11;
            s[26] = b26 ^ ~b28 & b20;
            s[27] = b27 ^ ~b29 & b21;
            s[36] = b36 ^ ~b38 & b30;
            s[37] = b37 ^ ~b39 & b31;
            s[46] = b46 ^ ~b48 & b40;
            s[47] = b47 ^ ~b49 & b41;
            s[8] = b8 ^ ~b0 & b2;
            s[9] = b9 ^ ~b1 & b3;
            s[18] = b18 ^ ~b10 & b12;
            s[19] = b19 ^ ~b11 & b13;
            s[28] = b28 ^ ~b20 & b22;
            s[29] = b29 ^ ~b21 & b23;
            s[38] = b38 ^ ~b30 & b32;
            s[39] = b39 ^ ~b31 & b33;
            s[48] = b48 ^ ~b40 & b42;
            s[49] = b49 ^ ~b41 & b43;
            s[0] ^= RC[n];
            s[1] ^= RC[n + 1];
          }
        };
        if (COMMON_JS2) {
          module2.exports = methods;
        } else {
          for (i = 0; i < methodNames.length; ++i) {
            root2[methodNames[i]] = methods[methodNames[i]];
          }
          if (AMD2) {
            define(function() {
              return methods;
            });
          }
        }
      })();
    }
  });

  // node_modules/algosdk/dist/esm/src/logicTemplates/htlc.js
  var require_htlc = __commonJS({
    "node_modules/algosdk/dist/esm/src/logicTemplates/htlc.js"(exports2, module2) {
      var sha256 = require_sha256();
      var { keccak256 } = require_sha3();
      var logic = (init_logic(), __toCommonJS(logic_exports));
      var logicSig = (init_logicsig(), __toCommonJS(logicsig_exports));
      var templates = require_templates();
      var transaction = (init_transaction(), __toCommonJS(transaction_exports));
      var HTLC = class {
        constructor(owner, receiver, hashFunction, hashImage, expiryRound, maxFee) {
          if (!Number.isSafeInteger(expiryRound) || expiryRound < 0)
            throw Error("expiryRound must be a positive number and smaller than 2^53-1");
          if (!Number.isSafeInteger(maxFee) || maxFee < 0)
            throw Error("maxFee must be a positive number and smaller than 2^53-1");
          let referenceProgramB64 = "";
          if (hashFunction === "sha256") {
            referenceProgramB64 = "ASAECAEACSYDIOaalh5vLV96yGYHkmVSvpgjXtMzY8qIkYu5yTipFbb5IH+DsWV/8fxTuS3BgUih1l38LUsfo9Z3KErd0gASbZBpIP68oLsUSlpOp7Q4pGgayA5soQW8tgf8VlMlyVaV9qITMQEiDjEQIxIQMQcyAxIQMQgkEhAxCSgSLQEpEhAxCSoSMQIlDRAREA==";
          } else if (hashFunction === "keccak256") {
            referenceProgramB64 = "ASAECAEACSYDIOaalh5vLV96yGYHkmVSvpgjXtMzY8qIkYu5yTipFbb5IH+DsWV/8fxTuS3BgUih1l38LUsfo9Z3KErd0gASbZBpIP68oLsUSlpOp7Q4pGgayA5soQW8tgf8VlMlyVaV9qITMQEiDjEQIxIQMQcyAxIQMQgkEhAxCSgSLQIpEhAxCSoSMQIlDRAREA==";
          } else {
            throw Error("hash function unrecognized");
          }
          const hashImageBytes = Buffer.from(hashImage, "base64");
          if (hashImageBytes.length !== 32)
            throw Error("hash image must be 32 bytes");
          const referenceProgramBytes = Buffer.from(referenceProgramB64, "base64");
          const referenceOffsets = [
            3,
            6,
            10,
            42,
            76
          ];
          const injectionVector = [maxFee, expiryRound, receiver, hashImage, owner];
          const injectionTypes = [
            templates.valTypes.INT,
            templates.valTypes.INT,
            templates.valTypes.ADDRESS,
            templates.valTypes.BASE64,
            templates.valTypes.ADDRESS
          ];
          const injectedBytes = templates.inject(referenceProgramBytes, referenceOffsets, injectionVector, injectionTypes);
          this.programBytes = injectedBytes;
          const lsig = new logicSig.LogicSig(injectedBytes, void 0);
          this.address = lsig.address();
        }
        getProgram() {
          return this.programBytes;
        }
        getAddress() {
          return this.address;
        }
      };
      function signTransactionWithHTLCUnlock(contract, txn, preImageAsBase64) {
        const preImageBytes = Buffer.from(preImageAsBase64, "base64");
        const readResult = logic.readProgram(contract, void 0);
        const ints = readResult[0];
        const byteArrays = readResult[1];
        const expectedHashedOutput = byteArrays[1];
        const hashFunction = contract[contract.length - 15];
        if (hashFunction === 1) {
          const hash = sha256.create();
          hash.update(preImageBytes);
          const actualHashedOutput = Buffer.from(hash.hex(), "hex");
          if (!actualHashedOutput.equals(expectedHashedOutput)) {
            throw new Error("sha256 hash of preimage did not match stored contract hash");
          }
        } else if (hashFunction === 2) {
          const hash = keccak256.create();
          hash.update(preImageBytes);
          const actualHashedOutput = Buffer.from(hash.hex(), "hex");
          if (!actualHashedOutput.equals(expectedHashedOutput)) {
            throw new Error("keccak256 hash of preimage did not match stored contract hash");
          }
        } else {
          throw new Error("hash function in contract unrecognized");
        }
        const args = [preImageBytes];
        const lsig = new logicSig.LogicSig(contract, args);
        delete txn.to;
        const maxFee = ints[0];
        const tempTxn = new transaction.Transaction(txn);
        if (tempTxn.fee > maxFee) {
          throw new Error(`final fee of payment transaction${tempTxn.fee.toString()}greater than transaction max fee${maxFee.toString()}`);
        }
        return logicSig.signLogicSigTransaction(txn, lsig);
      }
      module2.exports = {
        HTLC,
        signTransactionWithHTLCUnlock
      };
    }
  });

  // node_modules/algosdk/dist/esm/src/types/transactions/encoded.js
  var init_encoded = __esm({
    "node_modules/algosdk/dist/esm/src/types/transactions/encoded.js"() {
    }
  });

  // node_modules/algosdk/dist/esm/src/types/transactions/index.js
  var init_transactions = __esm({
    "node_modules/algosdk/dist/esm/src/types/transactions/index.js"() {
      init_base();
      init_encoded();
    }
  });

  // node_modules/algosdk/dist/esm/src/makeTxn.js
  var makeTxn_exports = {};
  __export(makeTxn_exports, {
    OnApplicationComplete: () => OnApplicationComplete,
    makeApplicationCallTxnFromObject: () => makeApplicationCallTxnFromObject,
    makeApplicationClearStateTxn: () => makeApplicationClearStateTxn,
    makeApplicationClearStateTxnFromObject: () => makeApplicationClearStateTxnFromObject,
    makeApplicationCloseOutTxn: () => makeApplicationCloseOutTxn,
    makeApplicationCloseOutTxnFromObject: () => makeApplicationCloseOutTxnFromObject,
    makeApplicationCreateTxn: () => makeApplicationCreateTxn,
    makeApplicationCreateTxnFromObject: () => makeApplicationCreateTxnFromObject,
    makeApplicationDeleteTxn: () => makeApplicationDeleteTxn,
    makeApplicationDeleteTxnFromObject: () => makeApplicationDeleteTxnFromObject,
    makeApplicationNoOpTxn: () => makeApplicationNoOpTxn,
    makeApplicationNoOpTxnFromObject: () => makeApplicationNoOpTxnFromObject,
    makeApplicationOptInTxn: () => makeApplicationOptInTxn,
    makeApplicationOptInTxnFromObject: () => makeApplicationOptInTxnFromObject,
    makeApplicationUpdateTxn: () => makeApplicationUpdateTxn,
    makeApplicationUpdateTxnFromObject: () => makeApplicationUpdateTxnFromObject,
    makeAssetConfigTxn: () => makeAssetConfigTxn,
    makeAssetConfigTxnWithSuggestedParams: () => makeAssetConfigTxnWithSuggestedParams,
    makeAssetConfigTxnWithSuggestedParamsFromObject: () => makeAssetConfigTxnWithSuggestedParamsFromObject,
    makeAssetCreateTxn: () => makeAssetCreateTxn,
    makeAssetCreateTxnWithSuggestedParams: () => makeAssetCreateTxnWithSuggestedParams,
    makeAssetCreateTxnWithSuggestedParamsFromObject: () => makeAssetCreateTxnWithSuggestedParamsFromObject,
    makeAssetDestroyTxn: () => makeAssetDestroyTxn,
    makeAssetDestroyTxnWithSuggestedParams: () => makeAssetDestroyTxnWithSuggestedParams,
    makeAssetDestroyTxnWithSuggestedParamsFromObject: () => makeAssetDestroyTxnWithSuggestedParamsFromObject,
    makeAssetFreezeTxn: () => makeAssetFreezeTxn,
    makeAssetFreezeTxnWithSuggestedParams: () => makeAssetFreezeTxnWithSuggestedParams,
    makeAssetFreezeTxnWithSuggestedParamsFromObject: () => makeAssetFreezeTxnWithSuggestedParamsFromObject,
    makeAssetTransferTxn: () => makeAssetTransferTxn,
    makeAssetTransferTxnWithSuggestedParams: () => makeAssetTransferTxnWithSuggestedParams,
    makeAssetTransferTxnWithSuggestedParamsFromObject: () => makeAssetTransferTxnWithSuggestedParamsFromObject,
    makeKeyRegistrationTxn: () => makeKeyRegistrationTxn,
    makeKeyRegistrationTxnWithSuggestedParams: () => makeKeyRegistrationTxnWithSuggestedParams,
    makeKeyRegistrationTxnWithSuggestedParamsFromObject: () => makeKeyRegistrationTxnWithSuggestedParamsFromObject,
    makePaymentTxn: () => makePaymentTxn,
    makePaymentTxnWithSuggestedParams: () => makePaymentTxnWithSuggestedParams,
    makePaymentTxnWithSuggestedParamsFromObject: () => makePaymentTxnWithSuggestedParamsFromObject
  });
  function makePaymentTxnWithSuggestedParams(from, to, amount, closeRemainderTo, note, suggestedParams, rekeyTo) {
    const o = {
      from,
      to,
      amount,
      closeRemainderTo,
      note,
      suggestedParams,
      type: TransactionType.pay,
      reKeyTo: rekeyTo
    };
    return new Transaction(o);
  }
  function makePaymentTxn(from, to, fee, amount, closeRemainderTo, firstRound, lastRound, note, genesisHash, genesisID, rekeyTo) {
    const suggestedParams = {
      genesisHash,
      genesisID,
      firstRound,
      lastRound,
      fee
    };
    return makePaymentTxnWithSuggestedParams(from, to, amount, closeRemainderTo, note, suggestedParams, rekeyTo);
  }
  function makePaymentTxnWithSuggestedParamsFromObject(o) {
    return makePaymentTxnWithSuggestedParams(o.from, o.to, o.amount, o.closeRemainderTo, o.note, o.suggestedParams, o.rekeyTo);
  }
  function makeKeyRegistrationTxnWithSuggestedParams(from, note, voteKey, selectionKey, voteFirst, voteLast, voteKeyDilution, suggestedParams, rekeyTo, nonParticipation = false) {
    const o = {
      from,
      note,
      voteKey,
      selectionKey,
      voteFirst,
      voteLast,
      voteKeyDilution,
      suggestedParams,
      type: TransactionType.keyreg,
      reKeyTo: rekeyTo,
      nonParticipation
    };
    return new Transaction(o);
  }
  function makeKeyRegistrationTxn(from, fee, firstRound, lastRound, note, genesisHash, genesisID, voteKey, selectionKey, voteFirst, voteLast, voteKeyDilution, rekeyTo, nonParticipation = false) {
    const suggestedParams = {
      genesisHash,
      genesisID,
      firstRound,
      lastRound,
      fee
    };
    return makeKeyRegistrationTxnWithSuggestedParams(from, note, voteKey, selectionKey, voteFirst, voteLast, voteKeyDilution, suggestedParams, rekeyTo, nonParticipation);
  }
  function makeKeyRegistrationTxnWithSuggestedParamsFromObject(o) {
    return makeKeyRegistrationTxnWithSuggestedParams(o.from, o.note, o.voteKey, o.selectionKey, o.voteFirst, o.voteLast, o.voteKeyDilution, o.suggestedParams, o.rekeyTo, o.nonParticipation);
  }
  function makeAssetCreateTxnWithSuggestedParams(from, note, total, decimals, defaultFrozen, manager, reserve, freeze, clawback, unitName, assetName, assetURL, assetMetadataHash, suggestedParams, rekeyTo) {
    const o = {
      from,
      note,
      suggestedParams,
      assetTotal: total,
      assetDecimals: decimals,
      assetDefaultFrozen: defaultFrozen,
      assetUnitName: unitName,
      assetName,
      assetURL,
      assetMetadataHash,
      assetManager: manager,
      assetReserve: reserve,
      assetFreeze: freeze,
      assetClawback: clawback,
      type: TransactionType.acfg,
      reKeyTo: rekeyTo
    };
    return new Transaction(o);
  }
  function makeAssetCreateTxn(from, fee, firstRound, lastRound, note, genesisHash, genesisID, total, decimals, defaultFrozen, manager, reserve, freeze, clawback, unitName, assetName, assetURL, assetMetadataHash, rekeyTo) {
    const suggestedParams = {
      genesisHash,
      genesisID,
      firstRound,
      lastRound,
      fee
    };
    return makeAssetCreateTxnWithSuggestedParams(from, note, total, decimals, defaultFrozen, manager, reserve, freeze, clawback, unitName, assetName, assetURL, assetMetadataHash, suggestedParams, rekeyTo);
  }
  function makeAssetCreateTxnWithSuggestedParamsFromObject(o) {
    return makeAssetCreateTxnWithSuggestedParams(o.from, o.note, o.total, o.decimals, o.defaultFrozen, o.manager, o.reserve, o.freeze, o.clawback, o.unitName, o.assetName, o.assetURL, o.assetMetadataHash, o.suggestedParams, o.rekeyTo);
  }
  function makeAssetConfigTxnWithSuggestedParams(from, note, assetIndex, manager, reserve, freeze, clawback, suggestedParams, strictEmptyAddressChecking = true, rekeyTo) {
    if (strictEmptyAddressChecking && (manager === void 0 || reserve === void 0 || freeze === void 0 || clawback === void 0)) {
      throw Error("strict empty address checking was turned on, but at least one empty address was provided");
    }
    const o = {
      from,
      suggestedParams,
      assetIndex,
      assetManager: manager,
      assetReserve: reserve,
      assetFreeze: freeze,
      assetClawback: clawback,
      type: TransactionType.acfg,
      note,
      reKeyTo: rekeyTo
    };
    return new Transaction(o);
  }
  function makeAssetConfigTxn(from, fee, firstRound, lastRound, note, genesisHash, genesisID, assetIndex, manager, reserve, freeze, clawback, strictEmptyAddressChecking = true, rekeyTo) {
    const suggestedParams = {
      genesisHash,
      genesisID,
      firstRound,
      lastRound,
      fee
    };
    return makeAssetConfigTxnWithSuggestedParams(from, note, assetIndex, manager, reserve, freeze, clawback, suggestedParams, strictEmptyAddressChecking, rekeyTo);
  }
  function makeAssetConfigTxnWithSuggestedParamsFromObject(o) {
    return makeAssetConfigTxnWithSuggestedParams(o.from, o.note, o.assetIndex, o.manager, o.reserve, o.freeze, o.clawback, o.suggestedParams, o.strictEmptyAddressChecking, o.rekeyTo);
  }
  function makeAssetDestroyTxnWithSuggestedParams(from, note, assetIndex, suggestedParams, rekeyTo) {
    const o = {
      from,
      suggestedParams,
      assetIndex,
      type: TransactionType.acfg,
      note,
      reKeyTo: rekeyTo
    };
    return new Transaction(o);
  }
  function makeAssetDestroyTxn(from, fee, firstRound, lastRound, note, genesisHash, genesisID, assetIndex, rekeyTo) {
    const suggestedParams = {
      genesisHash,
      genesisID,
      firstRound,
      lastRound,
      fee
    };
    return makeAssetDestroyTxnWithSuggestedParams(from, note, assetIndex, suggestedParams, rekeyTo);
  }
  function makeAssetDestroyTxnWithSuggestedParamsFromObject(o) {
    return makeAssetDestroyTxnWithSuggestedParams(o.from, o.note, o.assetIndex, o.suggestedParams, o.rekeyTo);
  }
  function makeAssetFreezeTxnWithSuggestedParams(from, note, assetIndex, freezeTarget, freezeState, suggestedParams, rekeyTo) {
    const o = {
      from,
      type: TransactionType.afrz,
      freezeAccount: freezeTarget,
      assetIndex,
      freezeState,
      note,
      suggestedParams,
      reKeyTo: rekeyTo
    };
    return new Transaction(o);
  }
  function makeAssetFreezeTxn(from, fee, firstRound, lastRound, note, genesisHash, genesisID, assetIndex, freezeTarget, freezeState, rekeyTo) {
    const suggestedParams = {
      genesisHash,
      genesisID,
      firstRound,
      lastRound,
      fee
    };
    return makeAssetFreezeTxnWithSuggestedParams(from, note, assetIndex, freezeTarget, freezeState, suggestedParams, rekeyTo);
  }
  function makeAssetFreezeTxnWithSuggestedParamsFromObject(o) {
    return makeAssetFreezeTxnWithSuggestedParams(o.from, o.note, o.assetIndex, o.freezeTarget, o.freezeState, o.suggestedParams, o.rekeyTo);
  }
  function makeAssetTransferTxnWithSuggestedParams(from, to, closeRemainderTo, revocationTarget, amount, note, assetIndex, suggestedParams, rekeyTo) {
    const o = {
      type: TransactionType.axfer,
      from,
      to,
      amount,
      suggestedParams,
      assetIndex,
      note,
      assetRevocationTarget: revocationTarget,
      closeRemainderTo,
      reKeyTo: rekeyTo
    };
    return new Transaction(o);
  }
  function makeAssetTransferTxn(from, to, closeRemainderTo, revocationTarget, fee, amount, firstRound, lastRound, note, genesisHash, genesisID, assetIndex, rekeyTo) {
    const suggestedParams = {
      genesisHash,
      genesisID,
      firstRound,
      lastRound,
      fee
    };
    return makeAssetTransferTxnWithSuggestedParams(from, to, closeRemainderTo, revocationTarget, amount, note, assetIndex, suggestedParams, rekeyTo);
  }
  function makeAssetTransferTxnWithSuggestedParamsFromObject(o) {
    return makeAssetTransferTxnWithSuggestedParams(o.from, o.to, o.closeRemainderTo, o.revocationTarget, o.amount, o.note, o.assetIndex, o.suggestedParams, o.rekeyTo);
  }
  function makeApplicationCreateTxn(from, suggestedParams, onComplete, approvalProgram, clearProgram, numLocalInts, numLocalByteSlices, numGlobalInts, numGlobalByteSlices, appArgs, accounts, foreignApps, foreignAssets, note, lease, rekeyTo, extraPages) {
    const o = {
      type: TransactionType.appl,
      from,
      suggestedParams,
      appIndex: 0,
      appOnComplete: onComplete,
      appLocalInts: numLocalInts,
      appLocalByteSlices: numLocalByteSlices,
      appGlobalInts: numGlobalInts,
      appGlobalByteSlices: numGlobalByteSlices,
      appApprovalProgram: approvalProgram,
      appClearProgram: clearProgram,
      appArgs,
      appAccounts: accounts,
      appForeignApps: foreignApps,
      appForeignAssets: foreignAssets,
      note,
      lease,
      reKeyTo: rekeyTo,
      extraPages
    };
    return new Transaction(o);
  }
  function makeApplicationCreateTxnFromObject(o) {
    return makeApplicationCreateTxn(o.from, o.suggestedParams, o.onComplete, o.approvalProgram, o.clearProgram, o.numLocalInts, o.numLocalByteSlices, o.numGlobalInts, o.numGlobalByteSlices, o.appArgs, o.accounts, o.foreignApps, o.foreignAssets, o.note, o.lease, o.rekeyTo, o.extraPages);
  }
  function makeApplicationUpdateTxn(from, suggestedParams, appIndex, approvalProgram, clearProgram, appArgs, accounts, foreignApps, foreignAssets, note, lease, rekeyTo) {
    const o = {
      type: TransactionType.appl,
      from,
      suggestedParams,
      appIndex,
      appApprovalProgram: approvalProgram,
      appOnComplete: OnApplicationComplete.UpdateApplicationOC,
      appClearProgram: clearProgram,
      appArgs,
      appAccounts: accounts,
      appForeignApps: foreignApps,
      appForeignAssets: foreignAssets,
      note,
      lease,
      reKeyTo: rekeyTo
    };
    return new Transaction(o);
  }
  function makeApplicationUpdateTxnFromObject(o) {
    return makeApplicationUpdateTxn(o.from, o.suggestedParams, o.appIndex, o.approvalProgram, o.clearProgram, o.appArgs, o.accounts, o.foreignApps, o.foreignAssets, o.note, o.lease, o.rekeyTo);
  }
  function makeApplicationDeleteTxn(from, suggestedParams, appIndex, appArgs, accounts, foreignApps, foreignAssets, note, lease, rekeyTo) {
    const o = {
      type: TransactionType.appl,
      from,
      suggestedParams,
      appIndex,
      appOnComplete: OnApplicationComplete.DeleteApplicationOC,
      appArgs,
      appAccounts: accounts,
      appForeignApps: foreignApps,
      appForeignAssets: foreignAssets,
      note,
      lease,
      reKeyTo: rekeyTo
    };
    return new Transaction(o);
  }
  function makeApplicationDeleteTxnFromObject(o) {
    return makeApplicationDeleteTxn(o.from, o.suggestedParams, o.appIndex, o.appArgs, o.accounts, o.foreignApps, o.foreignAssets, o.note, o.lease, o.rekeyTo);
  }
  function makeApplicationOptInTxn(from, suggestedParams, appIndex, appArgs, accounts, foreignApps, foreignAssets, note, lease, rekeyTo) {
    const o = {
      type: TransactionType.appl,
      from,
      suggestedParams,
      appIndex,
      appOnComplete: OnApplicationComplete.OptInOC,
      appArgs,
      appAccounts: accounts,
      appForeignApps: foreignApps,
      appForeignAssets: foreignAssets,
      note,
      lease,
      reKeyTo: rekeyTo
    };
    return new Transaction(o);
  }
  function makeApplicationOptInTxnFromObject(o) {
    return makeApplicationOptInTxn(o.from, o.suggestedParams, o.appIndex, o.appArgs, o.accounts, o.foreignApps, o.foreignAssets, o.note, o.lease, o.rekeyTo);
  }
  function makeApplicationCloseOutTxn(from, suggestedParams, appIndex, appArgs, accounts, foreignApps, foreignAssets, note, lease, rekeyTo) {
    const o = {
      type: TransactionType.appl,
      from,
      suggestedParams,
      appIndex,
      appOnComplete: OnApplicationComplete.CloseOutOC,
      appArgs,
      appAccounts: accounts,
      appForeignApps: foreignApps,
      appForeignAssets: foreignAssets,
      note,
      lease,
      reKeyTo: rekeyTo
    };
    return new Transaction(o);
  }
  function makeApplicationCloseOutTxnFromObject(o) {
    return makeApplicationCloseOutTxn(o.from, o.suggestedParams, o.appIndex, o.appArgs, o.accounts, o.foreignApps, o.foreignAssets, o.note, o.lease, o.rekeyTo);
  }
  function makeApplicationClearStateTxn(from, suggestedParams, appIndex, appArgs, accounts, foreignApps, foreignAssets, note, lease, rekeyTo) {
    const o = {
      type: TransactionType.appl,
      from,
      suggestedParams,
      appIndex,
      appOnComplete: OnApplicationComplete.ClearStateOC,
      appArgs,
      appAccounts: accounts,
      appForeignApps: foreignApps,
      appForeignAssets: foreignAssets,
      note,
      lease,
      reKeyTo: rekeyTo
    };
    return new Transaction(o);
  }
  function makeApplicationClearStateTxnFromObject(o) {
    return makeApplicationClearStateTxn(o.from, o.suggestedParams, o.appIndex, o.appArgs, o.accounts, o.foreignApps, o.foreignAssets, o.note, o.lease, o.rekeyTo);
  }
  function makeApplicationNoOpTxn(from, suggestedParams, appIndex, appArgs, accounts, foreignApps, foreignAssets, note, lease, rekeyTo) {
    const o = {
      type: TransactionType.appl,
      from,
      suggestedParams,
      appIndex,
      appOnComplete: OnApplicationComplete.NoOpOC,
      appArgs,
      appAccounts: accounts,
      appForeignApps: foreignApps,
      appForeignAssets: foreignAssets,
      note,
      lease,
      reKeyTo: rekeyTo
    };
    return new Transaction(o);
  }
  function makeApplicationNoOpTxnFromObject(o) {
    return makeApplicationNoOpTxn(o.from, o.suggestedParams, o.appIndex, o.appArgs, o.accounts, o.foreignApps, o.foreignAssets, o.note, o.lease, o.rekeyTo);
  }
  function makeApplicationCallTxnFromObject(options) {
    const o = {
      type: TransactionType.appl,
      from: options.from,
      suggestedParams: options.suggestedParams,
      appIndex: options.appIndex,
      appOnComplete: options.onComplete,
      appLocalInts: options.numLocalInts,
      appLocalByteSlices: options.numLocalByteSlices,
      appGlobalInts: options.numGlobalInts,
      appGlobalByteSlices: options.numGlobalByteSlices,
      appApprovalProgram: options.approvalProgram,
      appClearProgram: options.clearProgram,
      appArgs: options.appArgs,
      appAccounts: options.accounts,
      appForeignApps: options.foreignApps,
      appForeignAssets: options.foreignAssets,
      note: options.note,
      lease: options.lease,
      reKeyTo: options.rekeyTo,
      extraPages: options.extraPages
    };
    return new Transaction(o);
  }
  var init_makeTxn = __esm({
    "node_modules/algosdk/dist/esm/src/makeTxn.js"() {
      init_transaction();
      init_base();
      init_transactions();
      init_base();
    }
  });

  // node_modules/algosdk/dist/esm/src/logicTemplates/limitorder.js
  var require_limitorder = __commonJS({
    "node_modules/algosdk/dist/esm/src/logicTemplates/limitorder.js"(exports2, module2) {
      var address = (init_address(), __toCommonJS(address_exports));
      var makeTxn = (init_makeTxn(), __toCommonJS(makeTxn_exports));
      var group = (init_group(), __toCommonJS(group_exports));
      var logic = (init_logic(), __toCommonJS(logic_exports));
      var logicSig = (init_logicsig(), __toCommonJS(logicsig_exports));
      var nacl2 = (init_naclWrappers(), __toCommonJS(naclWrappers_exports));
      var templates = require_templates();
      var utils = (init_utils(), __toCommonJS(utils_exports));
      var LimitOrder = class {
        constructor(owner, assetid, ratn, ratd, expiryRound, minTrade, maxFee) {
          if (!Number.isSafeInteger(assetid) || assetid < 0)
            throw Error("assetid must be a positive number and smaller than 2^53-1");
          if (!Number.isSafeInteger(ratn) || ratn < 0)
            throw Error("ratn must be a positive number and smaller than 2^53-1");
          if (!Number.isSafeInteger(ratd) || ratd < 0)
            throw Error("ratd must be a positive number and smaller than 2^53-1");
          if (!Number.isSafeInteger(expiryRound) || expiryRound < 0)
            throw Error("expiryRound must be a positive number and smaller than 2^53-1");
          if (!Number.isSafeInteger(minTrade) || minTrade < 0)
            throw Error("minTrade must be a positive number and smaller than 2^53-1");
          if (!Number.isSafeInteger(maxFee) || maxFee < 0)
            throw Error("maxFee must be a positive number and smaller than 2^53-1");
          const referenceProgramB64 = "ASAKAAEFAgYEBwgJCiYBIP68oLsUSlpOp7Q4pGgayA5soQW8tgf8VlMlyVaV9qITMRYiEjEQIxIQMQEkDhAyBCMSQABVMgQlEjEIIQQNEDEJMgMSEDMBECEFEhAzAREhBhIQMwEUKBIQMwETMgMSEDMBEiEHHTUCNQExCCEIHTUENQM0ATQDDUAAJDQBNAMSNAI0BA8QQAAWADEJKBIxAiEJDRAxBzIDEhAxCCISEBA=";
          const referenceProgramBytes = Buffer.from(referenceProgramB64, "base64");
          const referenceOffsets = [
            5,
            7,
            9,
            10,
            11,
            12,
            16
          ];
          const injectionVector = [
            maxFee,
            minTrade,
            assetid,
            ratd,
            ratn,
            expiryRound,
            owner
          ];
          const injectionTypes = [
            templates.valTypes.INT,
            templates.valTypes.INT,
            templates.valTypes.INT,
            templates.valTypes.INT,
            templates.valTypes.INT,
            templates.valTypes.INT,
            templates.valTypes.ADDRESS
          ];
          const injectedBytes = templates.inject(referenceProgramBytes, referenceOffsets, injectionVector, injectionTypes);
          this.programBytes = injectedBytes;
          const lsig = new logicSig.LogicSig(injectedBytes, void 0);
          this.address = lsig.address();
          this.owner = owner;
          this.assetid = assetid;
        }
        getProgram() {
          return this.programBytes;
        }
        getAddress() {
          return this.address;
        }
      };
      function getSwapAssetsTransaction(contract, assetAmount, microAlgoAmount, secretKey, fee, firstRound, lastRound, genesisHash) {
        const buyerKeyPair = nacl2.keyPairFromSecretKey(secretKey);
        const buyerAddr = address.encodeAddress(buyerKeyPair.publicKey);
        const programOutputs = logic.readProgram(contract, void 0);
        const ints = programOutputs[0];
        const byteArrays = programOutputs[1];
        let noCloseRemainder;
        let noAssetRevocationTarget;
        const contractAssetID = ints[6];
        const contractOwner = address.encodeAddress(byteArrays[0]);
        const lsig = logicSig.makeLogicSig(contract, void 0);
        const contractAddress = lsig.address();
        const algosForAssets = makeTxn.makePaymentTxn(contractAddress, buyerAddr, fee, microAlgoAmount, noCloseRemainder, firstRound, lastRound, void 0, genesisHash, void 0);
        const assetsForAlgos = makeTxn.makeAssetTransferTxn(buyerAddr, contractOwner, noCloseRemainder, noAssetRevocationTarget, fee, assetAmount, firstRound, lastRound, void 0, genesisHash, void 0, contractAssetID);
        const txns = [algosForAssets, assetsForAlgos];
        const txGroup = group.assignGroupID(txns);
        const ratd = ints[7];
        const ratn = ints[8];
        if (assetAmount * ratd < microAlgoAmount * ratn) {
          throw new Error(`bad payment ratio, ${assetAmount.toString()}*${ratd.toString()} !>= ${microAlgoAmount.toString()}*${ratn.toString()}`);
        }
        const minTrade = ints[4];
        if (microAlgoAmount < minTrade) {
          throw new Error(`payment amount ${microAlgoAmount.toString()} less than minimum trade ${minTrade.toString()}`);
        }
        const maxFee = ints[2];
        if (txGroup[0].fee > maxFee) {
          throw new Error(`final fee of payment transaction ${txGroup[0].fee.toString()} greater than transaction max fee ${maxFee.toString()}`);
        }
        if (txGroup[1].fee > maxFee) {
          throw new Error(`final fee of asset transaction ${txGroup[1].fee.toString()} greater than transaction max fee ${maxFee.toString()}`);
        }
        const algosForAssetsSigned = logicSig.signLogicSigTransactionObject(txGroup[0], lsig);
        const assetsForAlgosSigned = txGroup[1].signTxn(secretKey);
        return utils.concatArrays(algosForAssetsSigned.blob, assetsForAlgosSigned);
      }
      module2.exports = {
        LimitOrder,
        getSwapAssetsTransaction
      };
    }
  });

  // node_modules/algosdk/dist/esm/src/logicTemplates/split.js
  var require_split = __commonJS({
    "node_modules/algosdk/dist/esm/src/logicTemplates/split.js"(exports2, module2) {
      var address = (init_address(), __toCommonJS(address_exports));
      var makeTxn = (init_makeTxn(), __toCommonJS(makeTxn_exports));
      var group = (init_group(), __toCommonJS(group_exports));
      var logicsig = (init_logicsig(), __toCommonJS(logicsig_exports));
      var logic = (init_logic(), __toCommonJS(logic_exports));
      var templates = require_templates();
      var utils = (init_utils(), __toCommonJS(utils_exports));
      var Split = class {
        constructor(owner, receiverOne, receiverTwo, rat1, rat2, expiryRound, minPay, maxFee) {
          if (!Number.isSafeInteger(rat2) || rat2 < 0)
            throw Error("rat2 must be a positive number and smaller than 2^53-1");
          if (!Number.isSafeInteger(rat1) || rat1 < 0)
            throw Error("rat1 must be a positive number and smaller than 2^53-1");
          if (!Number.isSafeInteger(expiryRound) || expiryRound < 0)
            throw Error("expiryRound must be a positive number and smaller than 2^53-1");
          if (!Number.isSafeInteger(minPay) || minPay < 0)
            throw Error("minPay must be a positive number and smaller than 2^53-1");
          if (!Number.isSafeInteger(maxFee) || maxFee < 0)
            throw Error("maxFee must be a positive number and smaller than 2^53-1");
          const referenceProgramB64 = "ASAIAQUCAAYHCAkmAyCztwQn0+DycN+vsk+vJWcsoz/b7NDS6i33HOkvTpf+YiC3qUpIgHGWE8/1LPh9SGCalSN7IaITeeWSXbfsS5wsXyC4kBQ38Z8zcwWVAym4S8vpFB/c0XC6R4mnPi9EBADsPDEQIhIxASMMEDIEJBJAABkxCSgSMQcyAxIQMQglEhAxAiEEDRAiQAAuMwAAMwEAEjEJMgMSEDMABykSEDMBByoSEDMACCEFCzMBCCEGCxIQMwAIIQcPEBA=";
          const referenceProgramBytes = Buffer.from(referenceProgramB64, "base64");
          const referenceOffsets = [
            4,
            7,
            8,
            9,
            10,
            14,
            47,
            80
          ];
          const injectionVector = [
            maxFee,
            expiryRound,
            rat2,
            rat1,
            minPay,
            owner,
            receiverOne,
            receiverTwo
          ];
          const injectionTypes = [
            templates.valTypes.INT,
            templates.valTypes.INT,
            templates.valTypes.INT,
            templates.valTypes.INT,
            templates.valTypes.INT,
            templates.valTypes.ADDRESS,
            templates.valTypes.ADDRESS,
            templates.valTypes.ADDRESS
          ];
          const injectedBytes = templates.inject(referenceProgramBytes, referenceOffsets, injectionVector, injectionTypes);
          this.programBytes = injectedBytes;
          const lsig = logicsig.makeLogicSig(injectedBytes, void 0);
          this.address = lsig.address();
        }
        getProgram() {
          return this.programBytes;
        }
        getAddress() {
          return this.address;
        }
      };
      function getSplitFundsTransaction(contract, amount, firstRound, lastRound, fee, genesisHash) {
        const programOutputs = logic.readProgram(contract, void 0);
        const ints = programOutputs[0];
        const byteArrays = programOutputs[1];
        let rat2 = ints[6];
        let rat1 = ints[5];
        let amountForReceiverOne = 0;
        const gcdFn = (a, b) => {
          if (typeof a !== "number" || typeof b !== "number")
            throw new Error("gcd operates only on positive integers");
          if (!b) {
            return a;
          }
          return gcdFn(b, a % b);
        };
        const gcd = gcdFn(rat2, rat1);
        rat2 = Math.floor(rat2 / gcd);
        rat1 = Math.floor(rat1 / gcd);
        const ratio = rat1 / rat2;
        amountForReceiverOne = Math.round(amount / (1 + ratio));
        const amountForReceiverTwo = amount - amountForReceiverOne;
        if (rat1 * amountForReceiverOne !== rat2 * amountForReceiverTwo) {
          throw Error("could not split funds in a way that satisfied the contract ratio");
        }
        const logicSig = logicsig.makeLogicSig(contract, void 0);
        const from = logicSig.address();
        const receiverOne = address.encodeAddress(byteArrays[1]);
        const receiverTwo = address.encodeAddress(byteArrays[2]);
        const tx1 = makeTxn.makePaymentTxn(from, receiverOne, fee, amountForReceiverOne, void 0, firstRound, lastRound, void 0, genesisHash);
        const tx2 = makeTxn.makePaymentTxn(from, receiverTwo, fee, amountForReceiverTwo, void 0, firstRound, lastRound, void 0, genesisHash);
        const txns = [tx1, tx2];
        const txGroup = group.assignGroupID(txns);
        const signedTxns = txGroup.map((txn) => logicsig.signLogicSigTransactionObject(txn, logicsig).blob);
        return utils.concatArrays(signedTxns[0], signedTxns[1]);
      }
      module2.exports = {
        Split,
        getSplitFundsTransaction
      };
    }
  });

  // node_modules/algosdk/dist/esm/src/logicTemplates/periodicpayment.js
  var require_periodicpayment = __commonJS({
    "node_modules/algosdk/dist/esm/src/logicTemplates/periodicpayment.js"(exports2, module2) {
      var address = (init_address(), __toCommonJS(address_exports));
      var makeTxn = (init_makeTxn(), __toCommonJS(makeTxn_exports));
      var logic = (init_logic(), __toCommonJS(logic_exports));
      var logicSig = (init_logicsig(), __toCommonJS(logicsig_exports));
      var nacl2 = (init_naclWrappers(), __toCommonJS(naclWrappers_exports));
      var templates = require_templates();
      var PeriodicPayment = class {
        constructor(receiver, amount, withdrawalWindow, period, expiryRound, maxFee, lease) {
          this.receiver = receiver;
          if (!Number.isSafeInteger(amount) || amount < 0)
            throw Error("amount must be a positive number and smaller than 2^53-1");
          this.amount = amount;
          if (!Number.isSafeInteger(withdrawalWindow) || withdrawalWindow < 0)
            throw Error("withdrawalWindow must be a positive number and smaller than 2^53-1");
          this.withdrawalWindow = withdrawalWindow;
          if (!Number.isSafeInteger(period) || period < 0)
            throw Error("period must be a positive number and smaller than 2^53-1");
          this.period = period;
          if (!Number.isSafeInteger(expiryRound) || expiryRound < 0)
            throw Error("expiryRound must be a positive number and smaller than 2^53-1");
          this.expiryRound = expiryRound;
          if (!Number.isSafeInteger(maxFee) || maxFee < 0)
            throw Error("maxFee must be a positive number and smaller than 2^53-1");
          this.maxFee = maxFee;
          if (lease === void 0) {
            const leaseBytes = nacl2.randomBytes(32);
            this.lease = Buffer.from(leaseBytes).toString("base64");
          } else {
            this.lease = lease;
          }
          this.programBytes = this.getProgram();
          const lsig = new logicSig.LogicSig(this.programBytes, void 0);
          this.address = lsig.address();
        }
        getProgram() {
          const referenceProgramB64 = "ASAHAQYFAAQDByYCIAECAwQFBgcIAQIDBAUGBwgBAgMEBQYHCAECAwQFBgcIIJKvkYTkEzwJf2arzJOxERsSogG9nQzKPkpIoc4TzPTFMRAiEjEBIw4QMQIkGCUSEDEEIQQxAggSEDEGKBIQMQkyAxIxBykSEDEIIQUSEDEJKRIxBzIDEhAxAiEGDRAxCCUSEBEQ";
          const referenceProgramBytes = Buffer.from(referenceProgramB64, "base64");
          const referenceOffsets = [
            4,
            5,
            7,
            8,
            9,
            12,
            46
          ];
          const injectionVector = [
            this.maxFee,
            this.period,
            this.withdrawalWindow,
            this.amount,
            this.expiryRound,
            this.lease,
            this.receiver
          ];
          const injectionTypes = [
            templates.valTypes.INT,
            templates.valTypes.INT,
            templates.valTypes.INT,
            templates.valTypes.INT,
            templates.valTypes.INT,
            templates.valTypes.BASE64,
            templates.valTypes.ADDRESS
          ];
          return templates.inject(referenceProgramBytes, referenceOffsets, injectionVector, injectionTypes);
        }
        getAddress() {
          return this.address;
        }
      };
      function getPeriodicPaymentWithdrawalTransaction(contract, fee, firstValid, genesisHash) {
        const readResult = logic.readProgram(contract, void 0);
        const ints = readResult[0];
        const byteArrays = readResult[1];
        const period = ints[2];
        const duration = ints[4];
        const amount = ints[5];
        if (firstValid % period !== 0) {
          throw new Error(`firstValid round ${firstValid.toString()} was not a multiple of contract period ${period.toString()}`);
        }
        const receiverBytes = byteArrays[1];
        const receiver = address.encodeAddress(receiverBytes);
        const leaseBuffer = byteArrays[0];
        const lease = new Uint8Array(leaseBuffer);
        const lastValid = firstValid + duration;
        const to = receiver;
        let noCloseRemainder;
        let noNote;
        const lsig = logicSig.makeLogicSig(contract, void 0);
        const from = lsig.address();
        const txn = {
          from,
          to,
          fee,
          amount,
          closeRemainderTo: noCloseRemainder,
          firstRound: firstValid,
          lastRound: lastValid,
          note: noNote,
          genesisHash,
          genesisID: "",
          type: "pay",
          lease
        };
        const tempTxn = makeTxn.makePaymentTxn(from, to, fee, amount, noCloseRemainder, firstValid, lastValid, noNote, genesisHash, "");
        if (tempTxn.fee > ints[1]) {
          throw new Error(`final fee of payment transaction${tempTxn.fee.toString()}greater than transaction max fee${ints[1].toString()}`);
        }
        return logicSig.signLogicSigTransaction(txn, lsig);
      }
      module2.exports = {
        PeriodicPayment,
        getPeriodicPaymentWithdrawalTransaction
      };
    }
  });

  // node_modules/algosdk/dist/esm/src/logicTemplates/index.js
  var require_logicTemplates = __commonJS({
    "node_modules/algosdk/dist/esm/src/logicTemplates/index.js"(exports2, module2) {
      var dynamicFeeTemplate = require_dynamicfee();
      var htlcTemplate = require_htlc();
      var limitOrderTemplate = require_limitorder();
      var splitTemplate = require_split();
      var periodicPayTemplate = require_periodicpayment();
      module2.exports = {
        DynamicFee: dynamicFeeTemplate.DynamicFee,
        getDynamicFeeTransactions: dynamicFeeTemplate.getDynamicFeeTransactions,
        signDynamicFee: dynamicFeeTemplate.signDynamicFee,
        HTLC: htlcTemplate.HTLC,
        signTransactionWithHTLCUnlock: htlcTemplate.signTransactionWithHTLCUnlock,
        LimitOrder: limitOrderTemplate.LimitOrder,
        getSwapAssetsTransaction: limitOrderTemplate.getSwapAssetsTransaction,
        Split: splitTemplate.Split,
        getSplitFundsTransaction: splitTemplate.getSplitFundsTransaction,
        PeriodicPayment: periodicPayTemplate.PeriodicPayment,
        getPeriodicPaymentWithdrawalTransaction: periodicPayTemplate.getPeriodicPaymentWithdrawalTransaction
      };
    }
  });

  // node_modules/requires-port/index.js
  var require_requires_port = __commonJS({
    "node_modules/requires-port/index.js"(exports2, module2) {
      "use strict";
      module2.exports = function required(port, protocol) {
        protocol = protocol.split(":")[0];
        port = +port;
        if (!port)
          return false;
        switch (protocol) {
          case "http":
          case "ws":
            return port !== 80;
          case "https":
          case "wss":
            return port !== 443;
          case "ftp":
            return port !== 21;
          case "gopher":
            return port !== 70;
          case "file":
            return false;
        }
        return port !== 0;
      };
    }
  });

  // node_modules/querystringify/index.js
  var require_querystringify = __commonJS({
    "node_modules/querystringify/index.js"(exports2) {
      "use strict";
      var has = Object.prototype.hasOwnProperty;
      var undef;
      function decode3(input) {
        try {
          return decodeURIComponent(input.replace(/\+/g, " "));
        } catch (e) {
          return null;
        }
      }
      function encode3(input) {
        try {
          return encodeURIComponent(input);
        } catch (e) {
          return null;
        }
      }
      function querystring(query) {
        var parser = /([^=?#&]+)=?([^&]*)/g, result = {}, part;
        while (part = parser.exec(query)) {
          var key = decode3(part[1]), value = decode3(part[2]);
          if (key === null || value === null || key in result)
            continue;
          result[key] = value;
        }
        return result;
      }
      function querystringify(obj, prefix) {
        prefix = prefix || "";
        var pairs = [], value, key;
        if (typeof prefix !== "string")
          prefix = "?";
        for (key in obj) {
          if (has.call(obj, key)) {
            value = obj[key];
            if (!value && (value === null || value === undef || isNaN(value))) {
              value = "";
            }
            key = encode3(key);
            value = encode3(value);
            if (key === null || value === null)
              continue;
            pairs.push(key + "=" + value);
          }
        }
        return pairs.length ? prefix + pairs.join("&") : "";
      }
      exports2.stringify = querystringify;
      exports2.parse = querystring;
    }
  });

  // node_modules/url-parse/index.js
  var require_url_parse = __commonJS({
    "node_modules/url-parse/index.js"(exports2, module2) {
      "use strict";
      var required = require_requires_port();
      var qs = require_querystringify();
      var controlOrWhitespace = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/;
      var CRHTLF = /[\n\r\t]/g;
      var slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//;
      var port = /:\d+$/;
      var protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\\/]+)?([\S\s]*)/i;
      var windowsDriveLetter = /^[a-zA-Z]:/;
      function trimLeft(str) {
        return (str ? str : "").toString().replace(controlOrWhitespace, "");
      }
      var rules = [
        ["#", "hash"],
        ["?", "query"],
        function sanitize(address, url) {
          return isSpecial(url.protocol) ? address.replace(/\\/g, "/") : address;
        },
        ["/", "pathname"],
        ["@", "auth", 1],
        [NaN, "host", void 0, 1, 1],
        [/:(\d*)$/, "port", void 0, 1],
        [NaN, "hostname", void 0, 1, 1]
      ];
      var ignore = { hash: 1, query: 1 };
      function lolcation(loc) {
        var globalVar;
        if (typeof window !== "undefined")
          globalVar = window;
        else if (typeof global !== "undefined")
          globalVar = global;
        else if (typeof self !== "undefined")
          globalVar = self;
        else
          globalVar = {};
        var location = globalVar.location || {};
        loc = loc || location;
        var finaldestination = {}, type = typeof loc, key;
        if (loc.protocol === "blob:") {
          finaldestination = new Url2(unescape(loc.pathname), {});
        } else if (type === "string") {
          finaldestination = new Url2(loc, {});
          for (key in ignore)
            delete finaldestination[key];
        } else if (type === "object") {
          for (key in loc) {
            if (key in ignore)
              continue;
            finaldestination[key] = loc[key];
          }
          if (finaldestination.slashes === void 0) {
            finaldestination.slashes = slashes.test(loc.href);
          }
        }
        return finaldestination;
      }
      function isSpecial(scheme) {
        return scheme === "file:" || scheme === "ftp:" || scheme === "http:" || scheme === "https:" || scheme === "ws:" || scheme === "wss:";
      }
      function extractProtocol(address, location) {
        address = trimLeft(address);
        address = address.replace(CRHTLF, "");
        location = location || {};
        var match = protocolre.exec(address);
        var protocol = match[1] ? match[1].toLowerCase() : "";
        var forwardSlashes = !!match[2];
        var otherSlashes = !!match[3];
        var slashesCount = 0;
        var rest;
        if (forwardSlashes) {
          if (otherSlashes) {
            rest = match[2] + match[3] + match[4];
            slashesCount = match[2].length + match[3].length;
          } else {
            rest = match[2] + match[4];
            slashesCount = match[2].length;
          }
        } else {
          if (otherSlashes) {
            rest = match[3] + match[4];
            slashesCount = match[3].length;
          } else {
            rest = match[4];
          }
        }
        if (protocol === "file:") {
          if (slashesCount >= 2) {
            rest = rest.slice(2);
          }
        } else if (isSpecial(protocol)) {
          rest = match[4];
        } else if (protocol) {
          if (forwardSlashes) {
            rest = rest.slice(2);
          }
        } else if (slashesCount >= 2 && isSpecial(location.protocol)) {
          rest = match[4];
        }
        return {
          protocol,
          slashes: forwardSlashes || isSpecial(protocol),
          slashesCount,
          rest
        };
      }
      function resolve(relative, base) {
        if (relative === "")
          return base;
        var path2 = (base || "/").split("/").slice(0, -1).concat(relative.split("/")), i = path2.length, last = path2[i - 1], unshift = false, up = 0;
        while (i--) {
          if (path2[i] === ".") {
            path2.splice(i, 1);
          } else if (path2[i] === "..") {
            path2.splice(i, 1);
            up++;
          } else if (up) {
            if (i === 0)
              unshift = true;
            path2.splice(i, 1);
            up--;
          }
        }
        if (unshift)
          path2.unshift("");
        if (last === "." || last === "..")
          path2.push("");
        return path2.join("/");
      }
      function Url2(address, location, parser) {
        address = trimLeft(address);
        address = address.replace(CRHTLF, "");
        if (!(this instanceof Url2)) {
          return new Url2(address, location, parser);
        }
        var relative, extracted, parse, instruction, index, key, instructions = rules.slice(), type = typeof location, url = this, i = 0;
        if (type !== "object" && type !== "string") {
          parser = location;
          location = null;
        }
        if (parser && typeof parser !== "function")
          parser = qs.parse;
        location = lolcation(location);
        extracted = extractProtocol(address || "", location);
        relative = !extracted.protocol && !extracted.slashes;
        url.slashes = extracted.slashes || relative && location.slashes;
        url.protocol = extracted.protocol || location.protocol || "";
        address = extracted.rest;
        if (extracted.protocol === "file:" && (extracted.slashesCount !== 2 || windowsDriveLetter.test(address)) || !extracted.slashes && (extracted.protocol || extracted.slashesCount < 2 || !isSpecial(url.protocol))) {
          instructions[3] = [/(.*)/, "pathname"];
        }
        for (; i < instructions.length; i++) {
          instruction = instructions[i];
          if (typeof instruction === "function") {
            address = instruction(address, url);
            continue;
          }
          parse = instruction[0];
          key = instruction[1];
          if (parse !== parse) {
            url[key] = address;
          } else if (typeof parse === "string") {
            index = parse === "@" ? address.lastIndexOf(parse) : address.indexOf(parse);
            if (~index) {
              if (typeof instruction[2] === "number") {
                url[key] = address.slice(0, index);
                address = address.slice(index + instruction[2]);
              } else {
                url[key] = address.slice(index);
                address = address.slice(0, index);
              }
            }
          } else if (index = parse.exec(address)) {
            url[key] = index[1];
            address = address.slice(0, index.index);
          }
          url[key] = url[key] || (relative && instruction[3] ? location[key] || "" : "");
          if (instruction[4])
            url[key] = url[key].toLowerCase();
        }
        if (parser)
          url.query = parser(url.query);
        if (relative && location.slashes && url.pathname.charAt(0) !== "/" && (url.pathname !== "" || location.pathname !== "")) {
          url.pathname = resolve(url.pathname, location.pathname);
        }
        if (url.pathname.charAt(0) !== "/" && isSpecial(url.protocol)) {
          url.pathname = "/" + url.pathname;
        }
        if (!required(url.port, url.protocol)) {
          url.host = url.hostname;
          url.port = "";
        }
        url.username = url.password = "";
        if (url.auth) {
          index = url.auth.indexOf(":");
          if (~index) {
            url.username = url.auth.slice(0, index);
            url.username = encodeURIComponent(decodeURIComponent(url.username));
            url.password = url.auth.slice(index + 1);
            url.password = encodeURIComponent(decodeURIComponent(url.password));
          } else {
            url.username = encodeURIComponent(decodeURIComponent(url.auth));
          }
          url.auth = url.password ? url.username + ":" + url.password : url.username;
        }
        url.origin = url.protocol !== "file:" && isSpecial(url.protocol) && url.host ? url.protocol + "//" + url.host : "null";
        url.href = url.toString();
      }
      function set(part, value, fn) {
        var url = this;
        switch (part) {
          case "query":
            if (typeof value === "string" && value.length) {
              value = (fn || qs.parse)(value);
            }
            url[part] = value;
            break;
          case "port":
            url[part] = value;
            if (!required(value, url.protocol)) {
              url.host = url.hostname;
              url[part] = "";
            } else if (value) {
              url.host = url.hostname + ":" + value;
            }
            break;
          case "hostname":
            url[part] = value;
            if (url.port)
              value += ":" + url.port;
            url.host = value;
            break;
          case "host":
            url[part] = value;
            if (port.test(value)) {
              value = value.split(":");
              url.port = value.pop();
              url.hostname = value.join(":");
            } else {
              url.hostname = value;
              url.port = "";
            }
            break;
          case "protocol":
            url.protocol = value.toLowerCase();
            url.slashes = !fn;
            break;
          case "pathname":
          case "hash":
            if (value) {
              var char = part === "pathname" ? "/" : "#";
              url[part] = value.charAt(0) !== char ? char + value : value;
            } else {
              url[part] = value;
            }
            break;
          case "username":
          case "password":
            url[part] = encodeURIComponent(value);
            break;
          case "auth":
            var index = value.indexOf(":");
            if (~index) {
              url.username = value.slice(0, index);
              url.username = encodeURIComponent(decodeURIComponent(url.username));
              url.password = value.slice(index + 1);
              url.password = encodeURIComponent(decodeURIComponent(url.password));
            } else {
              url.username = encodeURIComponent(decodeURIComponent(value));
            }
        }
        for (var i = 0; i < rules.length; i++) {
          var ins = rules[i];
          if (ins[4])
            url[ins[1]] = url[ins[1]].toLowerCase();
        }
        url.auth = url.password ? url.username + ":" + url.password : url.username;
        url.origin = url.protocol !== "file:" && isSpecial(url.protocol) && url.host ? url.protocol + "//" + url.host : "null";
        url.href = url.toString();
        return url;
      }
      function toString(stringify) {
        if (!stringify || typeof stringify !== "function")
          stringify = qs.stringify;
        var query, url = this, host = url.host, protocol = url.protocol;
        if (protocol && protocol.charAt(protocol.length - 1) !== ":")
          protocol += ":";
        var result = protocol + (url.protocol && url.slashes || isSpecial(url.protocol) ? "//" : "");
        if (url.username) {
          result += url.username;
          if (url.password)
            result += ":" + url.password;
          result += "@";
        } else if (url.password) {
          result += ":" + url.password;
          result += "@";
        } else if (url.protocol !== "file:" && isSpecial(url.protocol) && !host && url.pathname !== "/") {
          result += "@";
        }
        if (host[host.length - 1] === ":" || port.test(url.hostname) && !url.port) {
          host += ":";
        }
        result += host + url.pathname;
        query = typeof url.query === "object" ? stringify(url.query) : url.query;
        if (query)
          result += query.charAt(0) !== "?" ? "?" + query : query;
        if (url.hash)
          result += url.hash;
        return result;
      }
      Url2.prototype = { set, toString };
      Url2.extractProtocol = extractProtocol;
      Url2.location = lolcation;
      Url2.trimLeft = trimLeft;
      Url2.qs = qs;
      module2.exports = Url2;
    }
  });

  // node_modules/has-symbols/shams.js
  var require_shams = __commonJS({
    "node_modules/has-symbols/shams.js"(exports2, module2) {
      "use strict";
      module2.exports = function hasSymbols() {
        if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
          return false;
        }
        if (typeof Symbol.iterator === "symbol") {
          return true;
        }
        var obj = {};
        var sym = Symbol("test");
        var symObj = Object(sym);
        if (typeof sym === "string") {
          return false;
        }
        if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
          return false;
        }
        if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
          return false;
        }
        var symVal = 42;
        obj[sym] = symVal;
        for (sym in obj) {
          return false;
        }
        if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
          return false;
        }
        if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
          return false;
        }
        var syms = Object.getOwnPropertySymbols(obj);
        if (syms.length !== 1 || syms[0] !== sym) {
          return false;
        }
        if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
          return false;
        }
        if (typeof Object.getOwnPropertyDescriptor === "function") {
          var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
          if (descriptor.value !== symVal || descriptor.enumerable !== true) {
            return false;
          }
        }
        return true;
      };
    }
  });

  // node_modules/has-symbols/index.js
  var require_has_symbols = __commonJS({
    "node_modules/has-symbols/index.js"(exports2, module2) {
      "use strict";
      var origSymbol = typeof Symbol !== "undefined" && Symbol;
      var hasSymbolSham = require_shams();
      module2.exports = function hasNativeSymbols() {
        if (typeof origSymbol !== "function") {
          return false;
        }
        if (typeof Symbol !== "function") {
          return false;
        }
        if (typeof origSymbol("foo") !== "symbol") {
          return false;
        }
        if (typeof Symbol("bar") !== "symbol") {
          return false;
        }
        return hasSymbolSham();
      };
    }
  });

  // node_modules/function-bind/implementation.js
  var require_implementation = __commonJS({
    "node_modules/function-bind/implementation.js"(exports2, module2) {
      "use strict";
      var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
      var slice = Array.prototype.slice;
      var toStr = Object.prototype.toString;
      var funcType = "[object Function]";
      module2.exports = function bind(that) {
        var target = this;
        if (typeof target !== "function" || toStr.call(target) !== funcType) {
          throw new TypeError(ERROR_MESSAGE + target);
        }
        var args = slice.call(arguments, 1);
        var bound;
        var binder = function() {
          if (this instanceof bound) {
            var result = target.apply(this, args.concat(slice.call(arguments)));
            if (Object(result) === result) {
              return result;
            }
            return this;
          } else {
            return target.apply(that, args.concat(slice.call(arguments)));
          }
        };
        var boundLength = Math.max(0, target.length - args.length);
        var boundArgs = [];
        for (var i = 0; i < boundLength; i++) {
          boundArgs.push("$" + i);
        }
        bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
        if (target.prototype) {
          var Empty = function Empty2() {
          };
          Empty.prototype = target.prototype;
          bound.prototype = new Empty();
          Empty.prototype = null;
        }
        return bound;
      };
    }
  });

  // node_modules/function-bind/index.js
  var require_function_bind = __commonJS({
    "node_modules/function-bind/index.js"(exports2, module2) {
      "use strict";
      var implementation = require_implementation();
      module2.exports = Function.prototype.bind || implementation;
    }
  });

  // node_modules/has/src/index.js
  var require_src = __commonJS({
    "node_modules/has/src/index.js"(exports2, module2) {
      "use strict";
      var bind = require_function_bind();
      module2.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
    }
  });

  // node_modules/get-intrinsic/index.js
  var require_get_intrinsic = __commonJS({
    "node_modules/get-intrinsic/index.js"(exports2, module2) {
      "use strict";
      var undefined2;
      var $SyntaxError = SyntaxError;
      var $Function = Function;
      var $TypeError = TypeError;
      var getEvalledConstructor = function(expressionSyntax) {
        try {
          return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
        } catch (e) {
        }
      };
      var $gOPD = Object.getOwnPropertyDescriptor;
      if ($gOPD) {
        try {
          $gOPD({}, "");
        } catch (e) {
          $gOPD = null;
        }
      }
      var throwTypeError = function() {
        throw new $TypeError();
      };
      var ThrowTypeError = $gOPD ? function() {
        try {
          arguments.callee;
          return throwTypeError;
        } catch (calleeThrows) {
          try {
            return $gOPD(arguments, "callee").get;
          } catch (gOPDthrows) {
            return throwTypeError;
          }
        }
      }() : throwTypeError;
      var hasSymbols = require_has_symbols()();
      var getProto = Object.getPrototypeOf || function(x) {
        return x.__proto__;
      };
      var needsEval = {};
      var TypedArray = typeof Uint8Array === "undefined" ? undefined2 : getProto(Uint8Array);
      var INTRINSICS = {
        "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
        "%Array%": Array,
        "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
        "%ArrayIteratorPrototype%": hasSymbols ? getProto([][Symbol.iterator]()) : undefined2,
        "%AsyncFromSyncIteratorPrototype%": undefined2,
        "%AsyncFunction%": needsEval,
        "%AsyncGenerator%": needsEval,
        "%AsyncGeneratorFunction%": needsEval,
        "%AsyncIteratorPrototype%": needsEval,
        "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
        "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
        "%Boolean%": Boolean,
        "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
        "%Date%": Date,
        "%decodeURI%": decodeURI,
        "%decodeURIComponent%": decodeURIComponent,
        "%encodeURI%": encodeURI,
        "%encodeURIComponent%": encodeURIComponent,
        "%Error%": Error,
        "%eval%": eval,
        "%EvalError%": EvalError,
        "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
        "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
        "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
        "%Function%": $Function,
        "%GeneratorFunction%": needsEval,
        "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
        "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
        "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
        "%isFinite%": isFinite,
        "%isNaN%": isNaN,
        "%IteratorPrototype%": hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined2,
        "%JSON%": typeof JSON === "object" ? JSON : undefined2,
        "%Map%": typeof Map === "undefined" ? undefined2 : Map,
        "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
        "%Math%": Math,
        "%Number%": Number,
        "%Object%": Object,
        "%parseFloat%": parseFloat,
        "%parseInt%": parseInt,
        "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
        "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
        "%RangeError%": RangeError,
        "%ReferenceError%": ReferenceError,
        "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
        "%RegExp%": RegExp,
        "%Set%": typeof Set === "undefined" ? undefined2 : Set,
        "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
        "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
        "%String%": String,
        "%StringIteratorPrototype%": hasSymbols ? getProto(""[Symbol.iterator]()) : undefined2,
        "%Symbol%": hasSymbols ? Symbol : undefined2,
        "%SyntaxError%": $SyntaxError,
        "%ThrowTypeError%": ThrowTypeError,
        "%TypedArray%": TypedArray,
        "%TypeError%": $TypeError,
        "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
        "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
        "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
        "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
        "%URIError%": URIError,
        "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
        "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
        "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
      };
      var doEval = function doEval2(name) {
        var value;
        if (name === "%AsyncFunction%") {
          value = getEvalledConstructor("async function () {}");
        } else if (name === "%GeneratorFunction%") {
          value = getEvalledConstructor("function* () {}");
        } else if (name === "%AsyncGeneratorFunction%") {
          value = getEvalledConstructor("async function* () {}");
        } else if (name === "%AsyncGenerator%") {
          var fn = doEval2("%AsyncGeneratorFunction%");
          if (fn) {
            value = fn.prototype;
          }
        } else if (name === "%AsyncIteratorPrototype%") {
          var gen = doEval2("%AsyncGenerator%");
          if (gen) {
            value = getProto(gen.prototype);
          }
        }
        INTRINSICS[name] = value;
        return value;
      };
      var LEGACY_ALIASES = {
        "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
        "%ArrayPrototype%": ["Array", "prototype"],
        "%ArrayProto_entries%": ["Array", "prototype", "entries"],
        "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
        "%ArrayProto_keys%": ["Array", "prototype", "keys"],
        "%ArrayProto_values%": ["Array", "prototype", "values"],
        "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
        "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
        "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
        "%BooleanPrototype%": ["Boolean", "prototype"],
        "%DataViewPrototype%": ["DataView", "prototype"],
        "%DatePrototype%": ["Date", "prototype"],
        "%ErrorPrototype%": ["Error", "prototype"],
        "%EvalErrorPrototype%": ["EvalError", "prototype"],
        "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
        "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
        "%FunctionPrototype%": ["Function", "prototype"],
        "%Generator%": ["GeneratorFunction", "prototype"],
        "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
        "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
        "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
        "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
        "%JSONParse%": ["JSON", "parse"],
        "%JSONStringify%": ["JSON", "stringify"],
        "%MapPrototype%": ["Map", "prototype"],
        "%NumberPrototype%": ["Number", "prototype"],
        "%ObjectPrototype%": ["Object", "prototype"],
        "%ObjProto_toString%": ["Object", "prototype", "toString"],
        "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
        "%PromisePrototype%": ["Promise", "prototype"],
        "%PromiseProto_then%": ["Promise", "prototype", "then"],
        "%Promise_all%": ["Promise", "all"],
        "%Promise_reject%": ["Promise", "reject"],
        "%Promise_resolve%": ["Promise", "resolve"],
        "%RangeErrorPrototype%": ["RangeError", "prototype"],
        "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
        "%RegExpPrototype%": ["RegExp", "prototype"],
        "%SetPrototype%": ["Set", "prototype"],
        "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
        "%StringPrototype%": ["String", "prototype"],
        "%SymbolPrototype%": ["Symbol", "prototype"],
        "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
        "%TypedArrayPrototype%": ["TypedArray", "prototype"],
        "%TypeErrorPrototype%": ["TypeError", "prototype"],
        "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
        "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
        "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
        "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
        "%URIErrorPrototype%": ["URIError", "prototype"],
        "%WeakMapPrototype%": ["WeakMap", "prototype"],
        "%WeakSetPrototype%": ["WeakSet", "prototype"]
      };
      var bind = require_function_bind();
      var hasOwn = require_src();
      var $concat = bind.call(Function.call, Array.prototype.concat);
      var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
      var $replace = bind.call(Function.call, String.prototype.replace);
      var $strSlice = bind.call(Function.call, String.prototype.slice);
      var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
      var reEscapeChar = /\\(\\)?/g;
      var stringToPath = function stringToPath2(string) {
        var first = $strSlice(string, 0, 1);
        var last = $strSlice(string, -1);
        if (first === "%" && last !== "%") {
          throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
        } else if (last === "%" && first !== "%") {
          throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
        }
        var result = [];
        $replace(string, rePropName, function(match, number, quote, subString) {
          result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
        });
        return result;
      };
      var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
        var intrinsicName = name;
        var alias;
        if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
          alias = LEGACY_ALIASES[intrinsicName];
          intrinsicName = "%" + alias[0] + "%";
        }
        if (hasOwn(INTRINSICS, intrinsicName)) {
          var value = INTRINSICS[intrinsicName];
          if (value === needsEval) {
            value = doEval(intrinsicName);
          }
          if (typeof value === "undefined" && !allowMissing) {
            throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
          }
          return {
            alias,
            name: intrinsicName,
            value
          };
        }
        throw new $SyntaxError("intrinsic " + name + " does not exist!");
      };
      module2.exports = function GetIntrinsic(name, allowMissing) {
        if (typeof name !== "string" || name.length === 0) {
          throw new $TypeError("intrinsic name must be a non-empty string");
        }
        if (arguments.length > 1 && typeof allowMissing !== "boolean") {
          throw new $TypeError('"allowMissing" argument must be a boolean');
        }
        var parts = stringToPath(name);
        var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
        var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
        var intrinsicRealName = intrinsic.name;
        var value = intrinsic.value;
        var skipFurtherCaching = false;
        var alias = intrinsic.alias;
        if (alias) {
          intrinsicBaseName = alias[0];
          $spliceApply(parts, $concat([0, 1], alias));
        }
        for (var i = 1, isOwn = true; i < parts.length; i += 1) {
          var part = parts[i];
          var first = $strSlice(part, 0, 1);
          var last = $strSlice(part, -1);
          if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
            throw new $SyntaxError("property names with quotes must have matching quotes");
          }
          if (part === "constructor" || !isOwn) {
            skipFurtherCaching = true;
          }
          intrinsicBaseName += "." + part;
          intrinsicRealName = "%" + intrinsicBaseName + "%";
          if (hasOwn(INTRINSICS, intrinsicRealName)) {
            value = INTRINSICS[intrinsicRealName];
          } else if (value != null) {
            if (!(part in value)) {
              if (!allowMissing) {
                throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
              }
              return void 0;
            }
            if ($gOPD && i + 1 >= parts.length) {
              var desc = $gOPD(value, part);
              isOwn = !!desc;
              if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
                value = desc.get;
              } else {
                value = value[part];
              }
            } else {
              isOwn = hasOwn(value, part);
              value = value[part];
            }
            if (isOwn && !skipFurtherCaching) {
              INTRINSICS[intrinsicRealName] = value;
            }
          }
        }
        return value;
      };
    }
  });

  // node_modules/call-bind/index.js
  var require_call_bind = __commonJS({
    "node_modules/call-bind/index.js"(exports2, module2) {
      "use strict";
      var bind = require_function_bind();
      var GetIntrinsic = require_get_intrinsic();
      var $apply = GetIntrinsic("%Function.prototype.apply%");
      var $call = GetIntrinsic("%Function.prototype.call%");
      var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
      var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
      var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
      var $max = GetIntrinsic("%Math.max%");
      if ($defineProperty) {
        try {
          $defineProperty({}, "a", { value: 1 });
        } catch (e) {
          $defineProperty = null;
        }
      }
      module2.exports = function callBind(originalFunction) {
        var func = $reflectApply(bind, $call, arguments);
        if ($gOPD && $defineProperty) {
          var desc = $gOPD(func, "length");
          if (desc.configurable) {
            $defineProperty(func, "length", { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) });
          }
        }
        return func;
      };
      var applyBind = function applyBind2() {
        return $reflectApply(bind, $apply, arguments);
      };
      if ($defineProperty) {
        $defineProperty(module2.exports, "apply", { value: applyBind });
      } else {
        module2.exports.apply = applyBind;
      }
    }
  });

  // node_modules/call-bind/callBound.js
  var require_callBound = __commonJS({
    "node_modules/call-bind/callBound.js"(exports2, module2) {
      "use strict";
      var GetIntrinsic = require_get_intrinsic();
      var callBind = require_call_bind();
      var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
      module2.exports = function callBoundIntrinsic(name, allowMissing) {
        var intrinsic = GetIntrinsic(name, !!allowMissing);
        if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
          return callBind(intrinsic);
        }
        return intrinsic;
      };
    }
  });

  // node_modules/object-inspect/util.inspect.js
  var require_util_inspect = __commonJS({
    "node_modules/object-inspect/util.inspect.js"(exports2, module2) {
      module2.exports = __require("util").inspect;
    }
  });

  // node_modules/object-inspect/index.js
  var require_object_inspect = __commonJS({
    "node_modules/object-inspect/index.js"(exports2, module2) {
      var hasMap = typeof Map === "function" && Map.prototype;
      var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
      var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
      var mapForEach = hasMap && Map.prototype.forEach;
      var hasSet = typeof Set === "function" && Set.prototype;
      var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
      var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
      var setForEach = hasSet && Set.prototype.forEach;
      var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
      var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
      var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
      var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
      var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
      var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
      var booleanValueOf = Boolean.prototype.valueOf;
      var objectToString = Object.prototype.toString;
      var functionToString = Function.prototype.toString;
      var $match = String.prototype.match;
      var $slice = String.prototype.slice;
      var $replace = String.prototype.replace;
      var $toUpperCase = String.prototype.toUpperCase;
      var $toLowerCase = String.prototype.toLowerCase;
      var $test = RegExp.prototype.test;
      var $concat = Array.prototype.concat;
      var $join = Array.prototype.join;
      var $arrSlice = Array.prototype.slice;
      var $floor = Math.floor;
      var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
      var gOPS = Object.getOwnPropertySymbols;
      var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
      var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
      var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
      var isEnumerable = Object.prototype.propertyIsEnumerable;
      var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
        return O.__proto__;
      } : null);
      function addNumericSeparator(num, str) {
        if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
          return str;
        }
        var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
        if (typeof num === "number") {
          var int = num < 0 ? -$floor(-num) : $floor(num);
          if (int !== num) {
            var intStr = String(int);
            var dec = $slice.call(str, intStr.length + 1);
            return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
          }
        }
        return $replace.call(str, sepRegex, "$&_");
      }
      var inspectCustom = require_util_inspect().custom;
      var inspectSymbol = inspectCustom && isSymbol(inspectCustom) ? inspectCustom : null;
      module2.exports = function inspect_(obj, options, depth, seen) {
        var opts = options || {};
        if (has(opts, "quoteStyle") && (opts.quoteStyle !== "single" && opts.quoteStyle !== "double")) {
          throw new TypeError('option "quoteStyle" must be "single" or "double"');
        }
        if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
          throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
        }
        var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
        if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
          throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
        }
        if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
          throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
        }
        if (has(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
          throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
        }
        var numericSeparator = opts.numericSeparator;
        if (typeof obj === "undefined") {
          return "undefined";
        }
        if (obj === null) {
          return "null";
        }
        if (typeof obj === "boolean") {
          return obj ? "true" : "false";
        }
        if (typeof obj === "string") {
          return inspectString(obj, opts);
        }
        if (typeof obj === "number") {
          if (obj === 0) {
            return Infinity / obj > 0 ? "0" : "-0";
          }
          var str = String(obj);
          return numericSeparator ? addNumericSeparator(obj, str) : str;
        }
        if (typeof obj === "bigint") {
          var bigIntStr = String(obj) + "n";
          return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
        }
        var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
        if (typeof depth === "undefined") {
          depth = 0;
        }
        if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
          return isArray(obj) ? "[Array]" : "[Object]";
        }
        var indent = getIndent(opts, depth);
        if (typeof seen === "undefined") {
          seen = [];
        } else if (indexOf(seen, obj) >= 0) {
          return "[Circular]";
        }
        function inspect(value, from, noIndent) {
          if (from) {
            seen = $arrSlice.call(seen);
            seen.push(from);
          }
          if (noIndent) {
            var newOpts = {
              depth: opts.depth
            };
            if (has(opts, "quoteStyle")) {
              newOpts.quoteStyle = opts.quoteStyle;
            }
            return inspect_(value, newOpts, depth + 1, seen);
          }
          return inspect_(value, opts, depth + 1, seen);
        }
        if (typeof obj === "function") {
          var name = nameOf(obj);
          var keys = arrObjKeys(obj, inspect);
          return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys.length > 0 ? " { " + $join.call(keys, ", ") + " }" : "");
        }
        if (isSymbol(obj)) {
          var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
          return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
        }
        if (isElement(obj)) {
          var s = "<" + $toLowerCase.call(String(obj.nodeName));
          var attrs = obj.attributes || [];
          for (var i = 0; i < attrs.length; i++) {
            s += " " + attrs[i].name + "=" + wrapQuotes(quote(attrs[i].value), "double", opts);
          }
          s += ">";
          if (obj.childNodes && obj.childNodes.length) {
            s += "...";
          }
          s += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
          return s;
        }
        if (isArray(obj)) {
          if (obj.length === 0) {
            return "[]";
          }
          var xs = arrObjKeys(obj, inspect);
          if (indent && !singleLineValues(xs)) {
            return "[" + indentedJoin(xs, indent) + "]";
          }
          return "[ " + $join.call(xs, ", ") + " ]";
        }
        if (isError(obj)) {
          var parts = arrObjKeys(obj, inspect);
          if ("cause" in obj && !isEnumerable.call(obj, "cause")) {
            return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect(obj.cause), parts), ", ") + " }";
          }
          if (parts.length === 0) {
            return "[" + String(obj) + "]";
          }
          return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
        }
        if (typeof obj === "object" && customInspect) {
          if (inspectSymbol && typeof obj[inspectSymbol] === "function") {
            return obj[inspectSymbol]();
          } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
            return obj.inspect();
          }
        }
        if (isMap(obj)) {
          var mapParts = [];
          mapForEach.call(obj, function(value, key) {
            mapParts.push(inspect(key, obj, true) + " => " + inspect(value, obj));
          });
          return collectionOf("Map", mapSize.call(obj), mapParts, indent);
        }
        if (isSet(obj)) {
          var setParts = [];
          setForEach.call(obj, function(value) {
            setParts.push(inspect(value, obj));
          });
          return collectionOf("Set", setSize.call(obj), setParts, indent);
        }
        if (isWeakMap(obj)) {
          return weakCollectionOf("WeakMap");
        }
        if (isWeakSet(obj)) {
          return weakCollectionOf("WeakSet");
        }
        if (isWeakRef(obj)) {
          return weakCollectionOf("WeakRef");
        }
        if (isNumber(obj)) {
          return markBoxed(inspect(Number(obj)));
        }
        if (isBigInt(obj)) {
          return markBoxed(inspect(bigIntValueOf.call(obj)));
        }
        if (isBoolean(obj)) {
          return markBoxed(booleanValueOf.call(obj));
        }
        if (isString(obj)) {
          return markBoxed(inspect(String(obj)));
        }
        if (!isDate(obj) && !isRegExp(obj)) {
          var ys = arrObjKeys(obj, inspect);
          var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
          var protoTag = obj instanceof Object ? "" : "null prototype";
          var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
          var constructorTag = isPlainObject || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
          var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
          if (ys.length === 0) {
            return tag + "{}";
          }
          if (indent) {
            return tag + "{" + indentedJoin(ys, indent) + "}";
          }
          return tag + "{ " + $join.call(ys, ", ") + " }";
        }
        return String(obj);
      };
      function wrapQuotes(s, defaultStyle, opts) {
        var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
        return quoteChar + s + quoteChar;
      }
      function quote(s) {
        return $replace.call(String(s), /"/g, "&quot;");
      }
      function isArray(obj) {
        return toStr(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
      }
      function isDate(obj) {
        return toStr(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
      }
      function isRegExp(obj) {
        return toStr(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
      }
      function isError(obj) {
        return toStr(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
      }
      function isString(obj) {
        return toStr(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
      }
      function isNumber(obj) {
        return toStr(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
      }
      function isBoolean(obj) {
        return toStr(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
      }
      function isSymbol(obj) {
        if (hasShammedSymbols) {
          return obj && typeof obj === "object" && obj instanceof Symbol;
        }
        if (typeof obj === "symbol") {
          return true;
        }
        if (!obj || typeof obj !== "object" || !symToString) {
          return false;
        }
        try {
          symToString.call(obj);
          return true;
        } catch (e) {
        }
        return false;
      }
      function isBigInt(obj) {
        if (!obj || typeof obj !== "object" || !bigIntValueOf) {
          return false;
        }
        try {
          bigIntValueOf.call(obj);
          return true;
        } catch (e) {
        }
        return false;
      }
      var hasOwn = Object.prototype.hasOwnProperty || function(key) {
        return key in this;
      };
      function has(obj, key) {
        return hasOwn.call(obj, key);
      }
      function toStr(obj) {
        return objectToString.call(obj);
      }
      function nameOf(f) {
        if (f.name) {
          return f.name;
        }
        var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
        if (m) {
          return m[1];
        }
        return null;
      }
      function indexOf(xs, x) {
        if (xs.indexOf) {
          return xs.indexOf(x);
        }
        for (var i = 0, l = xs.length; i < l; i++) {
          if (xs[i] === x) {
            return i;
          }
        }
        return -1;
      }
      function isMap(x) {
        if (!mapSize || !x || typeof x !== "object") {
          return false;
        }
        try {
          mapSize.call(x);
          try {
            setSize.call(x);
          } catch (s) {
            return true;
          }
          return x instanceof Map;
        } catch (e) {
        }
        return false;
      }
      function isWeakMap(x) {
        if (!weakMapHas || !x || typeof x !== "object") {
          return false;
        }
        try {
          weakMapHas.call(x, weakMapHas);
          try {
            weakSetHas.call(x, weakSetHas);
          } catch (s) {
            return true;
          }
          return x instanceof WeakMap;
        } catch (e) {
        }
        return false;
      }
      function isWeakRef(x) {
        if (!weakRefDeref || !x || typeof x !== "object") {
          return false;
        }
        try {
          weakRefDeref.call(x);
          return true;
        } catch (e) {
        }
        return false;
      }
      function isSet(x) {
        if (!setSize || !x || typeof x !== "object") {
          return false;
        }
        try {
          setSize.call(x);
          try {
            mapSize.call(x);
          } catch (m) {
            return true;
          }
          return x instanceof Set;
        } catch (e) {
        }
        return false;
      }
      function isWeakSet(x) {
        if (!weakSetHas || !x || typeof x !== "object") {
          return false;
        }
        try {
          weakSetHas.call(x, weakSetHas);
          try {
            weakMapHas.call(x, weakMapHas);
          } catch (s) {
            return true;
          }
          return x instanceof WeakSet;
        } catch (e) {
        }
        return false;
      }
      function isElement(x) {
        if (!x || typeof x !== "object") {
          return false;
        }
        if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) {
          return true;
        }
        return typeof x.nodeName === "string" && typeof x.getAttribute === "function";
      }
      function inspectString(str, opts) {
        if (str.length > opts.maxStringLength) {
          var remaining = str.length - opts.maxStringLength;
          var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
          return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
        }
        var s = $replace.call($replace.call(str, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
        return wrapQuotes(s, "single", opts);
      }
      function lowbyte(c) {
        var n = c.charCodeAt(0);
        var x = {
          8: "b",
          9: "t",
          10: "n",
          12: "f",
          13: "r"
        }[n];
        if (x) {
          return "\\" + x;
        }
        return "\\x" + (n < 16 ? "0" : "") + $toUpperCase.call(n.toString(16));
      }
      function markBoxed(str) {
        return "Object(" + str + ")";
      }
      function weakCollectionOf(type) {
        return type + " { ? }";
      }
      function collectionOf(type, size, entries, indent) {
        var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
        return type + " (" + size + ") {" + joinedEntries + "}";
      }
      function singleLineValues(xs) {
        for (var i = 0; i < xs.length; i++) {
          if (indexOf(xs[i], "\n") >= 0) {
            return false;
          }
        }
        return true;
      }
      function getIndent(opts, depth) {
        var baseIndent;
        if (opts.indent === "	") {
          baseIndent = "	";
        } else if (typeof opts.indent === "number" && opts.indent > 0) {
          baseIndent = $join.call(Array(opts.indent + 1), " ");
        } else {
          return null;
        }
        return {
          base: baseIndent,
          prev: $join.call(Array(depth + 1), baseIndent)
        };
      }
      function indentedJoin(xs, indent) {
        if (xs.length === 0) {
          return "";
        }
        var lineJoiner = "\n" + indent.prev + indent.base;
        return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
      }
      function arrObjKeys(obj, inspect) {
        var isArr = isArray(obj);
        var xs = [];
        if (isArr) {
          xs.length = obj.length;
          for (var i = 0; i < obj.length; i++) {
            xs[i] = has(obj, i) ? inspect(obj[i], obj) : "";
          }
        }
        var syms = typeof gOPS === "function" ? gOPS(obj) : [];
        var symMap;
        if (hasShammedSymbols) {
          symMap = {};
          for (var k = 0; k < syms.length; k++) {
            symMap["$" + syms[k]] = syms[k];
          }
        }
        for (var key in obj) {
          if (!has(obj, key)) {
            continue;
          }
          if (isArr && String(Number(key)) === key && key < obj.length) {
            continue;
          }
          if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
            continue;
          } else if ($test.call(/[^\w$]/, key)) {
            xs.push(inspect(key, obj) + ": " + inspect(obj[key], obj));
          } else {
            xs.push(key + ": " + inspect(obj[key], obj));
          }
        }
        if (typeof gOPS === "function") {
          for (var j = 0; j < syms.length; j++) {
            if (isEnumerable.call(obj, syms[j])) {
              xs.push("[" + inspect(syms[j]) + "]: " + inspect(obj[syms[j]], obj));
            }
          }
        }
        return xs;
      }
    }
  });

  // node_modules/side-channel/index.js
  var require_side_channel = __commonJS({
    "node_modules/side-channel/index.js"(exports2, module2) {
      "use strict";
      var GetIntrinsic = require_get_intrinsic();
      var callBound = require_callBound();
      var inspect = require_object_inspect();
      var $TypeError = GetIntrinsic("%TypeError%");
      var $WeakMap = GetIntrinsic("%WeakMap%", true);
      var $Map = GetIntrinsic("%Map%", true);
      var $weakMapGet = callBound("WeakMap.prototype.get", true);
      var $weakMapSet = callBound("WeakMap.prototype.set", true);
      var $weakMapHas = callBound("WeakMap.prototype.has", true);
      var $mapGet = callBound("Map.prototype.get", true);
      var $mapSet = callBound("Map.prototype.set", true);
      var $mapHas = callBound("Map.prototype.has", true);
      var listGetNode = function(list, key) {
        for (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {
          if (curr.key === key) {
            prev.next = curr.next;
            curr.next = list.next;
            list.next = curr;
            return curr;
          }
        }
      };
      var listGet = function(objects, key) {
        var node = listGetNode(objects, key);
        return node && node.value;
      };
      var listSet = function(objects, key, value) {
        var node = listGetNode(objects, key);
        if (node) {
          node.value = value;
        } else {
          objects.next = {
            key,
            next: objects.next,
            value
          };
        }
      };
      var listHas = function(objects, key) {
        return !!listGetNode(objects, key);
      };
      module2.exports = function getSideChannel() {
        var $wm;
        var $m;
        var $o;
        var channel = {
          assert: function(key) {
            if (!channel.has(key)) {
              throw new $TypeError("Side channel does not contain " + inspect(key));
            }
          },
          get: function(key) {
            if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
              if ($wm) {
                return $weakMapGet($wm, key);
              }
            } else if ($Map) {
              if ($m) {
                return $mapGet($m, key);
              }
            } else {
              if ($o) {
                return listGet($o, key);
              }
            }
          },
          has: function(key) {
            if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
              if ($wm) {
                return $weakMapHas($wm, key);
              }
            } else if ($Map) {
              if ($m) {
                return $mapHas($m, key);
              }
            } else {
              if ($o) {
                return listHas($o, key);
              }
            }
            return false;
          },
          set: function(key, value) {
            if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
              if (!$wm) {
                $wm = new $WeakMap();
              }
              $weakMapSet($wm, key, value);
            } else if ($Map) {
              if (!$m) {
                $m = new $Map();
              }
              $mapSet($m, key, value);
            } else {
              if (!$o) {
                $o = { key: {}, next: null };
              }
              listSet($o, key, value);
            }
          }
        };
        return channel;
      };
    }
  });

  // node_modules/qs/lib/formats.js
  var require_formats = __commonJS({
    "node_modules/qs/lib/formats.js"(exports2, module2) {
      "use strict";
      var replace = String.prototype.replace;
      var percentTwenties = /%20/g;
      var Format = {
        RFC1738: "RFC1738",
        RFC3986: "RFC3986"
      };
      module2.exports = {
        "default": Format.RFC3986,
        formatters: {
          RFC1738: function(value) {
            return replace.call(value, percentTwenties, "+");
          },
          RFC3986: function(value) {
            return String(value);
          }
        },
        RFC1738: Format.RFC1738,
        RFC3986: Format.RFC3986
      };
    }
  });

  // node_modules/qs/lib/utils.js
  var require_utils = __commonJS({
    "node_modules/qs/lib/utils.js"(exports2, module2) {
      "use strict";
      var formats = require_formats();
      var has = Object.prototype.hasOwnProperty;
      var isArray = Array.isArray;
      var hexTable = function() {
        var array = [];
        for (var i = 0; i < 256; ++i) {
          array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
        }
        return array;
      }();
      var compactQueue = function compactQueue2(queue) {
        while (queue.length > 1) {
          var item = queue.pop();
          var obj = item.obj[item.prop];
          if (isArray(obj)) {
            var compacted = [];
            for (var j = 0; j < obj.length; ++j) {
              if (typeof obj[j] !== "undefined") {
                compacted.push(obj[j]);
              }
            }
            item.obj[item.prop] = compacted;
          }
        }
      };
      var arrayToObject = function arrayToObject2(source, options) {
        var obj = options && options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
        for (var i = 0; i < source.length; ++i) {
          if (typeof source[i] !== "undefined") {
            obj[i] = source[i];
          }
        }
        return obj;
      };
      var merge = function merge2(target, source, options) {
        if (!source) {
          return target;
        }
        if (typeof source !== "object") {
          if (isArray(target)) {
            target.push(source);
          } else if (target && typeof target === "object") {
            if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) {
              target[source] = true;
            }
          } else {
            return [target, source];
          }
          return target;
        }
        if (!target || typeof target !== "object") {
          return [target].concat(source);
        }
        var mergeTarget = target;
        if (isArray(target) && !isArray(source)) {
          mergeTarget = arrayToObject(target, options);
        }
        if (isArray(target) && isArray(source)) {
          source.forEach(function(item, i) {
            if (has.call(target, i)) {
              var targetItem = target[i];
              if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
                target[i] = merge2(targetItem, item, options);
              } else {
                target.push(item);
              }
            } else {
              target[i] = item;
            }
          });
          return target;
        }
        return Object.keys(source).reduce(function(acc, key) {
          var value = source[key];
          if (has.call(acc, key)) {
            acc[key] = merge2(acc[key], value, options);
          } else {
            acc[key] = value;
          }
          return acc;
        }, mergeTarget);
      };
      var assign = function assignSingleSource(target, source) {
        return Object.keys(source).reduce(function(acc, key) {
          acc[key] = source[key];
          return acc;
        }, target);
      };
      var decode3 = function(str, decoder, charset) {
        var strWithoutPlus = str.replace(/\+/g, " ");
        if (charset === "iso-8859-1") {
          return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
        }
        try {
          return decodeURIComponent(strWithoutPlus);
        } catch (e) {
          return strWithoutPlus;
        }
      };
      var encode3 = function encode4(str, defaultEncoder, charset, kind, format) {
        if (str.length === 0) {
          return str;
        }
        var string = str;
        if (typeof str === "symbol") {
          string = Symbol.prototype.toString.call(str);
        } else if (typeof str !== "string") {
          string = String(str);
        }
        if (charset === "iso-8859-1") {
          return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
            return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
          });
        }
        var out = "";
        for (var i = 0; i < string.length; ++i) {
          var c = string.charCodeAt(i);
          if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 || format === formats.RFC1738 && (c === 40 || c === 41)) {
            out += string.charAt(i);
            continue;
          }
          if (c < 128) {
            out = out + hexTable[c];
            continue;
          }
          if (c < 2048) {
            out = out + (hexTable[192 | c >> 6] + hexTable[128 | c & 63]);
            continue;
          }
          if (c < 55296 || c >= 57344) {
            out = out + (hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63]);
            continue;
          }
          i += 1;
          c = 65536 + ((c & 1023) << 10 | string.charCodeAt(i) & 1023);
          out += hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
        }
        return out;
      };
      var compact = function compact2(value) {
        var queue = [{ obj: { o: value }, prop: "o" }];
        var refs = [];
        for (var i = 0; i < queue.length; ++i) {
          var item = queue[i];
          var obj = item.obj[item.prop];
          var keys = Object.keys(obj);
          for (var j = 0; j < keys.length; ++j) {
            var key = keys[j];
            var val = obj[key];
            if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
              queue.push({ obj, prop: key });
              refs.push(val);
            }
          }
        }
        compactQueue(queue);
        return value;
      };
      var isRegExp = function isRegExp2(obj) {
        return Object.prototype.toString.call(obj) === "[object RegExp]";
      };
      var isBuffer = function isBuffer2(obj) {
        if (!obj || typeof obj !== "object") {
          return false;
        }
        return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
      };
      var combine = function combine2(a, b) {
        return [].concat(a, b);
      };
      var maybeMap = function maybeMap2(val, fn) {
        if (isArray(val)) {
          var mapped = [];
          for (var i = 0; i < val.length; i += 1) {
            mapped.push(fn(val[i]));
          }
          return mapped;
        }
        return fn(val);
      };
      module2.exports = {
        arrayToObject,
        assign,
        combine,
        compact,
        decode: decode3,
        encode: encode3,
        isBuffer,
        isRegExp,
        maybeMap,
        merge
      };
    }
  });

  // node_modules/qs/lib/stringify.js
  var require_stringify2 = __commonJS({
    "node_modules/qs/lib/stringify.js"(exports2, module2) {
      "use strict";
      var getSideChannel = require_side_channel();
      var utils = require_utils();
      var formats = require_formats();
      var has = Object.prototype.hasOwnProperty;
      var arrayPrefixGenerators = {
        brackets: function brackets(prefix) {
          return prefix + "[]";
        },
        comma: "comma",
        indices: function indices(prefix, key) {
          return prefix + "[" + key + "]";
        },
        repeat: function repeat(prefix) {
          return prefix;
        }
      };
      var isArray = Array.isArray;
      var split = String.prototype.split;
      var push = Array.prototype.push;
      var pushToArray = function(arr, valueOrArray) {
        push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
      };
      var toISO = Date.prototype.toISOString;
      var defaultFormat = formats["default"];
      var defaults = {
        addQueryPrefix: false,
        allowDots: false,
        charset: "utf-8",
        charsetSentinel: false,
        delimiter: "&",
        encode: true,
        encoder: utils.encode,
        encodeValuesOnly: false,
        format: defaultFormat,
        formatter: formats.formatters[defaultFormat],
        indices: false,
        serializeDate: function serializeDate(date) {
          return toISO.call(date);
        },
        skipNulls: false,
        strictNullHandling: false
      };
      var isNonNullishPrimitive = function isNonNullishPrimitive2(v) {
        return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
      };
      var sentinel = {};
      var stringify = function stringify2(object, prefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
        var obj = object;
        var tmpSc = sideChannel;
        var step = 0;
        var findFlag = false;
        while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
          var pos = tmpSc.get(object);
          step += 1;
          if (typeof pos !== "undefined") {
            if (pos === step) {
              throw new RangeError("Cyclic object value");
            } else {
              findFlag = true;
            }
          }
          if (typeof tmpSc.get(sentinel) === "undefined") {
            step = 0;
          }
        }
        if (typeof filter === "function") {
          obj = filter(prefix, obj);
        } else if (obj instanceof Date) {
          obj = serializeDate(obj);
        } else if (generateArrayPrefix === "comma" && isArray(obj)) {
          obj = utils.maybeMap(obj, function(value2) {
            if (value2 instanceof Date) {
              return serializeDate(value2);
            }
            return value2;
          });
        }
        if (obj === null) {
          if (strictNullHandling) {
            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, "key", format) : prefix;
          }
          obj = "";
        }
        if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
          if (encoder) {
            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, "key", format);
            if (generateArrayPrefix === "comma" && encodeValuesOnly) {
              var valuesArray = split.call(String(obj), ",");
              var valuesJoined = "";
              for (var i = 0; i < valuesArray.length; ++i) {
                valuesJoined += (i === 0 ? "" : ",") + formatter(encoder(valuesArray[i], defaults.encoder, charset, "value", format));
              }
              return [formatter(keyValue) + "=" + valuesJoined];
            }
            return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults.encoder, charset, "value", format))];
          }
          return [formatter(prefix) + "=" + formatter(String(obj))];
        }
        var values = [];
        if (typeof obj === "undefined") {
          return values;
        }
        var objKeys;
        if (generateArrayPrefix === "comma" && isArray(obj)) {
          objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
        } else if (isArray(filter)) {
          objKeys = filter;
        } else {
          var keys = Object.keys(obj);
          objKeys = sort ? keys.sort(sort) : keys;
        }
        for (var j = 0; j < objKeys.length; ++j) {
          var key = objKeys[j];
          var value = typeof key === "object" && typeof key.value !== "undefined" ? key.value : obj[key];
          if (skipNulls && value === null) {
            continue;
          }
          var keyPrefix = isArray(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(prefix, key) : prefix : prefix + (allowDots ? "." + key : "[" + key + "]");
          sideChannel.set(object, step);
          var valueSideChannel = getSideChannel();
          valueSideChannel.set(sentinel, sideChannel);
          pushToArray(values, stringify2(value, keyPrefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, valueSideChannel));
        }
        return values;
      };
      var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
        if (!opts) {
          return defaults;
        }
        if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
          throw new TypeError("Encoder has to be a function.");
        }
        var charset = opts.charset || defaults.charset;
        if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
          throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
        }
        var format = formats["default"];
        if (typeof opts.format !== "undefined") {
          if (!has.call(formats.formatters, opts.format)) {
            throw new TypeError("Unknown format option provided.");
          }
          format = opts.format;
        }
        var formatter = formats.formatters[format];
        var filter = defaults.filter;
        if (typeof opts.filter === "function" || isArray(opts.filter)) {
          filter = opts.filter;
        }
        return {
          addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
          allowDots: typeof opts.allowDots === "undefined" ? defaults.allowDots : !!opts.allowDots,
          charset,
          charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
          delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
          encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
          encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
          encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
          filter,
          format,
          formatter,
          serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
          skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
          sort: typeof opts.sort === "function" ? opts.sort : null,
          strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
        };
      };
      module2.exports = function(object, opts) {
        var obj = object;
        var options = normalizeStringifyOptions(opts);
        var objKeys;
        var filter;
        if (typeof options.filter === "function") {
          filter = options.filter;
          obj = filter("", obj);
        } else if (isArray(options.filter)) {
          filter = options.filter;
          objKeys = filter;
        }
        var keys = [];
        if (typeof obj !== "object" || obj === null) {
          return "";
        }
        var arrayFormat;
        if (opts && opts.arrayFormat in arrayPrefixGenerators) {
          arrayFormat = opts.arrayFormat;
        } else if (opts && "indices" in opts) {
          arrayFormat = opts.indices ? "indices" : "repeat";
        } else {
          arrayFormat = "indices";
        }
        var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
        if (!objKeys) {
          objKeys = Object.keys(obj);
        }
        if (options.sort) {
          objKeys.sort(options.sort);
        }
        var sideChannel = getSideChannel();
        for (var i = 0; i < objKeys.length; ++i) {
          var key = objKeys[i];
          if (options.skipNulls && obj[key] === null) {
            continue;
          }
          pushToArray(keys, stringify(obj[key], key, generateArrayPrefix, options.strictNullHandling, options.skipNulls, options.encode ? options.encoder : null, options.filter, options.sort, options.allowDots, options.serializeDate, options.format, options.formatter, options.encodeValuesOnly, options.charset, sideChannel));
        }
        var joined = keys.join(options.delimiter);
        var prefix = options.addQueryPrefix === true ? "?" : "";
        if (options.charsetSentinel) {
          if (options.charset === "iso-8859-1") {
            prefix += "utf8=%26%2310003%3B&";
          } else {
            prefix += "utf8=%E2%9C%93&";
          }
        }
        return joined.length > 0 ? prefix + joined : "";
      };
    }
  });

  // node_modules/qs/lib/parse.js
  var require_parse2 = __commonJS({
    "node_modules/qs/lib/parse.js"(exports2, module2) {
      "use strict";
      var utils = require_utils();
      var has = Object.prototype.hasOwnProperty;
      var isArray = Array.isArray;
      var defaults = {
        allowDots: false,
        allowPrototypes: false,
        allowSparse: false,
        arrayLimit: 20,
        charset: "utf-8",
        charsetSentinel: false,
        comma: false,
        decoder: utils.decode,
        delimiter: "&",
        depth: 5,
        ignoreQueryPrefix: false,
        interpretNumericEntities: false,
        parameterLimit: 1e3,
        parseArrays: true,
        plainObjects: false,
        strictNullHandling: false
      };
      var interpretNumericEntities = function(str) {
        return str.replace(/&#(\d+);/g, function($0, numberStr) {
          return String.fromCharCode(parseInt(numberStr, 10));
        });
      };
      var parseArrayValue = function(val, options) {
        if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
          return val.split(",");
        }
        return val;
      };
      var isoSentinel = "utf8=%26%2310003%3B";
      var charsetSentinel = "utf8=%E2%9C%93";
      var parseValues = function parseQueryStringValues(str, options) {
        var obj = {};
        var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
        var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
        var parts = cleanStr.split(options.delimiter, limit);
        var skipIndex = -1;
        var i;
        var charset = options.charset;
        if (options.charsetSentinel) {
          for (i = 0; i < parts.length; ++i) {
            if (parts[i].indexOf("utf8=") === 0) {
              if (parts[i] === charsetSentinel) {
                charset = "utf-8";
              } else if (parts[i] === isoSentinel) {
                charset = "iso-8859-1";
              }
              skipIndex = i;
              i = parts.length;
            }
          }
        }
        for (i = 0; i < parts.length; ++i) {
          if (i === skipIndex) {
            continue;
          }
          var part = parts[i];
          var bracketEqualsPos = part.indexOf("]=");
          var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
          var key, val;
          if (pos === -1) {
            key = options.decoder(part, defaults.decoder, charset, "key");
            val = options.strictNullHandling ? null : "";
          } else {
            key = options.decoder(part.slice(0, pos), defaults.decoder, charset, "key");
            val = utils.maybeMap(parseArrayValue(part.slice(pos + 1), options), function(encodedVal) {
              return options.decoder(encodedVal, defaults.decoder, charset, "value");
            });
          }
          if (val && options.interpretNumericEntities && charset === "iso-8859-1") {
            val = interpretNumericEntities(val);
          }
          if (part.indexOf("[]=") > -1) {
            val = isArray(val) ? [val] : val;
          }
          if (has.call(obj, key)) {
            obj[key] = utils.combine(obj[key], val);
          } else {
            obj[key] = val;
          }
        }
        return obj;
      };
      var parseObject = function(chain, val, options, valuesParsed) {
        var leaf = valuesParsed ? val : parseArrayValue(val, options);
        for (var i = chain.length - 1; i >= 0; --i) {
          var obj;
          var root2 = chain[i];
          if (root2 === "[]" && options.parseArrays) {
            obj = [].concat(leaf);
          } else {
            obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
            var cleanRoot = root2.charAt(0) === "[" && root2.charAt(root2.length - 1) === "]" ? root2.slice(1, -1) : root2;
            var index = parseInt(cleanRoot, 10);
            if (!options.parseArrays && cleanRoot === "") {
              obj = { 0: leaf };
            } else if (!isNaN(index) && root2 !== cleanRoot && String(index) === cleanRoot && index >= 0 && (options.parseArrays && index <= options.arrayLimit)) {
              obj = [];
              obj[index] = leaf;
            } else if (cleanRoot !== "__proto__") {
              obj[cleanRoot] = leaf;
            }
          }
          leaf = obj;
        }
        return leaf;
      };
      var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
        if (!givenKey) {
          return;
        }
        var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
        var brackets = /(\[[^[\]]*])/;
        var child = /(\[[^[\]]*])/g;
        var segment = options.depth > 0 && brackets.exec(key);
        var parent = segment ? key.slice(0, segment.index) : key;
        var keys = [];
        if (parent) {
          if (!options.plainObjects && has.call(Object.prototype, parent)) {
            if (!options.allowPrototypes) {
              return;
            }
          }
          keys.push(parent);
        }
        var i = 0;
        while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
          i += 1;
          if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
            if (!options.allowPrototypes) {
              return;
            }
          }
          keys.push(segment[1]);
        }
        if (segment) {
          keys.push("[" + key.slice(segment.index) + "]");
        }
        return parseObject(keys, val, options, valuesParsed);
      };
      var normalizeParseOptions = function normalizeParseOptions2(opts) {
        if (!opts) {
          return defaults;
        }
        if (opts.decoder !== null && opts.decoder !== void 0 && typeof opts.decoder !== "function") {
          throw new TypeError("Decoder has to be a function.");
        }
        if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
          throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
        }
        var charset = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
        return {
          allowDots: typeof opts.allowDots === "undefined" ? defaults.allowDots : !!opts.allowDots,
          allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
          allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults.allowSparse,
          arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
          charset,
          charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
          comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
          decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
          delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
          depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults.depth,
          ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
          interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
          parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
          parseArrays: opts.parseArrays !== false,
          plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
          strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
        };
      };
      module2.exports = function(str, opts) {
        var options = normalizeParseOptions(opts);
        if (str === "" || str === null || typeof str === "undefined") {
          return options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
        }
        var tempObj = typeof str === "string" ? parseValues(str, options) : str;
        var obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
        var keys = Object.keys(tempObj);
        for (var i = 0; i < keys.length; ++i) {
          var key = keys[i];
          var newObj = parseKeys(key, tempObj[key], options, typeof str === "string");
          obj = utils.merge(obj, newObj, options);
        }
        if (options.allowSparse === true) {
          return obj;
        }
        return utils.compact(obj);
      };
    }
  });

  // node_modules/qs/lib/index.js
  var require_lib = __commonJS({
    "node_modules/qs/lib/index.js"(exports2, module2) {
      "use strict";
      var stringify = require_stringify2();
      var parse = require_parse2();
      var formats = require_formats();
      module2.exports = {
        formats,
        parse,
        stringify
      };
    }
  });

  // node_modules/mime/Mime.js
  var require_Mime = __commonJS({
    "node_modules/mime/Mime.js"(exports2, module2) {
      "use strict";
      function Mime() {
        this._types = /* @__PURE__ */ Object.create(null);
        this._extensions = /* @__PURE__ */ Object.create(null);
        for (let i = 0; i < arguments.length; i++) {
          this.define(arguments[i]);
        }
        this.define = this.define.bind(this);
        this.getType = this.getType.bind(this);
        this.getExtension = this.getExtension.bind(this);
      }
      Mime.prototype.define = function(typeMap, force) {
        for (let type in typeMap) {
          let extensions = typeMap[type].map(function(t) {
            return t.toLowerCase();
          });
          type = type.toLowerCase();
          for (let i = 0; i < extensions.length; i++) {
            const ext = extensions[i];
            if (ext[0] === "*") {
              continue;
            }
            if (!force && ext in this._types) {
              throw new Error('Attempt to change mapping for "' + ext + '" extension from "' + this._types[ext] + '" to "' + type + '". Pass `force=true` to allow this, otherwise remove "' + ext + '" from the list of extensions for "' + type + '".');
            }
            this._types[ext] = type;
          }
          if (force || !this._extensions[type]) {
            const ext = extensions[0];
            this._extensions[type] = ext[0] !== "*" ? ext : ext.substr(1);
          }
        }
      };
      Mime.prototype.getType = function(path2) {
        path2 = String(path2);
        let last = path2.replace(/^.*[/\\]/, "").toLowerCase();
        let ext = last.replace(/^.*\./, "").toLowerCase();
        let hasPath = last.length < path2.length;
        let hasDot = ext.length < last.length - 1;
        return (hasDot || !hasPath) && this._types[ext] || null;
      };
      Mime.prototype.getExtension = function(type) {
        type = /^\s*([^;\s]*)/.test(type) && RegExp.$1;
        return type && this._extensions[type.toLowerCase()] || null;
      };
      module2.exports = Mime;
    }
  });

  // node_modules/mime/types/standard.js
  var require_standard = __commonJS({
    "node_modules/mime/types/standard.js"(exports2, module2) {
      module2.exports = { "application/andrew-inset": ["ez"], "application/applixware": ["aw"], "application/atom+xml": ["atom"], "application/atomcat+xml": ["atomcat"], "application/atomdeleted+xml": ["atomdeleted"], "application/atomsvc+xml": ["atomsvc"], "application/atsc-dwd+xml": ["dwd"], "application/atsc-held+xml": ["held"], "application/atsc-rsat+xml": ["rsat"], "application/bdoc": ["bdoc"], "application/calendar+xml": ["xcs"], "application/ccxml+xml": ["ccxml"], "application/cdfx+xml": ["cdfx"], "application/cdmi-capability": ["cdmia"], "application/cdmi-container": ["cdmic"], "application/cdmi-domain": ["cdmid"], "application/cdmi-object": ["cdmio"], "application/cdmi-queue": ["cdmiq"], "application/cu-seeme": ["cu"], "application/dash+xml": ["mpd"], "application/davmount+xml": ["davmount"], "application/docbook+xml": ["dbk"], "application/dssc+der": ["dssc"], "application/dssc+xml": ["xdssc"], "application/ecmascript": ["es", "ecma"], "application/emma+xml": ["emma"], "application/emotionml+xml": ["emotionml"], "application/epub+zip": ["epub"], "application/exi": ["exi"], "application/express": ["exp"], "application/fdt+xml": ["fdt"], "application/font-tdpfr": ["pfr"], "application/geo+json": ["geojson"], "application/gml+xml": ["gml"], "application/gpx+xml": ["gpx"], "application/gxf": ["gxf"], "application/gzip": ["gz"], "application/hjson": ["hjson"], "application/hyperstudio": ["stk"], "application/inkml+xml": ["ink", "inkml"], "application/ipfix": ["ipfix"], "application/its+xml": ["its"], "application/java-archive": ["jar", "war", "ear"], "application/java-serialized-object": ["ser"], "application/java-vm": ["class"], "application/javascript": ["js", "mjs"], "application/json": ["json", "map"], "application/json5": ["json5"], "application/jsonml+json": ["jsonml"], "application/ld+json": ["jsonld"], "application/lgr+xml": ["lgr"], "application/lost+xml": ["lostxml"], "application/mac-binhex40": ["hqx"], "application/mac-compactpro": ["cpt"], "application/mads+xml": ["mads"], "application/manifest+json": ["webmanifest"], "application/marc": ["mrc"], "application/marcxml+xml": ["mrcx"], "application/mathematica": ["ma", "nb", "mb"], "application/mathml+xml": ["mathml"], "application/mbox": ["mbox"], "application/mediaservercontrol+xml": ["mscml"], "application/metalink+xml": ["metalink"], "application/metalink4+xml": ["meta4"], "application/mets+xml": ["mets"], "application/mmt-aei+xml": ["maei"], "application/mmt-usd+xml": ["musd"], "application/mods+xml": ["mods"], "application/mp21": ["m21", "mp21"], "application/mp4": ["mp4s", "m4p"], "application/msword": ["doc", "dot"], "application/mxf": ["mxf"], "application/n-quads": ["nq"], "application/n-triples": ["nt"], "application/node": ["cjs"], "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"], "application/oda": ["oda"], "application/oebps-package+xml": ["opf"], "application/ogg": ["ogx"], "application/omdoc+xml": ["omdoc"], "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"], "application/oxps": ["oxps"], "application/p2p-overlay+xml": ["relo"], "application/patch-ops-error+xml": ["xer"], "application/pdf": ["pdf"], "application/pgp-encrypted": ["pgp"], "application/pgp-signature": ["asc", "sig"], "application/pics-rules": ["prf"], "application/pkcs10": ["p10"], "application/pkcs7-mime": ["p7m", "p7c"], "application/pkcs7-signature": ["p7s"], "application/pkcs8": ["p8"], "application/pkix-attr-cert": ["ac"], "application/pkix-cert": ["cer"], "application/pkix-crl": ["crl"], "application/pkix-pkipath": ["pkipath"], "application/pkixcmp": ["pki"], "application/pls+xml": ["pls"], "application/postscript": ["ai", "eps", "ps"], "application/provenance+xml": ["provx"], "application/pskc+xml": ["pskcxml"], "application/raml+yaml": ["raml"], "application/rdf+xml": ["rdf", "owl"], "application/reginfo+xml": ["rif"], "application/relax-ng-compact-syntax": ["rnc"], "application/resource-lists+xml": ["rl"], "application/resource-lists-diff+xml": ["rld"], "application/rls-services+xml": ["rs"], "application/route-apd+xml": ["rapd"], "application/route-s-tsid+xml": ["sls"], "application/route-usd+xml": ["rusd"], "application/rpki-ghostbusters": ["gbr"], "application/rpki-manifest": ["mft"], "application/rpki-roa": ["roa"], "application/rsd+xml": ["rsd"], "application/rss+xml": ["rss"], "application/rtf": ["rtf"], "application/sbml+xml": ["sbml"], "application/scvp-cv-request": ["scq"], "application/scvp-cv-response": ["scs"], "application/scvp-vp-request": ["spq"], "application/scvp-vp-response": ["spp"], "application/sdp": ["sdp"], "application/senml+xml": ["senmlx"], "application/sensml+xml": ["sensmlx"], "application/set-payment-initiation": ["setpay"], "application/set-registration-initiation": ["setreg"], "application/shf+xml": ["shf"], "application/sieve": ["siv", "sieve"], "application/smil+xml": ["smi", "smil"], "application/sparql-query": ["rq"], "application/sparql-results+xml": ["srx"], "application/srgs": ["gram"], "application/srgs+xml": ["grxml"], "application/sru+xml": ["sru"], "application/ssdl+xml": ["ssdl"], "application/ssml+xml": ["ssml"], "application/swid+xml": ["swidtag"], "application/tei+xml": ["tei", "teicorpus"], "application/thraud+xml": ["tfi"], "application/timestamped-data": ["tsd"], "application/toml": ["toml"], "application/trig": ["trig"], "application/ttml+xml": ["ttml"], "application/ubjson": ["ubj"], "application/urc-ressheet+xml": ["rsheet"], "application/urc-targetdesc+xml": ["td"], "application/voicexml+xml": ["vxml"], "application/wasm": ["wasm"], "application/widget": ["wgt"], "application/winhlp": ["hlp"], "application/wsdl+xml": ["wsdl"], "application/wspolicy+xml": ["wspolicy"], "application/xaml+xml": ["xaml"], "application/xcap-att+xml": ["xav"], "application/xcap-caps+xml": ["xca"], "application/xcap-diff+xml": ["xdf"], "application/xcap-el+xml": ["xel"], "application/xcap-ns+xml": ["xns"], "application/xenc+xml": ["xenc"], "application/xhtml+xml": ["xhtml", "xht"], "application/xliff+xml": ["xlf"], "application/xml": ["xml", "xsl", "xsd", "rng"], "application/xml-dtd": ["dtd"], "application/xop+xml": ["xop"], "application/xproc+xml": ["xpl"], "application/xslt+xml": ["*xsl", "xslt"], "application/xspf+xml": ["xspf"], "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"], "application/yang": ["yang"], "application/yin+xml": ["yin"], "application/zip": ["zip"], "audio/3gpp": ["*3gpp"], "audio/adpcm": ["adp"], "audio/amr": ["amr"], "audio/basic": ["au", "snd"], "audio/midi": ["mid", "midi", "kar", "rmi"], "audio/mobile-xmf": ["mxmf"], "audio/mp3": ["*mp3"], "audio/mp4": ["m4a", "mp4a"], "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"], "audio/ogg": ["oga", "ogg", "spx", "opus"], "audio/s3m": ["s3m"], "audio/silk": ["sil"], "audio/wav": ["wav"], "audio/wave": ["*wav"], "audio/webm": ["weba"], "audio/xm": ["xm"], "font/collection": ["ttc"], "font/otf": ["otf"], "font/ttf": ["ttf"], "font/woff": ["woff"], "font/woff2": ["woff2"], "image/aces": ["exr"], "image/apng": ["apng"], "image/avif": ["avif"], "image/bmp": ["bmp"], "image/cgm": ["cgm"], "image/dicom-rle": ["drle"], "image/emf": ["emf"], "image/fits": ["fits"], "image/g3fax": ["g3"], "image/gif": ["gif"], "image/heic": ["heic"], "image/heic-sequence": ["heics"], "image/heif": ["heif"], "image/heif-sequence": ["heifs"], "image/hej2k": ["hej2"], "image/hsj2": ["hsj2"], "image/ief": ["ief"], "image/jls": ["jls"], "image/jp2": ["jp2", "jpg2"], "image/jpeg": ["jpeg", "jpg", "jpe"], "image/jph": ["jph"], "image/jphc": ["jhc"], "image/jpm": ["jpm"], "image/jpx": ["jpx", "jpf"], "image/jxr": ["jxr"], "image/jxra": ["jxra"], "image/jxrs": ["jxrs"], "image/jxs": ["jxs"], "image/jxsc": ["jxsc"], "image/jxsi": ["jxsi"], "image/jxss": ["jxss"], "image/ktx": ["ktx"], "image/ktx2": ["ktx2"], "image/png": ["png"], "image/sgi": ["sgi"], "image/svg+xml": ["svg", "svgz"], "image/t38": ["t38"], "image/tiff": ["tif", "tiff"], "image/tiff-fx": ["tfx"], "image/webp": ["webp"], "image/wmf": ["wmf"], "message/disposition-notification": ["disposition-notification"], "message/global": ["u8msg"], "message/global-delivery-status": ["u8dsn"], "message/global-disposition-notification": ["u8mdn"], "message/global-headers": ["u8hdr"], "message/rfc822": ["eml", "mime"], "model/3mf": ["3mf"], "model/gltf+json": ["gltf"], "model/gltf-binary": ["glb"], "model/iges": ["igs", "iges"], "model/mesh": ["msh", "mesh", "silo"], "model/mtl": ["mtl"], "model/obj": ["obj"], "model/step+xml": ["stpx"], "model/step+zip": ["stpz"], "model/step-xml+zip": ["stpxz"], "model/stl": ["stl"], "model/vrml": ["wrl", "vrml"], "model/x3d+binary": ["*x3db", "x3dbz"], "model/x3d+fastinfoset": ["x3db"], "model/x3d+vrml": ["*x3dv", "x3dvz"], "model/x3d+xml": ["x3d", "x3dz"], "model/x3d-vrml": ["x3dv"], "text/cache-manifest": ["appcache", "manifest"], "text/calendar": ["ics", "ifb"], "text/coffeescript": ["coffee", "litcoffee"], "text/css": ["css"], "text/csv": ["csv"], "text/html": ["html", "htm", "shtml"], "text/jade": ["jade"], "text/jsx": ["jsx"], "text/less": ["less"], "text/markdown": ["markdown", "md"], "text/mathml": ["mml"], "text/mdx": ["mdx"], "text/n3": ["n3"], "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"], "text/richtext": ["rtx"], "text/rtf": ["*rtf"], "text/sgml": ["sgml", "sgm"], "text/shex": ["shex"], "text/slim": ["slim", "slm"], "text/spdx": ["spdx"], "text/stylus": ["stylus", "styl"], "text/tab-separated-values": ["tsv"], "text/troff": ["t", "tr", "roff", "man", "me", "ms"], "text/turtle": ["ttl"], "text/uri-list": ["uri", "uris", "urls"], "text/vcard": ["vcard"], "text/vtt": ["vtt"], "text/xml": ["*xml"], "text/yaml": ["yaml", "yml"], "video/3gpp": ["3gp", "3gpp"], "video/3gpp2": ["3g2"], "video/h261": ["h261"], "video/h263": ["h263"], "video/h264": ["h264"], "video/iso.segment": ["m4s"], "video/jpeg": ["jpgv"], "video/jpm": ["*jpm", "jpgm"], "video/mj2": ["mj2", "mjp2"], "video/mp2t": ["ts"], "video/mp4": ["mp4", "mp4v", "mpg4"], "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"], "video/ogg": ["ogv"], "video/quicktime": ["qt", "mov"], "video/webm": ["webm"] };
    }
  });

  // node_modules/mime/types/other.js
  var require_other = __commonJS({
    "node_modules/mime/types/other.js"(exports2, module2) {
      module2.exports = { "application/prs.cww": ["cww"], "application/vnd.1000minds.decision-model+xml": ["1km"], "application/vnd.3gpp.pic-bw-large": ["plb"], "application/vnd.3gpp.pic-bw-small": ["psb"], "application/vnd.3gpp.pic-bw-var": ["pvb"], "application/vnd.3gpp2.tcap": ["tcap"], "application/vnd.3m.post-it-notes": ["pwn"], "application/vnd.accpac.simply.aso": ["aso"], "application/vnd.accpac.simply.imp": ["imp"], "application/vnd.acucobol": ["acu"], "application/vnd.acucorp": ["atc", "acutc"], "application/vnd.adobe.air-application-installer-package+zip": ["air"], "application/vnd.adobe.formscentral.fcdt": ["fcdt"], "application/vnd.adobe.fxp": ["fxp", "fxpl"], "application/vnd.adobe.xdp+xml": ["xdp"], "application/vnd.adobe.xfdf": ["xfdf"], "application/vnd.ahead.space": ["ahead"], "application/vnd.airzip.filesecure.azf": ["azf"], "application/vnd.airzip.filesecure.azs": ["azs"], "application/vnd.amazon.ebook": ["azw"], "application/vnd.americandynamics.acc": ["acc"], "application/vnd.amiga.ami": ["ami"], "application/vnd.android.package-archive": ["apk"], "application/vnd.anser-web-certificate-issue-initiation": ["cii"], "application/vnd.anser-web-funds-transfer-initiation": ["fti"], "application/vnd.antix.game-component": ["atx"], "application/vnd.apple.installer+xml": ["mpkg"], "application/vnd.apple.keynote": ["key"], "application/vnd.apple.mpegurl": ["m3u8"], "application/vnd.apple.numbers": ["numbers"], "application/vnd.apple.pages": ["pages"], "application/vnd.apple.pkpass": ["pkpass"], "application/vnd.aristanetworks.swi": ["swi"], "application/vnd.astraea-software.iota": ["iota"], "application/vnd.audiograph": ["aep"], "application/vnd.balsamiq.bmml+xml": ["bmml"], "application/vnd.blueice.multipass": ["mpm"], "application/vnd.bmi": ["bmi"], "application/vnd.businessobjects": ["rep"], "application/vnd.chemdraw+xml": ["cdxml"], "application/vnd.chipnuts.karaoke-mmd": ["mmd"], "application/vnd.cinderella": ["cdy"], "application/vnd.citationstyles.style+xml": ["csl"], "application/vnd.claymore": ["cla"], "application/vnd.cloanto.rp9": ["rp9"], "application/vnd.clonk.c4group": ["c4g", "c4d", "c4f", "c4p", "c4u"], "application/vnd.cluetrust.cartomobile-config": ["c11amc"], "application/vnd.cluetrust.cartomobile-config-pkg": ["c11amz"], "application/vnd.commonspace": ["csp"], "application/vnd.contact.cmsg": ["cdbcmsg"], "application/vnd.cosmocaller": ["cmc"], "application/vnd.crick.clicker": ["clkx"], "application/vnd.crick.clicker.keyboard": ["clkk"], "application/vnd.crick.clicker.palette": ["clkp"], "application/vnd.crick.clicker.template": ["clkt"], "application/vnd.crick.clicker.wordbank": ["clkw"], "application/vnd.criticaltools.wbs+xml": ["wbs"], "application/vnd.ctc-posml": ["pml"], "application/vnd.cups-ppd": ["ppd"], "application/vnd.curl.car": ["car"], "application/vnd.curl.pcurl": ["pcurl"], "application/vnd.dart": ["dart"], "application/vnd.data-vision.rdz": ["rdz"], "application/vnd.dbf": ["dbf"], "application/vnd.dece.data": ["uvf", "uvvf", "uvd", "uvvd"], "application/vnd.dece.ttml+xml": ["uvt", "uvvt"], "application/vnd.dece.unspecified": ["uvx", "uvvx"], "application/vnd.dece.zip": ["uvz", "uvvz"], "application/vnd.denovo.fcselayout-link": ["fe_launch"], "application/vnd.dna": ["dna"], "application/vnd.dolby.mlp": ["mlp"], "application/vnd.dpgraph": ["dpg"], "application/vnd.dreamfactory": ["dfac"], "application/vnd.ds-keypoint": ["kpxx"], "application/vnd.dvb.ait": ["ait"], "application/vnd.dvb.service": ["svc"], "application/vnd.dynageo": ["geo"], "application/vnd.ecowin.chart": ["mag"], "application/vnd.enliven": ["nml"], "application/vnd.epson.esf": ["esf"], "application/vnd.epson.msf": ["msf"], "application/vnd.epson.quickanime": ["qam"], "application/vnd.epson.salt": ["slt"], "application/vnd.epson.ssf": ["ssf"], "application/vnd.eszigno3+xml": ["es3", "et3"], "application/vnd.ezpix-album": ["ez2"], "application/vnd.ezpix-package": ["ez3"], "application/vnd.fdf": ["fdf"], "application/vnd.fdsn.mseed": ["mseed"], "application/vnd.fdsn.seed": ["seed", "dataless"], "application/vnd.flographit": ["gph"], "application/vnd.fluxtime.clip": ["ftc"], "application/vnd.framemaker": ["fm", "frame", "maker", "book"], "application/vnd.frogans.fnc": ["fnc"], "application/vnd.frogans.ltf": ["ltf"], "application/vnd.fsc.weblaunch": ["fsc"], "application/vnd.fujitsu.oasys": ["oas"], "application/vnd.fujitsu.oasys2": ["oa2"], "application/vnd.fujitsu.oasys3": ["oa3"], "application/vnd.fujitsu.oasysgp": ["fg5"], "application/vnd.fujitsu.oasysprs": ["bh2"], "application/vnd.fujixerox.ddd": ["ddd"], "application/vnd.fujixerox.docuworks": ["xdw"], "application/vnd.fujixerox.docuworks.binder": ["xbd"], "application/vnd.fuzzysheet": ["fzs"], "application/vnd.genomatix.tuxedo": ["txd"], "application/vnd.geogebra.file": ["ggb"], "application/vnd.geogebra.tool": ["ggt"], "application/vnd.geometry-explorer": ["gex", "gre"], "application/vnd.geonext": ["gxt"], "application/vnd.geoplan": ["g2w"], "application/vnd.geospace": ["g3w"], "application/vnd.gmx": ["gmx"], "application/vnd.google-apps.document": ["gdoc"], "application/vnd.google-apps.presentation": ["gslides"], "application/vnd.google-apps.spreadsheet": ["gsheet"], "application/vnd.google-earth.kml+xml": ["kml"], "application/vnd.google-earth.kmz": ["kmz"], "application/vnd.grafeq": ["gqf", "gqs"], "application/vnd.groove-account": ["gac"], "application/vnd.groove-help": ["ghf"], "application/vnd.groove-identity-message": ["gim"], "application/vnd.groove-injector": ["grv"], "application/vnd.groove-tool-message": ["gtm"], "application/vnd.groove-tool-template": ["tpl"], "application/vnd.groove-vcard": ["vcg"], "application/vnd.hal+xml": ["hal"], "application/vnd.handheld-entertainment+xml": ["zmm"], "application/vnd.hbci": ["hbci"], "application/vnd.hhe.lesson-player": ["les"], "application/vnd.hp-hpgl": ["hpgl"], "application/vnd.hp-hpid": ["hpid"], "application/vnd.hp-hps": ["hps"], "application/vnd.hp-jlyt": ["jlt"], "application/vnd.hp-pcl": ["pcl"], "application/vnd.hp-pclxl": ["pclxl"], "application/vnd.hydrostatix.sof-data": ["sfd-hdstx"], "application/vnd.ibm.minipay": ["mpy"], "application/vnd.ibm.modcap": ["afp", "listafp", "list3820"], "application/vnd.ibm.rights-management": ["irm"], "application/vnd.ibm.secure-container": ["sc"], "application/vnd.iccprofile": ["icc", "icm"], "application/vnd.igloader": ["igl"], "application/vnd.immervision-ivp": ["ivp"], "application/vnd.immervision-ivu": ["ivu"], "application/vnd.insors.igm": ["igm"], "application/vnd.intercon.formnet": ["xpw", "xpx"], "application/vnd.intergeo": ["i2g"], "application/vnd.intu.qbo": ["qbo"], "application/vnd.intu.qfx": ["qfx"], "application/vnd.ipunplugged.rcprofile": ["rcprofile"], "application/vnd.irepository.package+xml": ["irp"], "application/vnd.is-xpr": ["xpr"], "application/vnd.isac.fcs": ["fcs"], "application/vnd.jam": ["jam"], "application/vnd.jcp.javame.midlet-rms": ["rms"], "application/vnd.jisp": ["jisp"], "application/vnd.joost.joda-archive": ["joda"], "application/vnd.kahootz": ["ktz", "ktr"], "application/vnd.kde.karbon": ["karbon"], "application/vnd.kde.kchart": ["chrt"], "application/vnd.kde.kformula": ["kfo"], "application/vnd.kde.kivio": ["flw"], "application/vnd.kde.kontour": ["kon"], "application/vnd.kde.kpresenter": ["kpr", "kpt"], "application/vnd.kde.kspread": ["ksp"], "application/vnd.kde.kword": ["kwd", "kwt"], "application/vnd.kenameaapp": ["htke"], "application/vnd.kidspiration": ["kia"], "application/vnd.kinar": ["kne", "knp"], "application/vnd.koan": ["skp", "skd", "skt", "skm"], "application/vnd.kodak-descriptor": ["sse"], "application/vnd.las.las+xml": ["lasxml"], "application/vnd.llamagraphics.life-balance.desktop": ["lbd"], "application/vnd.llamagraphics.life-balance.exchange+xml": ["lbe"], "application/vnd.lotus-1-2-3": ["123"], "application/vnd.lotus-approach": ["apr"], "application/vnd.lotus-freelance": ["pre"], "application/vnd.lotus-notes": ["nsf"], "application/vnd.lotus-organizer": ["org"], "application/vnd.lotus-screencam": ["scm"], "application/vnd.lotus-wordpro": ["lwp"], "application/vnd.macports.portpkg": ["portpkg"], "application/vnd.mapbox-vector-tile": ["mvt"], "application/vnd.mcd": ["mcd"], "application/vnd.medcalcdata": ["mc1"], "application/vnd.mediastation.cdkey": ["cdkey"], "application/vnd.mfer": ["mwf"], "application/vnd.mfmp": ["mfm"], "application/vnd.micrografx.flo": ["flo"], "application/vnd.micrografx.igx": ["igx"], "application/vnd.mif": ["mif"], "application/vnd.mobius.daf": ["daf"], "application/vnd.mobius.dis": ["dis"], "application/vnd.mobius.mbk": ["mbk"], "application/vnd.mobius.mqy": ["mqy"], "application/vnd.mobius.msl": ["msl"], "application/vnd.mobius.plc": ["plc"], "application/vnd.mobius.txf": ["txf"], "application/vnd.mophun.application": ["mpn"], "application/vnd.mophun.certificate": ["mpc"], "application/vnd.mozilla.xul+xml": ["xul"], "application/vnd.ms-artgalry": ["cil"], "application/vnd.ms-cab-compressed": ["cab"], "application/vnd.ms-excel": ["xls", "xlm", "xla", "xlc", "xlt", "xlw"], "application/vnd.ms-excel.addin.macroenabled.12": ["xlam"], "application/vnd.ms-excel.sheet.binary.macroenabled.12": ["xlsb"], "application/vnd.ms-excel.sheet.macroenabled.12": ["xlsm"], "application/vnd.ms-excel.template.macroenabled.12": ["xltm"], "application/vnd.ms-fontobject": ["eot"], "application/vnd.ms-htmlhelp": ["chm"], "application/vnd.ms-ims": ["ims"], "application/vnd.ms-lrm": ["lrm"], "application/vnd.ms-officetheme": ["thmx"], "application/vnd.ms-outlook": ["msg"], "application/vnd.ms-pki.seccat": ["cat"], "application/vnd.ms-pki.stl": ["*stl"], "application/vnd.ms-powerpoint": ["ppt", "pps", "pot"], "application/vnd.ms-powerpoint.addin.macroenabled.12": ["ppam"], "application/vnd.ms-powerpoint.presentation.macroenabled.12": ["pptm"], "application/vnd.ms-powerpoint.slide.macroenabled.12": ["sldm"], "application/vnd.ms-powerpoint.slideshow.macroenabled.12": ["ppsm"], "application/vnd.ms-powerpoint.template.macroenabled.12": ["potm"], "application/vnd.ms-project": ["mpp", "mpt"], "application/vnd.ms-word.document.macroenabled.12": ["docm"], "application/vnd.ms-word.template.macroenabled.12": ["dotm"], "application/vnd.ms-works": ["wps", "wks", "wcm", "wdb"], "application/vnd.ms-wpl": ["wpl"], "application/vnd.ms-xpsdocument": ["xps"], "application/vnd.mseq": ["mseq"], "application/vnd.musician": ["mus"], "application/vnd.muvee.style": ["msty"], "application/vnd.mynfc": ["taglet"], "application/vnd.neurolanguage.nlu": ["nlu"], "application/vnd.nitf": ["ntf", "nitf"], "application/vnd.noblenet-directory": ["nnd"], "application/vnd.noblenet-sealer": ["nns"], "application/vnd.noblenet-web": ["nnw"], "application/vnd.nokia.n-gage.ac+xml": ["*ac"], "application/vnd.nokia.n-gage.data": ["ngdat"], "application/vnd.nokia.n-gage.symbian.install": ["n-gage"], "application/vnd.nokia.radio-preset": ["rpst"], "application/vnd.nokia.radio-presets": ["rpss"], "application/vnd.novadigm.edm": ["edm"], "application/vnd.novadigm.edx": ["edx"], "application/vnd.novadigm.ext": ["ext"], "application/vnd.oasis.opendocument.chart": ["odc"], "application/vnd.oasis.opendocument.chart-template": ["otc"], "application/vnd.oasis.opendocument.database": ["odb"], "application/vnd.oasis.opendocument.formula": ["odf"], "application/vnd.oasis.opendocument.formula-template": ["odft"], "application/vnd.oasis.opendocument.graphics": ["odg"], "application/vnd.oasis.opendocument.graphics-template": ["otg"], "application/vnd.oasis.opendocument.image": ["odi"], "application/vnd.oasis.opendocument.image-template": ["oti"], "application/vnd.oasis.opendocument.presentation": ["odp"], "application/vnd.oasis.opendocument.presentation-template": ["otp"], "application/vnd.oasis.opendocument.spreadsheet": ["ods"], "application/vnd.oasis.opendocument.spreadsheet-template": ["ots"], "application/vnd.oasis.opendocument.text": ["odt"], "application/vnd.oasis.opendocument.text-master": ["odm"], "application/vnd.oasis.opendocument.text-template": ["ott"], "application/vnd.oasis.opendocument.text-web": ["oth"], "application/vnd.olpc-sugar": ["xo"], "application/vnd.oma.dd2+xml": ["dd2"], "application/vnd.openblox.game+xml": ["obgx"], "application/vnd.openofficeorg.extension": ["oxt"], "application/vnd.openstreetmap.data+xml": ["osm"], "application/vnd.openxmlformats-officedocument.presentationml.presentation": ["pptx"], "application/vnd.openxmlformats-officedocument.presentationml.slide": ["sldx"], "application/vnd.openxmlformats-officedocument.presentationml.slideshow": ["ppsx"], "application/vnd.openxmlformats-officedocument.presentationml.template": ["potx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": ["xlsx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.template": ["xltx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.document": ["docx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.template": ["dotx"], "application/vnd.osgeo.mapguide.package": ["mgp"], "application/vnd.osgi.dp": ["dp"], "application/vnd.osgi.subsystem": ["esa"], "application/vnd.palm": ["pdb", "pqa", "oprc"], "application/vnd.pawaafile": ["paw"], "application/vnd.pg.format": ["str"], "application/vnd.pg.osasli": ["ei6"], "application/vnd.picsel": ["efif"], "application/vnd.pmi.widget": ["wg"], "application/vnd.pocketlearn": ["plf"], "application/vnd.powerbuilder6": ["pbd"], "application/vnd.previewsystems.box": ["box"], "application/vnd.proteus.magazine": ["mgz"], "application/vnd.publishare-delta-tree": ["qps"], "application/vnd.pvi.ptid1": ["ptid"], "application/vnd.quark.quarkxpress": ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"], "application/vnd.rar": ["rar"], "application/vnd.realvnc.bed": ["bed"], "application/vnd.recordare.musicxml": ["mxl"], "application/vnd.recordare.musicxml+xml": ["musicxml"], "application/vnd.rig.cryptonote": ["cryptonote"], "application/vnd.rim.cod": ["cod"], "application/vnd.rn-realmedia": ["rm"], "application/vnd.rn-realmedia-vbr": ["rmvb"], "application/vnd.route66.link66+xml": ["link66"], "application/vnd.sailingtracker.track": ["st"], "application/vnd.seemail": ["see"], "application/vnd.sema": ["sema"], "application/vnd.semd": ["semd"], "application/vnd.semf": ["semf"], "application/vnd.shana.informed.formdata": ["ifm"], "application/vnd.shana.informed.formtemplate": ["itp"], "application/vnd.shana.informed.interchange": ["iif"], "application/vnd.shana.informed.package": ["ipk"], "application/vnd.simtech-mindmapper": ["twd", "twds"], "application/vnd.smaf": ["mmf"], "application/vnd.smart.teacher": ["teacher"], "application/vnd.software602.filler.form+xml": ["fo"], "application/vnd.solent.sdkm+xml": ["sdkm", "sdkd"], "application/vnd.spotfire.dxp": ["dxp"], "application/vnd.spotfire.sfs": ["sfs"], "application/vnd.stardivision.calc": ["sdc"], "application/vnd.stardivision.draw": ["sda"], "application/vnd.stardivision.impress": ["sdd"], "application/vnd.stardivision.math": ["smf"], "application/vnd.stardivision.writer": ["sdw", "vor"], "application/vnd.stardivision.writer-global": ["sgl"], "application/vnd.stepmania.package": ["smzip"], "application/vnd.stepmania.stepchart": ["sm"], "application/vnd.sun.wadl+xml": ["wadl"], "application/vnd.sun.xml.calc": ["sxc"], "application/vnd.sun.xml.calc.template": ["stc"], "application/vnd.sun.xml.draw": ["sxd"], "application/vnd.sun.xml.draw.template": ["std"], "application/vnd.sun.xml.impress": ["sxi"], "application/vnd.sun.xml.impress.template": ["sti"], "application/vnd.sun.xml.math": ["sxm"], "application/vnd.sun.xml.writer": ["sxw"], "application/vnd.sun.xml.writer.global": ["sxg"], "application/vnd.sun.xml.writer.template": ["stw"], "application/vnd.sus-calendar": ["sus", "susp"], "application/vnd.svd": ["svd"], "application/vnd.symbian.install": ["sis", "sisx"], "application/vnd.syncml+xml": ["xsm"], "application/vnd.syncml.dm+wbxml": ["bdm"], "application/vnd.syncml.dm+xml": ["xdm"], "application/vnd.syncml.dmddf+xml": ["ddf"], "application/vnd.tao.intent-module-archive": ["tao"], "application/vnd.tcpdump.pcap": ["pcap", "cap", "dmp"], "application/vnd.tmobile-livetv": ["tmo"], "application/vnd.trid.tpt": ["tpt"], "application/vnd.triscape.mxs": ["mxs"], "application/vnd.trueapp": ["tra"], "application/vnd.ufdl": ["ufd", "ufdl"], "application/vnd.uiq.theme": ["utz"], "application/vnd.umajin": ["umj"], "application/vnd.unity": ["unityweb"], "application/vnd.uoml+xml": ["uoml"], "application/vnd.vcx": ["vcx"], "application/vnd.visio": ["vsd", "vst", "vss", "vsw"], "application/vnd.visionary": ["vis"], "application/vnd.vsf": ["vsf"], "application/vnd.wap.wbxml": ["wbxml"], "application/vnd.wap.wmlc": ["wmlc"], "application/vnd.wap.wmlscriptc": ["wmlsc"], "application/vnd.webturbo": ["wtb"], "application/vnd.wolfram.player": ["nbp"], "application/vnd.wordperfect": ["wpd"], "application/vnd.wqd": ["wqd"], "application/vnd.wt.stf": ["stf"], "application/vnd.xara": ["xar"], "application/vnd.xfdl": ["xfdl"], "application/vnd.yamaha.hv-dic": ["hvd"], "application/vnd.yamaha.hv-script": ["hvs"], "application/vnd.yamaha.hv-voice": ["hvp"], "application/vnd.yamaha.openscoreformat": ["osf"], "application/vnd.yamaha.openscoreformat.osfpvg+xml": ["osfpvg"], "application/vnd.yamaha.smaf-audio": ["saf"], "application/vnd.yamaha.smaf-phrase": ["spf"], "application/vnd.yellowriver-custom-menu": ["cmp"], "application/vnd.zul": ["zir", "zirz"], "application/vnd.zzazz.deck+xml": ["zaz"], "application/x-7z-compressed": ["7z"], "application/x-abiword": ["abw"], "application/x-ace-compressed": ["ace"], "application/x-apple-diskimage": ["*dmg"], "application/x-arj": ["arj"], "application/x-authorware-bin": ["aab", "x32", "u32", "vox"], "application/x-authorware-map": ["aam"], "application/x-authorware-seg": ["aas"], "application/x-bcpio": ["bcpio"], "application/x-bdoc": ["*bdoc"], "application/x-bittorrent": ["torrent"], "application/x-blorb": ["blb", "blorb"], "application/x-bzip": ["bz"], "application/x-bzip2": ["bz2", "boz"], "application/x-cbr": ["cbr", "cba", "cbt", "cbz", "cb7"], "application/x-cdlink": ["vcd"], "application/x-cfs-compressed": ["cfs"], "application/x-chat": ["chat"], "application/x-chess-pgn": ["pgn"], "application/x-chrome-extension": ["crx"], "application/x-cocoa": ["cco"], "application/x-conference": ["nsc"], "application/x-cpio": ["cpio"], "application/x-csh": ["csh"], "application/x-debian-package": ["*deb", "udeb"], "application/x-dgc-compressed": ["dgc"], "application/x-director": ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"], "application/x-doom": ["wad"], "application/x-dtbncx+xml": ["ncx"], "application/x-dtbook+xml": ["dtb"], "application/x-dtbresource+xml": ["res"], "application/x-dvi": ["dvi"], "application/x-envoy": ["evy"], "application/x-eva": ["eva"], "application/x-font-bdf": ["bdf"], "application/x-font-ghostscript": ["gsf"], "application/x-font-linux-psf": ["psf"], "application/x-font-pcf": ["pcf"], "application/x-font-snf": ["snf"], "application/x-font-type1": ["pfa", "pfb", "pfm", "afm"], "application/x-freearc": ["arc"], "application/x-futuresplash": ["spl"], "application/x-gca-compressed": ["gca"], "application/x-glulx": ["ulx"], "application/x-gnumeric": ["gnumeric"], "application/x-gramps-xml": ["gramps"], "application/x-gtar": ["gtar"], "application/x-hdf": ["hdf"], "application/x-httpd-php": ["php"], "application/x-install-instructions": ["install"], "application/x-iso9660-image": ["*iso"], "application/x-iwork-keynote-sffkey": ["*key"], "application/x-iwork-numbers-sffnumbers": ["*numbers"], "application/x-iwork-pages-sffpages": ["*pages"], "application/x-java-archive-diff": ["jardiff"], "application/x-java-jnlp-file": ["jnlp"], "application/x-keepass2": ["kdbx"], "application/x-latex": ["latex"], "application/x-lua-bytecode": ["luac"], "application/x-lzh-compressed": ["lzh", "lha"], "application/x-makeself": ["run"], "application/x-mie": ["mie"], "application/x-mobipocket-ebook": ["prc", "mobi"], "application/x-ms-application": ["application"], "application/x-ms-shortcut": ["lnk"], "application/x-ms-wmd": ["wmd"], "application/x-ms-wmz": ["wmz"], "application/x-ms-xbap": ["xbap"], "application/x-msaccess": ["mdb"], "application/x-msbinder": ["obd"], "application/x-mscardfile": ["crd"], "application/x-msclip": ["clp"], "application/x-msdos-program": ["*exe"], "application/x-msdownload": ["*exe", "*dll", "com", "bat", "*msi"], "application/x-msmediaview": ["mvb", "m13", "m14"], "application/x-msmetafile": ["*wmf", "*wmz", "*emf", "emz"], "application/x-msmoney": ["mny"], "application/x-mspublisher": ["pub"], "application/x-msschedule": ["scd"], "application/x-msterminal": ["trm"], "application/x-mswrite": ["wri"], "application/x-netcdf": ["nc", "cdf"], "application/x-ns-proxy-autoconfig": ["pac"], "application/x-nzb": ["nzb"], "application/x-perl": ["pl", "pm"], "application/x-pilot": ["*prc", "*pdb"], "application/x-pkcs12": ["p12", "pfx"], "application/x-pkcs7-certificates": ["p7b", "spc"], "application/x-pkcs7-certreqresp": ["p7r"], "application/x-rar-compressed": ["*rar"], "application/x-redhat-package-manager": ["rpm"], "application/x-research-info-systems": ["ris"], "application/x-sea": ["sea"], "application/x-sh": ["sh"], "application/x-shar": ["shar"], "application/x-shockwave-flash": ["swf"], "application/x-silverlight-app": ["xap"], "application/x-sql": ["sql"], "application/x-stuffit": ["sit"], "application/x-stuffitx": ["sitx"], "application/x-subrip": ["srt"], "application/x-sv4cpio": ["sv4cpio"], "application/x-sv4crc": ["sv4crc"], "application/x-t3vm-image": ["t3"], "application/x-tads": ["gam"], "application/x-tar": ["tar"], "application/x-tcl": ["tcl", "tk"], "application/x-tex": ["tex"], "application/x-tex-tfm": ["tfm"], "application/x-texinfo": ["texinfo", "texi"], "application/x-tgif": ["*obj"], "application/x-ustar": ["ustar"], "application/x-virtualbox-hdd": ["hdd"], "application/x-virtualbox-ova": ["ova"], "application/x-virtualbox-ovf": ["ovf"], "application/x-virtualbox-vbox": ["vbox"], "application/x-virtualbox-vbox-extpack": ["vbox-extpack"], "application/x-virtualbox-vdi": ["vdi"], "application/x-virtualbox-vhd": ["vhd"], "application/x-virtualbox-vmdk": ["vmdk"], "application/x-wais-source": ["src"], "application/x-web-app-manifest+json": ["webapp"], "application/x-x509-ca-cert": ["der", "crt", "pem"], "application/x-xfig": ["fig"], "application/x-xliff+xml": ["*xlf"], "application/x-xpinstall": ["xpi"], "application/x-xz": ["xz"], "application/x-zmachine": ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"], "audio/vnd.dece.audio": ["uva", "uvva"], "audio/vnd.digital-winds": ["eol"], "audio/vnd.dra": ["dra"], "audio/vnd.dts": ["dts"], "audio/vnd.dts.hd": ["dtshd"], "audio/vnd.lucent.voice": ["lvp"], "audio/vnd.ms-playready.media.pya": ["pya"], "audio/vnd.nuera.ecelp4800": ["ecelp4800"], "audio/vnd.nuera.ecelp7470": ["ecelp7470"], "audio/vnd.nuera.ecelp9600": ["ecelp9600"], "audio/vnd.rip": ["rip"], "audio/x-aac": ["aac"], "audio/x-aiff": ["aif", "aiff", "aifc"], "audio/x-caf": ["caf"], "audio/x-flac": ["flac"], "audio/x-m4a": ["*m4a"], "audio/x-matroska": ["mka"], "audio/x-mpegurl": ["m3u"], "audio/x-ms-wax": ["wax"], "audio/x-ms-wma": ["wma"], "audio/x-pn-realaudio": ["ram", "ra"], "audio/x-pn-realaudio-plugin": ["rmp"], "audio/x-realaudio": ["*ra"], "audio/x-wav": ["*wav"], "chemical/x-cdx": ["cdx"], "chemical/x-cif": ["cif"], "chemical/x-cmdf": ["cmdf"], "chemical/x-cml": ["cml"], "chemical/x-csml": ["csml"], "chemical/x-xyz": ["xyz"], "image/prs.btif": ["btif"], "image/prs.pti": ["pti"], "image/vnd.adobe.photoshop": ["psd"], "image/vnd.airzip.accelerator.azv": ["azv"], "image/vnd.dece.graphic": ["uvi", "uvvi", "uvg", "uvvg"], "image/vnd.djvu": ["djvu", "djv"], "image/vnd.dvb.subtitle": ["*sub"], "image/vnd.dwg": ["dwg"], "image/vnd.dxf": ["dxf"], "image/vnd.fastbidsheet": ["fbs"], "image/vnd.fpx": ["fpx"], "image/vnd.fst": ["fst"], "image/vnd.fujixerox.edmics-mmr": ["mmr"], "image/vnd.fujixerox.edmics-rlc": ["rlc"], "image/vnd.microsoft.icon": ["ico"], "image/vnd.ms-dds": ["dds"], "image/vnd.ms-modi": ["mdi"], "image/vnd.ms-photo": ["wdp"], "image/vnd.net-fpx": ["npx"], "image/vnd.pco.b16": ["b16"], "image/vnd.tencent.tap": ["tap"], "image/vnd.valve.source.texture": ["vtf"], "image/vnd.wap.wbmp": ["wbmp"], "image/vnd.xiff": ["xif"], "image/vnd.zbrush.pcx": ["pcx"], "image/x-3ds": ["3ds"], "image/x-cmu-raster": ["ras"], "image/x-cmx": ["cmx"], "image/x-freehand": ["fh", "fhc", "fh4", "fh5", "fh7"], "image/x-icon": ["*ico"], "image/x-jng": ["jng"], "image/x-mrsid-image": ["sid"], "image/x-ms-bmp": ["*bmp"], "image/x-pcx": ["*pcx"], "image/x-pict": ["pic", "pct"], "image/x-portable-anymap": ["pnm"], "image/x-portable-bitmap": ["pbm"], "image/x-portable-graymap": ["pgm"], "image/x-portable-pixmap": ["ppm"], "image/x-rgb": ["rgb"], "image/x-tga": ["tga"], "image/x-xbitmap": ["xbm"], "image/x-xpixmap": ["xpm"], "image/x-xwindowdump": ["xwd"], "message/vnd.wfa.wsc": ["wsc"], "model/vnd.collada+xml": ["dae"], "model/vnd.dwf": ["dwf"], "model/vnd.gdl": ["gdl"], "model/vnd.gtw": ["gtw"], "model/vnd.mts": ["mts"], "model/vnd.opengex": ["ogex"], "model/vnd.parasolid.transmit.binary": ["x_b"], "model/vnd.parasolid.transmit.text": ["x_t"], "model/vnd.sap.vds": ["vds"], "model/vnd.usdz+zip": ["usdz"], "model/vnd.valve.source.compiled-map": ["bsp"], "model/vnd.vtu": ["vtu"], "text/prs.lines.tag": ["dsc"], "text/vnd.curl": ["curl"], "text/vnd.curl.dcurl": ["dcurl"], "text/vnd.curl.mcurl": ["mcurl"], "text/vnd.curl.scurl": ["scurl"], "text/vnd.dvb.subtitle": ["sub"], "text/vnd.fly": ["fly"], "text/vnd.fmi.flexstor": ["flx"], "text/vnd.graphviz": ["gv"], "text/vnd.in3d.3dml": ["3dml"], "text/vnd.in3d.spot": ["spot"], "text/vnd.sun.j2me.app-descriptor": ["jad"], "text/vnd.wap.wml": ["wml"], "text/vnd.wap.wmlscript": ["wmls"], "text/x-asm": ["s", "asm"], "text/x-c": ["c", "cc", "cxx", "cpp", "h", "hh", "dic"], "text/x-component": ["htc"], "text/x-fortran": ["f", "for", "f77", "f90"], "text/x-handlebars-template": ["hbs"], "text/x-java-source": ["java"], "text/x-lua": ["lua"], "text/x-markdown": ["mkd"], "text/x-nfo": ["nfo"], "text/x-opml": ["opml"], "text/x-org": ["*org"], "text/x-pascal": ["p", "pas"], "text/x-processing": ["pde"], "text/x-sass": ["sass"], "text/x-scss": ["scss"], "text/x-setext": ["etx"], "text/x-sfv": ["sfv"], "text/x-suse-ymp": ["ymp"], "text/x-uuencode": ["uu"], "text/x-vcalendar": ["vcs"], "text/x-vcard": ["vcf"], "video/vnd.dece.hd": ["uvh", "uvvh"], "video/vnd.dece.mobile": ["uvm", "uvvm"], "video/vnd.dece.pd": ["uvp", "uvvp"], "video/vnd.dece.sd": ["uvs", "uvvs"], "video/vnd.dece.video": ["uvv", "uvvv"], "video/vnd.dvb.file": ["dvb"], "video/vnd.fvt": ["fvt"], "video/vnd.mpegurl": ["mxu", "m4u"], "video/vnd.ms-playready.media.pyv": ["pyv"], "video/vnd.uvvu.mp4": ["uvu", "uvvu"], "video/vnd.vivo": ["viv"], "video/x-f4v": ["f4v"], "video/x-fli": ["fli"], "video/x-flv": ["flv"], "video/x-m4v": ["m4v"], "video/x-matroska": ["mkv", "mk3d", "mks"], "video/x-mng": ["mng"], "video/x-ms-asf": ["asf", "asx"], "video/x-ms-vob": ["vob"], "video/x-ms-wm": ["wm"], "video/x-ms-wmv": ["wmv"], "video/x-ms-wmx": ["wmx"], "video/x-ms-wvx": ["wvx"], "video/x-msvideo": ["avi"], "video/x-sgi-movie": ["movie"], "video/x-smv": ["smv"], "x-conference/x-cooltalk": ["ice"] };
    }
  });

  // node_modules/mime/index.js
  var require_mime = __commonJS({
    "node_modules/mime/index.js"(exports2, module2) {
      "use strict";
      var Mime = require_Mime();
      module2.exports = new Mime(require_standard(), require_other());
    }
  });

  // node_modules/methods/index.js
  var require_methods = __commonJS({
    "node_modules/methods/index.js"(exports2, module2) {
      "use strict";
      var http = __require("http");
      module2.exports = getCurrentNodeMethods() || getBasicNodeMethods();
      function getCurrentNodeMethods() {
        return http.METHODS && http.METHODS.map(function lowerCaseMethod(method2) {
          return method2.toLowerCase();
        });
      }
      function getBasicNodeMethods() {
        return [
          "get",
          "post",
          "put",
          "head",
          "delete",
          "options",
          "trace",
          "copy",
          "lock",
          "mkcol",
          "move",
          "purge",
          "propfind",
          "proppatch",
          "unlock",
          "report",
          "mkactivity",
          "checkout",
          "merge",
          "m-search",
          "notify",
          "subscribe",
          "unsubscribe",
          "patch",
          "search",
          "connect"
        ];
      }
    }
  });

  // node_modules/delayed-stream/lib/delayed_stream.js
  var require_delayed_stream = __commonJS({
    "node_modules/delayed-stream/lib/delayed_stream.js"(exports2, module2) {
      var Stream = __require("stream").Stream;
      var util = __require("util");
      module2.exports = DelayedStream;
      function DelayedStream() {
        this.source = null;
        this.dataSize = 0;
        this.maxDataSize = 1024 * 1024;
        this.pauseStream = true;
        this._maxDataSizeExceeded = false;
        this._released = false;
        this._bufferedEvents = [];
      }
      util.inherits(DelayedStream, Stream);
      DelayedStream.create = function(source, options) {
        var delayedStream = new this();
        options = options || {};
        for (var option in options) {
          delayedStream[option] = options[option];
        }
        delayedStream.source = source;
        var realEmit = source.emit;
        source.emit = function() {
          delayedStream._handleEmit(arguments);
          return realEmit.apply(source, arguments);
        };
        source.on("error", function() {
        });
        if (delayedStream.pauseStream) {
          source.pause();
        }
        return delayedStream;
      };
      Object.defineProperty(DelayedStream.prototype, "readable", {
        configurable: true,
        enumerable: true,
        get: function() {
          return this.source.readable;
        }
      });
      DelayedStream.prototype.setEncoding = function() {
        return this.source.setEncoding.apply(this.source, arguments);
      };
      DelayedStream.prototype.resume = function() {
        if (!this._released) {
          this.release();
        }
        this.source.resume();
      };
      DelayedStream.prototype.pause = function() {
        this.source.pause();
      };
      DelayedStream.prototype.release = function() {
        this._released = true;
        this._bufferedEvents.forEach(function(args) {
          this.emit.apply(this, args);
        }.bind(this));
        this._bufferedEvents = [];
      };
      DelayedStream.prototype.pipe = function() {
        var r = Stream.prototype.pipe.apply(this, arguments);
        this.resume();
        return r;
      };
      DelayedStream.prototype._handleEmit = function(args) {
        if (this._released) {
          this.emit.apply(this, args);
          return;
        }
        if (args[0] === "data") {
          this.dataSize += args[1].length;
          this._checkIfMaxDataSizeExceeded();
        }
        this._bufferedEvents.push(args);
      };
      DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
        if (this._maxDataSizeExceeded) {
          return;
        }
        if (this.dataSize <= this.maxDataSize) {
          return;
        }
        this._maxDataSizeExceeded = true;
        var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
        this.emit("error", new Error(message));
      };
    }
  });

  // node_modules/combined-stream/lib/combined_stream.js
  var require_combined_stream = __commonJS({
    "node_modules/combined-stream/lib/combined_stream.js"(exports2, module2) {
      var util = __require("util");
      var Stream = __require("stream").Stream;
      var DelayedStream = require_delayed_stream();
      module2.exports = CombinedStream;
      function CombinedStream() {
        this.writable = false;
        this.readable = true;
        this.dataSize = 0;
        this.maxDataSize = 2 * 1024 * 1024;
        this.pauseStreams = true;
        this._released = false;
        this._streams = [];
        this._currentStream = null;
        this._insideLoop = false;
        this._pendingNext = false;
      }
      util.inherits(CombinedStream, Stream);
      CombinedStream.create = function(options) {
        var combinedStream = new this();
        options = options || {};
        for (var option in options) {
          combinedStream[option] = options[option];
        }
        return combinedStream;
      };
      CombinedStream.isStreamLike = function(stream) {
        return typeof stream !== "function" && typeof stream !== "string" && typeof stream !== "boolean" && typeof stream !== "number" && !Buffer.isBuffer(stream);
      };
      CombinedStream.prototype.append = function(stream) {
        var isStreamLike = CombinedStream.isStreamLike(stream);
        if (isStreamLike) {
          if (!(stream instanceof DelayedStream)) {
            var newStream = DelayedStream.create(stream, {
              maxDataSize: Infinity,
              pauseStream: this.pauseStreams
            });
            stream.on("data", this._checkDataSize.bind(this));
            stream = newStream;
          }
          this._handleErrors(stream);
          if (this.pauseStreams) {
            stream.pause();
          }
        }
        this._streams.push(stream);
        return this;
      };
      CombinedStream.prototype.pipe = function(dest, options) {
        Stream.prototype.pipe.call(this, dest, options);
        this.resume();
        return dest;
      };
      CombinedStream.prototype._getNext = function() {
        this._currentStream = null;
        if (this._insideLoop) {
          this._pendingNext = true;
          return;
        }
        this._insideLoop = true;
        try {
          do {
            this._pendingNext = false;
            this._realGetNext();
          } while (this._pendingNext);
        } finally {
          this._insideLoop = false;
        }
      };
      CombinedStream.prototype._realGetNext = function() {
        var stream = this._streams.shift();
        if (typeof stream == "undefined") {
          this.end();
          return;
        }
        if (typeof stream !== "function") {
          this._pipeNext(stream);
          return;
        }
        var getStream = stream;
        getStream(function(stream2) {
          var isStreamLike = CombinedStream.isStreamLike(stream2);
          if (isStreamLike) {
            stream2.on("data", this._checkDataSize.bind(this));
            this._handleErrors(stream2);
          }
          this._pipeNext(stream2);
        }.bind(this));
      };
      CombinedStream.prototype._pipeNext = function(stream) {
        this._currentStream = stream;
        var isStreamLike = CombinedStream.isStreamLike(stream);
        if (isStreamLike) {
          stream.on("end", this._getNext.bind(this));
          stream.pipe(this, { end: false });
          return;
        }
        var value = stream;
        this.write(value);
        this._getNext();
      };
      CombinedStream.prototype._handleErrors = function(stream) {
        var self2 = this;
        stream.on("error", function(err) {
          self2._emitError(err);
        });
      };
      CombinedStream.prototype.write = function(data) {
        this.emit("data", data);
      };
      CombinedStream.prototype.pause = function() {
        if (!this.pauseStreams) {
          return;
        }
        if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function")
          this._currentStream.pause();
        this.emit("pause");
      };
      CombinedStream.prototype.resume = function() {
        if (!this._released) {
          this._released = true;
          this.writable = true;
          this._getNext();
        }
        if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function")
          this._currentStream.resume();
        this.emit("resume");
      };
      CombinedStream.prototype.end = function() {
        this._reset();
        this.emit("end");
      };
      CombinedStream.prototype.destroy = function() {
        this._reset();
        this.emit("close");
      };
      CombinedStream.prototype._reset = function() {
        this.writable = false;
        this._streams = [];
        this._currentStream = null;
      };
      CombinedStream.prototype._checkDataSize = function() {
        this._updateDataSize();
        if (this.dataSize <= this.maxDataSize) {
          return;
        }
        var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
        this._emitError(new Error(message));
      };
      CombinedStream.prototype._updateDataSize = function() {
        this.dataSize = 0;
        var self2 = this;
        this._streams.forEach(function(stream) {
          if (!stream.dataSize) {
            return;
          }
          self2.dataSize += stream.dataSize;
        });
        if (this._currentStream && this._currentStream.dataSize) {
          this.dataSize += this._currentStream.dataSize;
        }
      };
      CombinedStream.prototype._emitError = function(err) {
        this._reset();
        this.emit("error", err);
      };
    }
  });

  // node_modules/mime-db/db.json
  var require_db = __commonJS({
    "node_modules/mime-db/db.json"(exports2, module2) {
      module2.exports = {
        "application/1d-interleaved-parityfec": {
          source: "iana"
        },
        "application/3gpdash-qoe-report+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/3gpp-ims+xml": {
          source: "iana",
          compressible: true
        },
        "application/3gpphal+json": {
          source: "iana",
          compressible: true
        },
        "application/3gpphalforms+json": {
          source: "iana",
          compressible: true
        },
        "application/a2l": {
          source: "iana"
        },
        "application/ace+cbor": {
          source: "iana"
        },
        "application/activemessage": {
          source: "iana"
        },
        "application/activity+json": {
          source: "iana",
          compressible: true
        },
        "application/alto-costmap+json": {
          source: "iana",
          compressible: true
        },
        "application/alto-costmapfilter+json": {
          source: "iana",
          compressible: true
        },
        "application/alto-directory+json": {
          source: "iana",
          compressible: true
        },
        "application/alto-endpointcost+json": {
          source: "iana",
          compressible: true
        },
        "application/alto-endpointcostparams+json": {
          source: "iana",
          compressible: true
        },
        "application/alto-endpointprop+json": {
          source: "iana",
          compressible: true
        },
        "application/alto-endpointpropparams+json": {
          source: "iana",
          compressible: true
        },
        "application/alto-error+json": {
          source: "iana",
          compressible: true
        },
        "application/alto-networkmap+json": {
          source: "iana",
          compressible: true
        },
        "application/alto-networkmapfilter+json": {
          source: "iana",
          compressible: true
        },
        "application/alto-updatestreamcontrol+json": {
          source: "iana",
          compressible: true
        },
        "application/alto-updatestreamparams+json": {
          source: "iana",
          compressible: true
        },
        "application/aml": {
          source: "iana"
        },
        "application/andrew-inset": {
          source: "iana",
          extensions: ["ez"]
        },
        "application/applefile": {
          source: "iana"
        },
        "application/applixware": {
          source: "apache",
          extensions: ["aw"]
        },
        "application/at+jwt": {
          source: "iana"
        },
        "application/atf": {
          source: "iana"
        },
        "application/atfx": {
          source: "iana"
        },
        "application/atom+xml": {
          source: "iana",
          compressible: true,
          extensions: ["atom"]
        },
        "application/atomcat+xml": {
          source: "iana",
          compressible: true,
          extensions: ["atomcat"]
        },
        "application/atomdeleted+xml": {
          source: "iana",
          compressible: true,
          extensions: ["atomdeleted"]
        },
        "application/atomicmail": {
          source: "iana"
        },
        "application/atomsvc+xml": {
          source: "iana",
          compressible: true,
          extensions: ["atomsvc"]
        },
        "application/atsc-dwd+xml": {
          source: "iana",
          compressible: true,
          extensions: ["dwd"]
        },
        "application/atsc-dynamic-event-message": {
          source: "iana"
        },
        "application/atsc-held+xml": {
          source: "iana",
          compressible: true,
          extensions: ["held"]
        },
        "application/atsc-rdt+json": {
          source: "iana",
          compressible: true
        },
        "application/atsc-rsat+xml": {
          source: "iana",
          compressible: true,
          extensions: ["rsat"]
        },
        "application/atxml": {
          source: "iana"
        },
        "application/auth-policy+xml": {
          source: "iana",
          compressible: true
        },
        "application/bacnet-xdd+zip": {
          source: "iana",
          compressible: false
        },
        "application/batch-smtp": {
          source: "iana"
        },
        "application/bdoc": {
          compressible: false,
          extensions: ["bdoc"]
        },
        "application/beep+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/calendar+json": {
          source: "iana",
          compressible: true
        },
        "application/calendar+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xcs"]
        },
        "application/call-completion": {
          source: "iana"
        },
        "application/cals-1840": {
          source: "iana"
        },
        "application/captive+json": {
          source: "iana",
          compressible: true
        },
        "application/cbor": {
          source: "iana"
        },
        "application/cbor-seq": {
          source: "iana"
        },
        "application/cccex": {
          source: "iana"
        },
        "application/ccmp+xml": {
          source: "iana",
          compressible: true
        },
        "application/ccxml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["ccxml"]
        },
        "application/cdfx+xml": {
          source: "iana",
          compressible: true,
          extensions: ["cdfx"]
        },
        "application/cdmi-capability": {
          source: "iana",
          extensions: ["cdmia"]
        },
        "application/cdmi-container": {
          source: "iana",
          extensions: ["cdmic"]
        },
        "application/cdmi-domain": {
          source: "iana",
          extensions: ["cdmid"]
        },
        "application/cdmi-object": {
          source: "iana",
          extensions: ["cdmio"]
        },
        "application/cdmi-queue": {
          source: "iana",
          extensions: ["cdmiq"]
        },
        "application/cdni": {
          source: "iana"
        },
        "application/cea": {
          source: "iana"
        },
        "application/cea-2018+xml": {
          source: "iana",
          compressible: true
        },
        "application/cellml+xml": {
          source: "iana",
          compressible: true
        },
        "application/cfw": {
          source: "iana"
        },
        "application/clr": {
          source: "iana"
        },
        "application/clue+xml": {
          source: "iana",
          compressible: true
        },
        "application/clue_info+xml": {
          source: "iana",
          compressible: true
        },
        "application/cms": {
          source: "iana"
        },
        "application/cnrp+xml": {
          source: "iana",
          compressible: true
        },
        "application/coap-group+json": {
          source: "iana",
          compressible: true
        },
        "application/coap-payload": {
          source: "iana"
        },
        "application/commonground": {
          source: "iana"
        },
        "application/conference-info+xml": {
          source: "iana",
          compressible: true
        },
        "application/cose": {
          source: "iana"
        },
        "application/cose-key": {
          source: "iana"
        },
        "application/cose-key-set": {
          source: "iana"
        },
        "application/cpl+xml": {
          source: "iana",
          compressible: true
        },
        "application/csrattrs": {
          source: "iana"
        },
        "application/csta+xml": {
          source: "iana",
          compressible: true
        },
        "application/cstadata+xml": {
          source: "iana",
          compressible: true
        },
        "application/csvm+json": {
          source: "iana",
          compressible: true
        },
        "application/cu-seeme": {
          source: "apache",
          extensions: ["cu"]
        },
        "application/cwt": {
          source: "iana"
        },
        "application/cybercash": {
          source: "iana"
        },
        "application/dart": {
          compressible: true
        },
        "application/dash+xml": {
          source: "iana",
          compressible: true,
          extensions: ["mpd"]
        },
        "application/dashdelta": {
          source: "iana"
        },
        "application/davmount+xml": {
          source: "iana",
          compressible: true,
          extensions: ["davmount"]
        },
        "application/dca-rft": {
          source: "iana"
        },
        "application/dcd": {
          source: "iana"
        },
        "application/dec-dx": {
          source: "iana"
        },
        "application/dialog-info+xml": {
          source: "iana",
          compressible: true
        },
        "application/dicom": {
          source: "iana"
        },
        "application/dicom+json": {
          source: "iana",
          compressible: true
        },
        "application/dicom+xml": {
          source: "iana",
          compressible: true
        },
        "application/dii": {
          source: "iana"
        },
        "application/dit": {
          source: "iana"
        },
        "application/dns": {
          source: "iana"
        },
        "application/dns+json": {
          source: "iana",
          compressible: true
        },
        "application/dns-message": {
          source: "iana"
        },
        "application/docbook+xml": {
          source: "apache",
          compressible: true,
          extensions: ["dbk"]
        },
        "application/dots+cbor": {
          source: "iana"
        },
        "application/dskpp+xml": {
          source: "iana",
          compressible: true
        },
        "application/dssc+der": {
          source: "iana",
          extensions: ["dssc"]
        },
        "application/dssc+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xdssc"]
        },
        "application/dvcs": {
          source: "iana"
        },
        "application/ecmascript": {
          source: "iana",
          compressible: true,
          extensions: ["es", "ecma"]
        },
        "application/edi-consent": {
          source: "iana"
        },
        "application/edi-x12": {
          source: "iana",
          compressible: false
        },
        "application/edifact": {
          source: "iana",
          compressible: false
        },
        "application/efi": {
          source: "iana"
        },
        "application/elm+json": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/elm+xml": {
          source: "iana",
          compressible: true
        },
        "application/emergencycalldata.cap+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/emergencycalldata.comment+xml": {
          source: "iana",
          compressible: true
        },
        "application/emergencycalldata.control+xml": {
          source: "iana",
          compressible: true
        },
        "application/emergencycalldata.deviceinfo+xml": {
          source: "iana",
          compressible: true
        },
        "application/emergencycalldata.ecall.msd": {
          source: "iana"
        },
        "application/emergencycalldata.providerinfo+xml": {
          source: "iana",
          compressible: true
        },
        "application/emergencycalldata.serviceinfo+xml": {
          source: "iana",
          compressible: true
        },
        "application/emergencycalldata.subscriberinfo+xml": {
          source: "iana",
          compressible: true
        },
        "application/emergencycalldata.veds+xml": {
          source: "iana",
          compressible: true
        },
        "application/emma+xml": {
          source: "iana",
          compressible: true,
          extensions: ["emma"]
        },
        "application/emotionml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["emotionml"]
        },
        "application/encaprtp": {
          source: "iana"
        },
        "application/epp+xml": {
          source: "iana",
          compressible: true
        },
        "application/epub+zip": {
          source: "iana",
          compressible: false,
          extensions: ["epub"]
        },
        "application/eshop": {
          source: "iana"
        },
        "application/exi": {
          source: "iana",
          extensions: ["exi"]
        },
        "application/expect-ct-report+json": {
          source: "iana",
          compressible: true
        },
        "application/express": {
          source: "iana",
          extensions: ["exp"]
        },
        "application/fastinfoset": {
          source: "iana"
        },
        "application/fastsoap": {
          source: "iana"
        },
        "application/fdt+xml": {
          source: "iana",
          compressible: true,
          extensions: ["fdt"]
        },
        "application/fhir+json": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/fhir+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/fido.trusted-apps+json": {
          compressible: true
        },
        "application/fits": {
          source: "iana"
        },
        "application/flexfec": {
          source: "iana"
        },
        "application/font-sfnt": {
          source: "iana"
        },
        "application/font-tdpfr": {
          source: "iana",
          extensions: ["pfr"]
        },
        "application/font-woff": {
          source: "iana",
          compressible: false
        },
        "application/framework-attributes+xml": {
          source: "iana",
          compressible: true
        },
        "application/geo+json": {
          source: "iana",
          compressible: true,
          extensions: ["geojson"]
        },
        "application/geo+json-seq": {
          source: "iana"
        },
        "application/geopackage+sqlite3": {
          source: "iana"
        },
        "application/geoxacml+xml": {
          source: "iana",
          compressible: true
        },
        "application/gltf-buffer": {
          source: "iana"
        },
        "application/gml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["gml"]
        },
        "application/gpx+xml": {
          source: "apache",
          compressible: true,
          extensions: ["gpx"]
        },
        "application/gxf": {
          source: "apache",
          extensions: ["gxf"]
        },
        "application/gzip": {
          source: "iana",
          compressible: false,
          extensions: ["gz"]
        },
        "application/h224": {
          source: "iana"
        },
        "application/held+xml": {
          source: "iana",
          compressible: true
        },
        "application/hjson": {
          extensions: ["hjson"]
        },
        "application/http": {
          source: "iana"
        },
        "application/hyperstudio": {
          source: "iana",
          extensions: ["stk"]
        },
        "application/ibe-key-request+xml": {
          source: "iana",
          compressible: true
        },
        "application/ibe-pkg-reply+xml": {
          source: "iana",
          compressible: true
        },
        "application/ibe-pp-data": {
          source: "iana"
        },
        "application/iges": {
          source: "iana"
        },
        "application/im-iscomposing+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/index": {
          source: "iana"
        },
        "application/index.cmd": {
          source: "iana"
        },
        "application/index.obj": {
          source: "iana"
        },
        "application/index.response": {
          source: "iana"
        },
        "application/index.vnd": {
          source: "iana"
        },
        "application/inkml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["ink", "inkml"]
        },
        "application/iotp": {
          source: "iana"
        },
        "application/ipfix": {
          source: "iana",
          extensions: ["ipfix"]
        },
        "application/ipp": {
          source: "iana"
        },
        "application/isup": {
          source: "iana"
        },
        "application/its+xml": {
          source: "iana",
          compressible: true,
          extensions: ["its"]
        },
        "application/java-archive": {
          source: "apache",
          compressible: false,
          extensions: ["jar", "war", "ear"]
        },
        "application/java-serialized-object": {
          source: "apache",
          compressible: false,
          extensions: ["ser"]
        },
        "application/java-vm": {
          source: "apache",
          compressible: false,
          extensions: ["class"]
        },
        "application/javascript": {
          source: "iana",
          charset: "UTF-8",
          compressible: true,
          extensions: ["js", "mjs"]
        },
        "application/jf2feed+json": {
          source: "iana",
          compressible: true
        },
        "application/jose": {
          source: "iana"
        },
        "application/jose+json": {
          source: "iana",
          compressible: true
        },
        "application/jrd+json": {
          source: "iana",
          compressible: true
        },
        "application/jscalendar+json": {
          source: "iana",
          compressible: true
        },
        "application/json": {
          source: "iana",
          charset: "UTF-8",
          compressible: true,
          extensions: ["json", "map"]
        },
        "application/json-patch+json": {
          source: "iana",
          compressible: true
        },
        "application/json-seq": {
          source: "iana"
        },
        "application/json5": {
          extensions: ["json5"]
        },
        "application/jsonml+json": {
          source: "apache",
          compressible: true,
          extensions: ["jsonml"]
        },
        "application/jwk+json": {
          source: "iana",
          compressible: true
        },
        "application/jwk-set+json": {
          source: "iana",
          compressible: true
        },
        "application/jwt": {
          source: "iana"
        },
        "application/kpml-request+xml": {
          source: "iana",
          compressible: true
        },
        "application/kpml-response+xml": {
          source: "iana",
          compressible: true
        },
        "application/ld+json": {
          source: "iana",
          compressible: true,
          extensions: ["jsonld"]
        },
        "application/lgr+xml": {
          source: "iana",
          compressible: true,
          extensions: ["lgr"]
        },
        "application/link-format": {
          source: "iana"
        },
        "application/load-control+xml": {
          source: "iana",
          compressible: true
        },
        "application/lost+xml": {
          source: "iana",
          compressible: true,
          extensions: ["lostxml"]
        },
        "application/lostsync+xml": {
          source: "iana",
          compressible: true
        },
        "application/lpf+zip": {
          source: "iana",
          compressible: false
        },
        "application/lxf": {
          source: "iana"
        },
        "application/mac-binhex40": {
          source: "iana",
          extensions: ["hqx"]
        },
        "application/mac-compactpro": {
          source: "apache",
          extensions: ["cpt"]
        },
        "application/macwriteii": {
          source: "iana"
        },
        "application/mads+xml": {
          source: "iana",
          compressible: true,
          extensions: ["mads"]
        },
        "application/manifest+json": {
          source: "iana",
          charset: "UTF-8",
          compressible: true,
          extensions: ["webmanifest"]
        },
        "application/marc": {
          source: "iana",
          extensions: ["mrc"]
        },
        "application/marcxml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["mrcx"]
        },
        "application/mathematica": {
          source: "iana",
          extensions: ["ma", "nb", "mb"]
        },
        "application/mathml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["mathml"]
        },
        "application/mathml-content+xml": {
          source: "iana",
          compressible: true
        },
        "application/mathml-presentation+xml": {
          source: "iana",
          compressible: true
        },
        "application/mbms-associated-procedure-description+xml": {
          source: "iana",
          compressible: true
        },
        "application/mbms-deregister+xml": {
          source: "iana",
          compressible: true
        },
        "application/mbms-envelope+xml": {
          source: "iana",
          compressible: true
        },
        "application/mbms-msk+xml": {
          source: "iana",
          compressible: true
        },
        "application/mbms-msk-response+xml": {
          source: "iana",
          compressible: true
        },
        "application/mbms-protection-description+xml": {
          source: "iana",
          compressible: true
        },
        "application/mbms-reception-report+xml": {
          source: "iana",
          compressible: true
        },
        "application/mbms-register+xml": {
          source: "iana",
          compressible: true
        },
        "application/mbms-register-response+xml": {
          source: "iana",
          compressible: true
        },
        "application/mbms-schedule+xml": {
          source: "iana",
          compressible: true
        },
        "application/mbms-user-service-description+xml": {
          source: "iana",
          compressible: true
        },
        "application/mbox": {
          source: "iana",
          extensions: ["mbox"]
        },
        "application/media-policy-dataset+xml": {
          source: "iana",
          compressible: true
        },
        "application/media_control+xml": {
          source: "iana",
          compressible: true
        },
        "application/mediaservercontrol+xml": {
          source: "iana",
          compressible: true,
          extensions: ["mscml"]
        },
        "application/merge-patch+json": {
          source: "iana",
          compressible: true
        },
        "application/metalink+xml": {
          source: "apache",
          compressible: true,
          extensions: ["metalink"]
        },
        "application/metalink4+xml": {
          source: "iana",
          compressible: true,
          extensions: ["meta4"]
        },
        "application/mets+xml": {
          source: "iana",
          compressible: true,
          extensions: ["mets"]
        },
        "application/mf4": {
          source: "iana"
        },
        "application/mikey": {
          source: "iana"
        },
        "application/mipc": {
          source: "iana"
        },
        "application/missing-blocks+cbor-seq": {
          source: "iana"
        },
        "application/mmt-aei+xml": {
          source: "iana",
          compressible: true,
          extensions: ["maei"]
        },
        "application/mmt-usd+xml": {
          source: "iana",
          compressible: true,
          extensions: ["musd"]
        },
        "application/mods+xml": {
          source: "iana",
          compressible: true,
          extensions: ["mods"]
        },
        "application/moss-keys": {
          source: "iana"
        },
        "application/moss-signature": {
          source: "iana"
        },
        "application/mosskey-data": {
          source: "iana"
        },
        "application/mosskey-request": {
          source: "iana"
        },
        "application/mp21": {
          source: "iana",
          extensions: ["m21", "mp21"]
        },
        "application/mp4": {
          source: "iana",
          extensions: ["mp4s", "m4p"]
        },
        "application/mpeg4-generic": {
          source: "iana"
        },
        "application/mpeg4-iod": {
          source: "iana"
        },
        "application/mpeg4-iod-xmt": {
          source: "iana"
        },
        "application/mrb-consumer+xml": {
          source: "iana",
          compressible: true
        },
        "application/mrb-publish+xml": {
          source: "iana",
          compressible: true
        },
        "application/msc-ivr+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/msc-mixer+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/msword": {
          source: "iana",
          compressible: false,
          extensions: ["doc", "dot"]
        },
        "application/mud+json": {
          source: "iana",
          compressible: true
        },
        "application/multipart-core": {
          source: "iana"
        },
        "application/mxf": {
          source: "iana",
          extensions: ["mxf"]
        },
        "application/n-quads": {
          source: "iana",
          extensions: ["nq"]
        },
        "application/n-triples": {
          source: "iana",
          extensions: ["nt"]
        },
        "application/nasdata": {
          source: "iana"
        },
        "application/news-checkgroups": {
          source: "iana",
          charset: "US-ASCII"
        },
        "application/news-groupinfo": {
          source: "iana",
          charset: "US-ASCII"
        },
        "application/news-transmission": {
          source: "iana"
        },
        "application/nlsml+xml": {
          source: "iana",
          compressible: true
        },
        "application/node": {
          source: "iana",
          extensions: ["cjs"]
        },
        "application/nss": {
          source: "iana"
        },
        "application/oauth-authz-req+jwt": {
          source: "iana"
        },
        "application/ocsp-request": {
          source: "iana"
        },
        "application/ocsp-response": {
          source: "iana"
        },
        "application/octet-stream": {
          source: "iana",
          compressible: false,
          extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
        },
        "application/oda": {
          source: "iana",
          extensions: ["oda"]
        },
        "application/odm+xml": {
          source: "iana",
          compressible: true
        },
        "application/odx": {
          source: "iana"
        },
        "application/oebps-package+xml": {
          source: "iana",
          compressible: true,
          extensions: ["opf"]
        },
        "application/ogg": {
          source: "iana",
          compressible: false,
          extensions: ["ogx"]
        },
        "application/omdoc+xml": {
          source: "apache",
          compressible: true,
          extensions: ["omdoc"]
        },
        "application/onenote": {
          source: "apache",
          extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
        },
        "application/opc-nodeset+xml": {
          source: "iana",
          compressible: true
        },
        "application/oscore": {
          source: "iana"
        },
        "application/oxps": {
          source: "iana",
          extensions: ["oxps"]
        },
        "application/p21": {
          source: "iana"
        },
        "application/p21+zip": {
          source: "iana",
          compressible: false
        },
        "application/p2p-overlay+xml": {
          source: "iana",
          compressible: true,
          extensions: ["relo"]
        },
        "application/parityfec": {
          source: "iana"
        },
        "application/passport": {
          source: "iana"
        },
        "application/patch-ops-error+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xer"]
        },
        "application/pdf": {
          source: "iana",
          compressible: false,
          extensions: ["pdf"]
        },
        "application/pdx": {
          source: "iana"
        },
        "application/pem-certificate-chain": {
          source: "iana"
        },
        "application/pgp-encrypted": {
          source: "iana",
          compressible: false,
          extensions: ["pgp"]
        },
        "application/pgp-keys": {
          source: "iana"
        },
        "application/pgp-signature": {
          source: "iana",
          extensions: ["asc", "sig"]
        },
        "application/pics-rules": {
          source: "apache",
          extensions: ["prf"]
        },
        "application/pidf+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/pidf-diff+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/pkcs10": {
          source: "iana",
          extensions: ["p10"]
        },
        "application/pkcs12": {
          source: "iana"
        },
        "application/pkcs7-mime": {
          source: "iana",
          extensions: ["p7m", "p7c"]
        },
        "application/pkcs7-signature": {
          source: "iana",
          extensions: ["p7s"]
        },
        "application/pkcs8": {
          source: "iana",
          extensions: ["p8"]
        },
        "application/pkcs8-encrypted": {
          source: "iana"
        },
        "application/pkix-attr-cert": {
          source: "iana",
          extensions: ["ac"]
        },
        "application/pkix-cert": {
          source: "iana",
          extensions: ["cer"]
        },
        "application/pkix-crl": {
          source: "iana",
          extensions: ["crl"]
        },
        "application/pkix-pkipath": {
          source: "iana",
          extensions: ["pkipath"]
        },
        "application/pkixcmp": {
          source: "iana",
          extensions: ["pki"]
        },
        "application/pls+xml": {
          source: "iana",
          compressible: true,
          extensions: ["pls"]
        },
        "application/poc-settings+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/postscript": {
          source: "iana",
          compressible: true,
          extensions: ["ai", "eps", "ps"]
        },
        "application/ppsp-tracker+json": {
          source: "iana",
          compressible: true
        },
        "application/problem+json": {
          source: "iana",
          compressible: true
        },
        "application/problem+xml": {
          source: "iana",
          compressible: true
        },
        "application/provenance+xml": {
          source: "iana",
          compressible: true,
          extensions: ["provx"]
        },
        "application/prs.alvestrand.titrax-sheet": {
          source: "iana"
        },
        "application/prs.cww": {
          source: "iana",
          extensions: ["cww"]
        },
        "application/prs.cyn": {
          source: "iana",
          charset: "7-BIT"
        },
        "application/prs.hpub+zip": {
          source: "iana",
          compressible: false
        },
        "application/prs.nprend": {
          source: "iana"
        },
        "application/prs.plucker": {
          source: "iana"
        },
        "application/prs.rdf-xml-crypt": {
          source: "iana"
        },
        "application/prs.xsf+xml": {
          source: "iana",
          compressible: true
        },
        "application/pskc+xml": {
          source: "iana",
          compressible: true,
          extensions: ["pskcxml"]
        },
        "application/pvd+json": {
          source: "iana",
          compressible: true
        },
        "application/qsig": {
          source: "iana"
        },
        "application/raml+yaml": {
          compressible: true,
          extensions: ["raml"]
        },
        "application/raptorfec": {
          source: "iana"
        },
        "application/rdap+json": {
          source: "iana",
          compressible: true
        },
        "application/rdf+xml": {
          source: "iana",
          compressible: true,
          extensions: ["rdf", "owl"]
        },
        "application/reginfo+xml": {
          source: "iana",
          compressible: true,
          extensions: ["rif"]
        },
        "application/relax-ng-compact-syntax": {
          source: "iana",
          extensions: ["rnc"]
        },
        "application/remote-printing": {
          source: "iana"
        },
        "application/reputon+json": {
          source: "iana",
          compressible: true
        },
        "application/resource-lists+xml": {
          source: "iana",
          compressible: true,
          extensions: ["rl"]
        },
        "application/resource-lists-diff+xml": {
          source: "iana",
          compressible: true,
          extensions: ["rld"]
        },
        "application/rfc+xml": {
          source: "iana",
          compressible: true
        },
        "application/riscos": {
          source: "iana"
        },
        "application/rlmi+xml": {
          source: "iana",
          compressible: true
        },
        "application/rls-services+xml": {
          source: "iana",
          compressible: true,
          extensions: ["rs"]
        },
        "application/route-apd+xml": {
          source: "iana",
          compressible: true,
          extensions: ["rapd"]
        },
        "application/route-s-tsid+xml": {
          source: "iana",
          compressible: true,
          extensions: ["sls"]
        },
        "application/route-usd+xml": {
          source: "iana",
          compressible: true,
          extensions: ["rusd"]
        },
        "application/rpki-ghostbusters": {
          source: "iana",
          extensions: ["gbr"]
        },
        "application/rpki-manifest": {
          source: "iana",
          extensions: ["mft"]
        },
        "application/rpki-publication": {
          source: "iana"
        },
        "application/rpki-roa": {
          source: "iana",
          extensions: ["roa"]
        },
        "application/rpki-updown": {
          source: "iana"
        },
        "application/rsd+xml": {
          source: "apache",
          compressible: true,
          extensions: ["rsd"]
        },
        "application/rss+xml": {
          source: "apache",
          compressible: true,
          extensions: ["rss"]
        },
        "application/rtf": {
          source: "iana",
          compressible: true,
          extensions: ["rtf"]
        },
        "application/rtploopback": {
          source: "iana"
        },
        "application/rtx": {
          source: "iana"
        },
        "application/samlassertion+xml": {
          source: "iana",
          compressible: true
        },
        "application/samlmetadata+xml": {
          source: "iana",
          compressible: true
        },
        "application/sarif+json": {
          source: "iana",
          compressible: true
        },
        "application/sarif-external-properties+json": {
          source: "iana",
          compressible: true
        },
        "application/sbe": {
          source: "iana"
        },
        "application/sbml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["sbml"]
        },
        "application/scaip+xml": {
          source: "iana",
          compressible: true
        },
        "application/scim+json": {
          source: "iana",
          compressible: true
        },
        "application/scvp-cv-request": {
          source: "iana",
          extensions: ["scq"]
        },
        "application/scvp-cv-response": {
          source: "iana",
          extensions: ["scs"]
        },
        "application/scvp-vp-request": {
          source: "iana",
          extensions: ["spq"]
        },
        "application/scvp-vp-response": {
          source: "iana",
          extensions: ["spp"]
        },
        "application/sdp": {
          source: "iana",
          extensions: ["sdp"]
        },
        "application/secevent+jwt": {
          source: "iana"
        },
        "application/senml+cbor": {
          source: "iana"
        },
        "application/senml+json": {
          source: "iana",
          compressible: true
        },
        "application/senml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["senmlx"]
        },
        "application/senml-etch+cbor": {
          source: "iana"
        },
        "application/senml-etch+json": {
          source: "iana",
          compressible: true
        },
        "application/senml-exi": {
          source: "iana"
        },
        "application/sensml+cbor": {
          source: "iana"
        },
        "application/sensml+json": {
          source: "iana",
          compressible: true
        },
        "application/sensml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["sensmlx"]
        },
        "application/sensml-exi": {
          source: "iana"
        },
        "application/sep+xml": {
          source: "iana",
          compressible: true
        },
        "application/sep-exi": {
          source: "iana"
        },
        "application/session-info": {
          source: "iana"
        },
        "application/set-payment": {
          source: "iana"
        },
        "application/set-payment-initiation": {
          source: "iana",
          extensions: ["setpay"]
        },
        "application/set-registration": {
          source: "iana"
        },
        "application/set-registration-initiation": {
          source: "iana",
          extensions: ["setreg"]
        },
        "application/sgml": {
          source: "iana"
        },
        "application/sgml-open-catalog": {
          source: "iana"
        },
        "application/shf+xml": {
          source: "iana",
          compressible: true,
          extensions: ["shf"]
        },
        "application/sieve": {
          source: "iana",
          extensions: ["siv", "sieve"]
        },
        "application/simple-filter+xml": {
          source: "iana",
          compressible: true
        },
        "application/simple-message-summary": {
          source: "iana"
        },
        "application/simplesymbolcontainer": {
          source: "iana"
        },
        "application/sipc": {
          source: "iana"
        },
        "application/slate": {
          source: "iana"
        },
        "application/smil": {
          source: "iana"
        },
        "application/smil+xml": {
          source: "iana",
          compressible: true,
          extensions: ["smi", "smil"]
        },
        "application/smpte336m": {
          source: "iana"
        },
        "application/soap+fastinfoset": {
          source: "iana"
        },
        "application/soap+xml": {
          source: "iana",
          compressible: true
        },
        "application/sparql-query": {
          source: "iana",
          extensions: ["rq"]
        },
        "application/sparql-results+xml": {
          source: "iana",
          compressible: true,
          extensions: ["srx"]
        },
        "application/spdx+json": {
          source: "iana",
          compressible: true
        },
        "application/spirits-event+xml": {
          source: "iana",
          compressible: true
        },
        "application/sql": {
          source: "iana"
        },
        "application/srgs": {
          source: "iana",
          extensions: ["gram"]
        },
        "application/srgs+xml": {
          source: "iana",
          compressible: true,
          extensions: ["grxml"]
        },
        "application/sru+xml": {
          source: "iana",
          compressible: true,
          extensions: ["sru"]
        },
        "application/ssdl+xml": {
          source: "apache",
          compressible: true,
          extensions: ["ssdl"]
        },
        "application/ssml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["ssml"]
        },
        "application/stix+json": {
          source: "iana",
          compressible: true
        },
        "application/swid+xml": {
          source: "iana",
          compressible: true,
          extensions: ["swidtag"]
        },
        "application/tamp-apex-update": {
          source: "iana"
        },
        "application/tamp-apex-update-confirm": {
          source: "iana"
        },
        "application/tamp-community-update": {
          source: "iana"
        },
        "application/tamp-community-update-confirm": {
          source: "iana"
        },
        "application/tamp-error": {
          source: "iana"
        },
        "application/tamp-sequence-adjust": {
          source: "iana"
        },
        "application/tamp-sequence-adjust-confirm": {
          source: "iana"
        },
        "application/tamp-status-query": {
          source: "iana"
        },
        "application/tamp-status-response": {
          source: "iana"
        },
        "application/tamp-update": {
          source: "iana"
        },
        "application/tamp-update-confirm": {
          source: "iana"
        },
        "application/tar": {
          compressible: true
        },
        "application/taxii+json": {
          source: "iana",
          compressible: true
        },
        "application/td+json": {
          source: "iana",
          compressible: true
        },
        "application/tei+xml": {
          source: "iana",
          compressible: true,
          extensions: ["tei", "teicorpus"]
        },
        "application/tetra_isi": {
          source: "iana"
        },
        "application/thraud+xml": {
          source: "iana",
          compressible: true,
          extensions: ["tfi"]
        },
        "application/timestamp-query": {
          source: "iana"
        },
        "application/timestamp-reply": {
          source: "iana"
        },
        "application/timestamped-data": {
          source: "iana",
          extensions: ["tsd"]
        },
        "application/tlsrpt+gzip": {
          source: "iana"
        },
        "application/tlsrpt+json": {
          source: "iana",
          compressible: true
        },
        "application/tnauthlist": {
          source: "iana"
        },
        "application/token-introspection+jwt": {
          source: "iana"
        },
        "application/toml": {
          compressible: true,
          extensions: ["toml"]
        },
        "application/trickle-ice-sdpfrag": {
          source: "iana"
        },
        "application/trig": {
          source: "iana",
          extensions: ["trig"]
        },
        "application/ttml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["ttml"]
        },
        "application/tve-trigger": {
          source: "iana"
        },
        "application/tzif": {
          source: "iana"
        },
        "application/tzif-leap": {
          source: "iana"
        },
        "application/ubjson": {
          compressible: false,
          extensions: ["ubj"]
        },
        "application/ulpfec": {
          source: "iana"
        },
        "application/urc-grpsheet+xml": {
          source: "iana",
          compressible: true
        },
        "application/urc-ressheet+xml": {
          source: "iana",
          compressible: true,
          extensions: ["rsheet"]
        },
        "application/urc-targetdesc+xml": {
          source: "iana",
          compressible: true,
          extensions: ["td"]
        },
        "application/urc-uisocketdesc+xml": {
          source: "iana",
          compressible: true
        },
        "application/vcard+json": {
          source: "iana",
          compressible: true
        },
        "application/vcard+xml": {
          source: "iana",
          compressible: true
        },
        "application/vemmi": {
          source: "iana"
        },
        "application/vividence.scriptfile": {
          source: "apache"
        },
        "application/vnd.1000minds.decision-model+xml": {
          source: "iana",
          compressible: true,
          extensions: ["1km"]
        },
        "application/vnd.3gpp-prose+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp-prose-pc3ch+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp-v2x-local-service-information": {
          source: "iana"
        },
        "application/vnd.3gpp.5gnas": {
          source: "iana"
        },
        "application/vnd.3gpp.access-transfer-events+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.bsf+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.gmop+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.gtpc": {
          source: "iana"
        },
        "application/vnd.3gpp.interworking-data": {
          source: "iana"
        },
        "application/vnd.3gpp.lpp": {
          source: "iana"
        },
        "application/vnd.3gpp.mc-signalling-ear": {
          source: "iana"
        },
        "application/vnd.3gpp.mcdata-affiliation-command+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcdata-info+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcdata-payload": {
          source: "iana"
        },
        "application/vnd.3gpp.mcdata-service-config+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcdata-signalling": {
          source: "iana"
        },
        "application/vnd.3gpp.mcdata-ue-config+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcdata-user-profile+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcptt-affiliation-command+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcptt-floor-request+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcptt-info+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcptt-location-info+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcptt-service-config+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcptt-signed+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcptt-ue-config+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcptt-ue-init-config+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcptt-user-profile+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcvideo-info+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcvideo-location-info+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcvideo-service-config+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcvideo-transmission-request+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcvideo-ue-config+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcvideo-user-profile+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mid-call+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.ngap": {
          source: "iana"
        },
        "application/vnd.3gpp.pfcp": {
          source: "iana"
        },
        "application/vnd.3gpp.pic-bw-large": {
          source: "iana",
          extensions: ["plb"]
        },
        "application/vnd.3gpp.pic-bw-small": {
          source: "iana",
          extensions: ["psb"]
        },
        "application/vnd.3gpp.pic-bw-var": {
          source: "iana",
          extensions: ["pvb"]
        },
        "application/vnd.3gpp.s1ap": {
          source: "iana"
        },
        "application/vnd.3gpp.sms": {
          source: "iana"
        },
        "application/vnd.3gpp.sms+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.srvcc-ext+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.srvcc-info+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.state-and-event-info+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.ussd+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp2.bcmcsinfo+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp2.sms": {
          source: "iana"
        },
        "application/vnd.3gpp2.tcap": {
          source: "iana",
          extensions: ["tcap"]
        },
        "application/vnd.3lightssoftware.imagescal": {
          source: "iana"
        },
        "application/vnd.3m.post-it-notes": {
          source: "iana",
          extensions: ["pwn"]
        },
        "application/vnd.accpac.simply.aso": {
          source: "iana",
          extensions: ["aso"]
        },
        "application/vnd.accpac.simply.imp": {
          source: "iana",
          extensions: ["imp"]
        },
        "application/vnd.acucobol": {
          source: "iana",
          extensions: ["acu"]
        },
        "application/vnd.acucorp": {
          source: "iana",
          extensions: ["atc", "acutc"]
        },
        "application/vnd.adobe.air-application-installer-package+zip": {
          source: "apache",
          compressible: false,
          extensions: ["air"]
        },
        "application/vnd.adobe.flash.movie": {
          source: "iana"
        },
        "application/vnd.adobe.formscentral.fcdt": {
          source: "iana",
          extensions: ["fcdt"]
        },
        "application/vnd.adobe.fxp": {
          source: "iana",
          extensions: ["fxp", "fxpl"]
        },
        "application/vnd.adobe.partial-upload": {
          source: "iana"
        },
        "application/vnd.adobe.xdp+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xdp"]
        },
        "application/vnd.adobe.xfdf": {
          source: "iana",
          extensions: ["xfdf"]
        },
        "application/vnd.aether.imp": {
          source: "iana"
        },
        "application/vnd.afpc.afplinedata": {
          source: "iana"
        },
        "application/vnd.afpc.afplinedata-pagedef": {
          source: "iana"
        },
        "application/vnd.afpc.cmoca-cmresource": {
          source: "iana"
        },
        "application/vnd.afpc.foca-charset": {
          source: "iana"
        },
        "application/vnd.afpc.foca-codedfont": {
          source: "iana"
        },
        "application/vnd.afpc.foca-codepage": {
          source: "iana"
        },
        "application/vnd.afpc.modca": {
          source: "iana"
        },
        "application/vnd.afpc.modca-cmtable": {
          source: "iana"
        },
        "application/vnd.afpc.modca-formdef": {
          source: "iana"
        },
        "application/vnd.afpc.modca-mediummap": {
          source: "iana"
        },
        "application/vnd.afpc.modca-objectcontainer": {
          source: "iana"
        },
        "application/vnd.afpc.modca-overlay": {
          source: "iana"
        },
        "application/vnd.afpc.modca-pagesegment": {
          source: "iana"
        },
        "application/vnd.age": {
          source: "iana",
          extensions: ["age"]
        },
        "application/vnd.ah-barcode": {
          source: "iana"
        },
        "application/vnd.ahead.space": {
          source: "iana",
          extensions: ["ahead"]
        },
        "application/vnd.airzip.filesecure.azf": {
          source: "iana",
          extensions: ["azf"]
        },
        "application/vnd.airzip.filesecure.azs": {
          source: "iana",
          extensions: ["azs"]
        },
        "application/vnd.amadeus+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.amazon.ebook": {
          source: "apache",
          extensions: ["azw"]
        },
        "application/vnd.amazon.mobi8-ebook": {
          source: "iana"
        },
        "application/vnd.americandynamics.acc": {
          source: "iana",
          extensions: ["acc"]
        },
        "application/vnd.amiga.ami": {
          source: "iana",
          extensions: ["ami"]
        },
        "application/vnd.amundsen.maze+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.android.ota": {
          source: "iana"
        },
        "application/vnd.android.package-archive": {
          source: "apache",
          compressible: false,
          extensions: ["apk"]
        },
        "application/vnd.anki": {
          source: "iana"
        },
        "application/vnd.anser-web-certificate-issue-initiation": {
          source: "iana",
          extensions: ["cii"]
        },
        "application/vnd.anser-web-funds-transfer-initiation": {
          source: "apache",
          extensions: ["fti"]
        },
        "application/vnd.antix.game-component": {
          source: "iana",
          extensions: ["atx"]
        },
        "application/vnd.apache.arrow.file": {
          source: "iana"
        },
        "application/vnd.apache.arrow.stream": {
          source: "iana"
        },
        "application/vnd.apache.thrift.binary": {
          source: "iana"
        },
        "application/vnd.apache.thrift.compact": {
          source: "iana"
        },
        "application/vnd.apache.thrift.json": {
          source: "iana"
        },
        "application/vnd.api+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.aplextor.warrp+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.apothekende.reservation+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.apple.installer+xml": {
          source: "iana",
          compressible: true,
          extensions: ["mpkg"]
        },
        "application/vnd.apple.keynote": {
          source: "iana",
          extensions: ["key"]
        },
        "application/vnd.apple.mpegurl": {
          source: "iana",
          extensions: ["m3u8"]
        },
        "application/vnd.apple.numbers": {
          source: "iana",
          extensions: ["numbers"]
        },
        "application/vnd.apple.pages": {
          source: "iana",
          extensions: ["pages"]
        },
        "application/vnd.apple.pkpass": {
          compressible: false,
          extensions: ["pkpass"]
        },
        "application/vnd.arastra.swi": {
          source: "iana"
        },
        "application/vnd.aristanetworks.swi": {
          source: "iana",
          extensions: ["swi"]
        },
        "application/vnd.artisan+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.artsquare": {
          source: "iana"
        },
        "application/vnd.astraea-software.iota": {
          source: "iana",
          extensions: ["iota"]
        },
        "application/vnd.audiograph": {
          source: "iana",
          extensions: ["aep"]
        },
        "application/vnd.autopackage": {
          source: "iana"
        },
        "application/vnd.avalon+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.avistar+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.balsamiq.bmml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["bmml"]
        },
        "application/vnd.balsamiq.bmpr": {
          source: "iana"
        },
        "application/vnd.banana-accounting": {
          source: "iana"
        },
        "application/vnd.bbf.usp.error": {
          source: "iana"
        },
        "application/vnd.bbf.usp.msg": {
          source: "iana"
        },
        "application/vnd.bbf.usp.msg+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.bekitzur-stech+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.bint.med-content": {
          source: "iana"
        },
        "application/vnd.biopax.rdf+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.blink-idb-value-wrapper": {
          source: "iana"
        },
        "application/vnd.blueice.multipass": {
          source: "iana",
          extensions: ["mpm"]
        },
        "application/vnd.bluetooth.ep.oob": {
          source: "iana"
        },
        "application/vnd.bluetooth.le.oob": {
          source: "iana"
        },
        "application/vnd.bmi": {
          source: "iana",
          extensions: ["bmi"]
        },
        "application/vnd.bpf": {
          source: "iana"
        },
        "application/vnd.bpf3": {
          source: "iana"
        },
        "application/vnd.businessobjects": {
          source: "iana",
          extensions: ["rep"]
        },
        "application/vnd.byu.uapi+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.cab-jscript": {
          source: "iana"
        },
        "application/vnd.canon-cpdl": {
          source: "iana"
        },
        "application/vnd.canon-lips": {
          source: "iana"
        },
        "application/vnd.capasystems-pg+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.cendio.thinlinc.clientconf": {
          source: "iana"
        },
        "application/vnd.century-systems.tcp_stream": {
          source: "iana"
        },
        "application/vnd.chemdraw+xml": {
          source: "iana",
          compressible: true,
          extensions: ["cdxml"]
        },
        "application/vnd.chess-pgn": {
          source: "iana"
        },
        "application/vnd.chipnuts.karaoke-mmd": {
          source: "iana",
          extensions: ["mmd"]
        },
        "application/vnd.ciedi": {
          source: "iana"
        },
        "application/vnd.cinderella": {
          source: "iana",
          extensions: ["cdy"]
        },
        "application/vnd.cirpack.isdn-ext": {
          source: "iana"
        },
        "application/vnd.citationstyles.style+xml": {
          source: "iana",
          compressible: true,
          extensions: ["csl"]
        },
        "application/vnd.claymore": {
          source: "iana",
          extensions: ["cla"]
        },
        "application/vnd.cloanto.rp9": {
          source: "iana",
          extensions: ["rp9"]
        },
        "application/vnd.clonk.c4group": {
          source: "iana",
          extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
        },
        "application/vnd.cluetrust.cartomobile-config": {
          source: "iana",
          extensions: ["c11amc"]
        },
        "application/vnd.cluetrust.cartomobile-config-pkg": {
          source: "iana",
          extensions: ["c11amz"]
        },
        "application/vnd.coffeescript": {
          source: "iana"
        },
        "application/vnd.collabio.xodocuments.document": {
          source: "iana"
        },
        "application/vnd.collabio.xodocuments.document-template": {
          source: "iana"
        },
        "application/vnd.collabio.xodocuments.presentation": {
          source: "iana"
        },
        "application/vnd.collabio.xodocuments.presentation-template": {
          source: "iana"
        },
        "application/vnd.collabio.xodocuments.spreadsheet": {
          source: "iana"
        },
        "application/vnd.collabio.xodocuments.spreadsheet-template": {
          source: "iana"
        },
        "application/vnd.collection+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.collection.doc+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.collection.next+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.comicbook+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.comicbook-rar": {
          source: "iana"
        },
        "application/vnd.commerce-battelle": {
          source: "iana"
        },
        "application/vnd.commonspace": {
          source: "iana",
          extensions: ["csp"]
        },
        "application/vnd.contact.cmsg": {
          source: "iana",
          extensions: ["cdbcmsg"]
        },
        "application/vnd.coreos.ignition+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.cosmocaller": {
          source: "iana",
          extensions: ["cmc"]
        },
        "application/vnd.crick.clicker": {
          source: "iana",
          extensions: ["clkx"]
        },
        "application/vnd.crick.clicker.keyboard": {
          source: "iana",
          extensions: ["clkk"]
        },
        "application/vnd.crick.clicker.palette": {
          source: "iana",
          extensions: ["clkp"]
        },
        "application/vnd.crick.clicker.template": {
          source: "iana",
          extensions: ["clkt"]
        },
        "application/vnd.crick.clicker.wordbank": {
          source: "iana",
          extensions: ["clkw"]
        },
        "application/vnd.criticaltools.wbs+xml": {
          source: "iana",
          compressible: true,
          extensions: ["wbs"]
        },
        "application/vnd.cryptii.pipe+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.crypto-shade-file": {
          source: "iana"
        },
        "application/vnd.cryptomator.encrypted": {
          source: "iana"
        },
        "application/vnd.cryptomator.vault": {
          source: "iana"
        },
        "application/vnd.ctc-posml": {
          source: "iana",
          extensions: ["pml"]
        },
        "application/vnd.ctct.ws+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.cups-pdf": {
          source: "iana"
        },
        "application/vnd.cups-postscript": {
          source: "iana"
        },
        "application/vnd.cups-ppd": {
          source: "iana",
          extensions: ["ppd"]
        },
        "application/vnd.cups-raster": {
          source: "iana"
        },
        "application/vnd.cups-raw": {
          source: "iana"
        },
        "application/vnd.curl": {
          source: "iana"
        },
        "application/vnd.curl.car": {
          source: "apache",
          extensions: ["car"]
        },
        "application/vnd.curl.pcurl": {
          source: "apache",
          extensions: ["pcurl"]
        },
        "application/vnd.cyan.dean.root+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.cybank": {
          source: "iana"
        },
        "application/vnd.cyclonedx+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.cyclonedx+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.d2l.coursepackage1p0+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.d3m-dataset": {
          source: "iana"
        },
        "application/vnd.d3m-problem": {
          source: "iana"
        },
        "application/vnd.dart": {
          source: "iana",
          compressible: true,
          extensions: ["dart"]
        },
        "application/vnd.data-vision.rdz": {
          source: "iana",
          extensions: ["rdz"]
        },
        "application/vnd.datapackage+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.dataresource+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.dbf": {
          source: "iana",
          extensions: ["dbf"]
        },
        "application/vnd.debian.binary-package": {
          source: "iana"
        },
        "application/vnd.dece.data": {
          source: "iana",
          extensions: ["uvf", "uvvf", "uvd", "uvvd"]
        },
        "application/vnd.dece.ttml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["uvt", "uvvt"]
        },
        "application/vnd.dece.unspecified": {
          source: "iana",
          extensions: ["uvx", "uvvx"]
        },
        "application/vnd.dece.zip": {
          source: "iana",
          extensions: ["uvz", "uvvz"]
        },
        "application/vnd.denovo.fcselayout-link": {
          source: "iana",
          extensions: ["fe_launch"]
        },
        "application/vnd.desmume.movie": {
          source: "iana"
        },
        "application/vnd.dir-bi.plate-dl-nosuffix": {
          source: "iana"
        },
        "application/vnd.dm.delegation+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.dna": {
          source: "iana",
          extensions: ["dna"]
        },
        "application/vnd.document+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.dolby.mlp": {
          source: "apache",
          extensions: ["mlp"]
        },
        "application/vnd.dolby.mobile.1": {
          source: "iana"
        },
        "application/vnd.dolby.mobile.2": {
          source: "iana"
        },
        "application/vnd.doremir.scorecloud-binary-document": {
          source: "iana"
        },
        "application/vnd.dpgraph": {
          source: "iana",
          extensions: ["dpg"]
        },
        "application/vnd.dreamfactory": {
          source: "iana",
          extensions: ["dfac"]
        },
        "application/vnd.drive+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.ds-keypoint": {
          source: "apache",
          extensions: ["kpxx"]
        },
        "application/vnd.dtg.local": {
          source: "iana"
        },
        "application/vnd.dtg.local.flash": {
          source: "iana"
        },
        "application/vnd.dtg.local.html": {
          source: "iana"
        },
        "application/vnd.dvb.ait": {
          source: "iana",
          extensions: ["ait"]
        },
        "application/vnd.dvb.dvbisl+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.dvb.dvbj": {
          source: "iana"
        },
        "application/vnd.dvb.esgcontainer": {
          source: "iana"
        },
        "application/vnd.dvb.ipdcdftnotifaccess": {
          source: "iana"
        },
        "application/vnd.dvb.ipdcesgaccess": {
          source: "iana"
        },
        "application/vnd.dvb.ipdcesgaccess2": {
          source: "iana"
        },
        "application/vnd.dvb.ipdcesgpdd": {
          source: "iana"
        },
        "application/vnd.dvb.ipdcroaming": {
          source: "iana"
        },
        "application/vnd.dvb.iptv.alfec-base": {
          source: "iana"
        },
        "application/vnd.dvb.iptv.alfec-enhancement": {
          source: "iana"
        },
        "application/vnd.dvb.notif-aggregate-root+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.dvb.notif-container+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.dvb.notif-generic+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.dvb.notif-ia-msglist+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.dvb.notif-ia-registration-request+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.dvb.notif-ia-registration-response+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.dvb.notif-init+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.dvb.pfr": {
          source: "iana"
        },
        "application/vnd.dvb.service": {
          source: "iana",
          extensions: ["svc"]
        },
        "application/vnd.dxr": {
          source: "iana"
        },
        "application/vnd.dynageo": {
          source: "iana",
          extensions: ["geo"]
        },
        "application/vnd.dzr": {
          source: "iana"
        },
        "application/vnd.easykaraoke.cdgdownload": {
          source: "iana"
        },
        "application/vnd.ecdis-update": {
          source: "iana"
        },
        "application/vnd.ecip.rlp": {
          source: "iana"
        },
        "application/vnd.ecowin.chart": {
          source: "iana",
          extensions: ["mag"]
        },
        "application/vnd.ecowin.filerequest": {
          source: "iana"
        },
        "application/vnd.ecowin.fileupdate": {
          source: "iana"
        },
        "application/vnd.ecowin.series": {
          source: "iana"
        },
        "application/vnd.ecowin.seriesrequest": {
          source: "iana"
        },
        "application/vnd.ecowin.seriesupdate": {
          source: "iana"
        },
        "application/vnd.efi.img": {
          source: "iana"
        },
        "application/vnd.efi.iso": {
          source: "iana"
        },
        "application/vnd.emclient.accessrequest+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.enliven": {
          source: "iana",
          extensions: ["nml"]
        },
        "application/vnd.enphase.envoy": {
          source: "iana"
        },
        "application/vnd.eprints.data+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.epson.esf": {
          source: "iana",
          extensions: ["esf"]
        },
        "application/vnd.epson.msf": {
          source: "iana",
          extensions: ["msf"]
        },
        "application/vnd.epson.quickanime": {
          source: "iana",
          extensions: ["qam"]
        },
        "application/vnd.epson.salt": {
          source: "iana",
          extensions: ["slt"]
        },
        "application/vnd.epson.ssf": {
          source: "iana",
          extensions: ["ssf"]
        },
        "application/vnd.ericsson.quickcall": {
          source: "iana"
        },
        "application/vnd.espass-espass+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.eszigno3+xml": {
          source: "iana",
          compressible: true,
          extensions: ["es3", "et3"]
        },
        "application/vnd.etsi.aoc+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.asic-e+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.etsi.asic-s+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.etsi.cug+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.iptvcommand+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.iptvdiscovery+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.iptvprofile+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.iptvsad-bc+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.iptvsad-cod+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.iptvsad-npvr+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.iptvservice+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.iptvsync+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.iptvueprofile+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.mcid+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.mheg5": {
          source: "iana"
        },
        "application/vnd.etsi.overload-control-policy-dataset+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.pstn+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.sci+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.simservs+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.timestamp-token": {
          source: "iana"
        },
        "application/vnd.etsi.tsl+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.tsl.der": {
          source: "iana"
        },
        "application/vnd.eudora.data": {
          source: "iana"
        },
        "application/vnd.evolv.ecig.profile": {
          source: "iana"
        },
        "application/vnd.evolv.ecig.settings": {
          source: "iana"
        },
        "application/vnd.evolv.ecig.theme": {
          source: "iana"
        },
        "application/vnd.exstream-empower+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.exstream-package": {
          source: "iana"
        },
        "application/vnd.ezpix-album": {
          source: "iana",
          extensions: ["ez2"]
        },
        "application/vnd.ezpix-package": {
          source: "iana",
          extensions: ["ez3"]
        },
        "application/vnd.f-secure.mobile": {
          source: "iana"
        },
        "application/vnd.fastcopy-disk-image": {
          source: "iana"
        },
        "application/vnd.fdf": {
          source: "iana",
          extensions: ["fdf"]
        },
        "application/vnd.fdsn.mseed": {
          source: "iana",
          extensions: ["mseed"]
        },
        "application/vnd.fdsn.seed": {
          source: "iana",
          extensions: ["seed", "dataless"]
        },
        "application/vnd.ffsns": {
          source: "iana"
        },
        "application/vnd.ficlab.flb+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.filmit.zfc": {
          source: "iana"
        },
        "application/vnd.fints": {
          source: "iana"
        },
        "application/vnd.firemonkeys.cloudcell": {
          source: "iana"
        },
        "application/vnd.flographit": {
          source: "iana",
          extensions: ["gph"]
        },
        "application/vnd.fluxtime.clip": {
          source: "iana",
          extensions: ["ftc"]
        },
        "application/vnd.font-fontforge-sfd": {
          source: "iana"
        },
        "application/vnd.framemaker": {
          source: "iana",
          extensions: ["fm", "frame", "maker", "book"]
        },
        "application/vnd.frogans.fnc": {
          source: "iana",
          extensions: ["fnc"]
        },
        "application/vnd.frogans.ltf": {
          source: "iana",
          extensions: ["ltf"]
        },
        "application/vnd.fsc.weblaunch": {
          source: "iana",
          extensions: ["fsc"]
        },
        "application/vnd.fujifilm.fb.docuworks": {
          source: "iana"
        },
        "application/vnd.fujifilm.fb.docuworks.binder": {
          source: "iana"
        },
        "application/vnd.fujifilm.fb.docuworks.container": {
          source: "iana"
        },
        "application/vnd.fujifilm.fb.jfi+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.fujitsu.oasys": {
          source: "iana",
          extensions: ["oas"]
        },
        "application/vnd.fujitsu.oasys2": {
          source: "iana",
          extensions: ["oa2"]
        },
        "application/vnd.fujitsu.oasys3": {
          source: "iana",
          extensions: ["oa3"]
        },
        "application/vnd.fujitsu.oasysgp": {
          source: "iana",
          extensions: ["fg5"]
        },
        "application/vnd.fujitsu.oasysprs": {
          source: "iana",
          extensions: ["bh2"]
        },
        "application/vnd.fujixerox.art-ex": {
          source: "iana"
        },
        "application/vnd.fujixerox.art4": {
          source: "iana"
        },
        "application/vnd.fujixerox.ddd": {
          source: "iana",
          extensions: ["ddd"]
        },
        "application/vnd.fujixerox.docuworks": {
          source: "iana",
          extensions: ["xdw"]
        },
        "application/vnd.fujixerox.docuworks.binder": {
          source: "iana",
          extensions: ["xbd"]
        },
        "application/vnd.fujixerox.docuworks.container": {
          source: "iana"
        },
        "application/vnd.fujixerox.hbpl": {
          source: "iana"
        },
        "application/vnd.fut-misnet": {
          source: "iana"
        },
        "application/vnd.futoin+cbor": {
          source: "iana"
        },
        "application/vnd.futoin+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.fuzzysheet": {
          source: "iana",
          extensions: ["fzs"]
        },
        "application/vnd.genomatix.tuxedo": {
          source: "iana",
          extensions: ["txd"]
        },
        "application/vnd.gentics.grd+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.geo+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.geocube+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.geogebra.file": {
          source: "iana",
          extensions: ["ggb"]
        },
        "application/vnd.geogebra.slides": {
          source: "iana"
        },
        "application/vnd.geogebra.tool": {
          source: "iana",
          extensions: ["ggt"]
        },
        "application/vnd.geometry-explorer": {
          source: "iana",
          extensions: ["gex", "gre"]
        },
        "application/vnd.geonext": {
          source: "iana",
          extensions: ["gxt"]
        },
        "application/vnd.geoplan": {
          source: "iana",
          extensions: ["g2w"]
        },
        "application/vnd.geospace": {
          source: "iana",
          extensions: ["g3w"]
        },
        "application/vnd.gerber": {
          source: "iana"
        },
        "application/vnd.globalplatform.card-content-mgt": {
          source: "iana"
        },
        "application/vnd.globalplatform.card-content-mgt-response": {
          source: "iana"
        },
        "application/vnd.gmx": {
          source: "iana",
          extensions: ["gmx"]
        },
        "application/vnd.google-apps.document": {
          compressible: false,
          extensions: ["gdoc"]
        },
        "application/vnd.google-apps.presentation": {
          compressible: false,
          extensions: ["gslides"]
        },
        "application/vnd.google-apps.spreadsheet": {
          compressible: false,
          extensions: ["gsheet"]
        },
        "application/vnd.google-earth.kml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["kml"]
        },
        "application/vnd.google-earth.kmz": {
          source: "iana",
          compressible: false,
          extensions: ["kmz"]
        },
        "application/vnd.gov.sk.e-form+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.gov.sk.e-form+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.gov.sk.xmldatacontainer+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.grafeq": {
          source: "iana",
          extensions: ["gqf", "gqs"]
        },
        "application/vnd.gridmp": {
          source: "iana"
        },
        "application/vnd.groove-account": {
          source: "iana",
          extensions: ["gac"]
        },
        "application/vnd.groove-help": {
          source: "iana",
          extensions: ["ghf"]
        },
        "application/vnd.groove-identity-message": {
          source: "iana",
          extensions: ["gim"]
        },
        "application/vnd.groove-injector": {
          source: "iana",
          extensions: ["grv"]
        },
        "application/vnd.groove-tool-message": {
          source: "iana",
          extensions: ["gtm"]
        },
        "application/vnd.groove-tool-template": {
          source: "iana",
          extensions: ["tpl"]
        },
        "application/vnd.groove-vcard": {
          source: "iana",
          extensions: ["vcg"]
        },
        "application/vnd.hal+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.hal+xml": {
          source: "iana",
          compressible: true,
          extensions: ["hal"]
        },
        "application/vnd.handheld-entertainment+xml": {
          source: "iana",
          compressible: true,
          extensions: ["zmm"]
        },
        "application/vnd.hbci": {
          source: "iana",
          extensions: ["hbci"]
        },
        "application/vnd.hc+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.hcl-bireports": {
          source: "iana"
        },
        "application/vnd.hdt": {
          source: "iana"
        },
        "application/vnd.heroku+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.hhe.lesson-player": {
          source: "iana",
          extensions: ["les"]
        },
        "application/vnd.hp-hpgl": {
          source: "iana",
          extensions: ["hpgl"]
        },
        "application/vnd.hp-hpid": {
          source: "iana",
          extensions: ["hpid"]
        },
        "application/vnd.hp-hps": {
          source: "iana",
          extensions: ["hps"]
        },
        "application/vnd.hp-jlyt": {
          source: "iana",
          extensions: ["jlt"]
        },
        "application/vnd.hp-pcl": {
          source: "iana",
          extensions: ["pcl"]
        },
        "application/vnd.hp-pclxl": {
          source: "iana",
          extensions: ["pclxl"]
        },
        "application/vnd.httphone": {
          source: "iana"
        },
        "application/vnd.hydrostatix.sof-data": {
          source: "iana",
          extensions: ["sfd-hdstx"]
        },
        "application/vnd.hyper+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.hyper-item+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.hyperdrive+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.hzn-3d-crossword": {
          source: "iana"
        },
        "application/vnd.ibm.afplinedata": {
          source: "iana"
        },
        "application/vnd.ibm.electronic-media": {
          source: "iana"
        },
        "application/vnd.ibm.minipay": {
          source: "iana",
          extensions: ["mpy"]
        },
        "application/vnd.ibm.modcap": {
          source: "iana",
          extensions: ["afp", "listafp", "list3820"]
        },
        "application/vnd.ibm.rights-management": {
          source: "iana",
          extensions: ["irm"]
        },
        "application/vnd.ibm.secure-container": {
          source: "iana",
          extensions: ["sc"]
        },
        "application/vnd.iccprofile": {
          source: "iana",
          extensions: ["icc", "icm"]
        },
        "application/vnd.ieee.1905": {
          source: "iana"
        },
        "application/vnd.igloader": {
          source: "iana",
          extensions: ["igl"]
        },
        "application/vnd.imagemeter.folder+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.imagemeter.image+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.immervision-ivp": {
          source: "iana",
          extensions: ["ivp"]
        },
        "application/vnd.immervision-ivu": {
          source: "iana",
          extensions: ["ivu"]
        },
        "application/vnd.ims.imsccv1p1": {
          source: "iana"
        },
        "application/vnd.ims.imsccv1p2": {
          source: "iana"
        },
        "application/vnd.ims.imsccv1p3": {
          source: "iana"
        },
        "application/vnd.ims.lis.v2.result+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.ims.lti.v2.toolproxy+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.ims.lti.v2.toolproxy.id+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.ims.lti.v2.toolsettings+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.ims.lti.v2.toolsettings.simple+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.informedcontrol.rms+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.informix-visionary": {
          source: "iana"
        },
        "application/vnd.infotech.project": {
          source: "iana"
        },
        "application/vnd.infotech.project+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.innopath.wamp.notification": {
          source: "iana"
        },
        "application/vnd.insors.igm": {
          source: "iana",
          extensions: ["igm"]
        },
        "application/vnd.intercon.formnet": {
          source: "iana",
          extensions: ["xpw", "xpx"]
        },
        "application/vnd.intergeo": {
          source: "iana",
          extensions: ["i2g"]
        },
        "application/vnd.intertrust.digibox": {
          source: "iana"
        },
        "application/vnd.intertrust.nncp": {
          source: "iana"
        },
        "application/vnd.intu.qbo": {
          source: "iana",
          extensions: ["qbo"]
        },
        "application/vnd.intu.qfx": {
          source: "iana",
          extensions: ["qfx"]
        },
        "application/vnd.iptc.g2.catalogitem+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.iptc.g2.conceptitem+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.iptc.g2.knowledgeitem+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.iptc.g2.newsitem+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.iptc.g2.newsmessage+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.iptc.g2.packageitem+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.iptc.g2.planningitem+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.ipunplugged.rcprofile": {
          source: "iana",
          extensions: ["rcprofile"]
        },
        "application/vnd.irepository.package+xml": {
          source: "iana",
          compressible: true,
          extensions: ["irp"]
        },
        "application/vnd.is-xpr": {
          source: "iana",
          extensions: ["xpr"]
        },
        "application/vnd.isac.fcs": {
          source: "iana",
          extensions: ["fcs"]
        },
        "application/vnd.iso11783-10+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.jam": {
          source: "iana",
          extensions: ["jam"]
        },
        "application/vnd.japannet-directory-service": {
          source: "iana"
        },
        "application/vnd.japannet-jpnstore-wakeup": {
          source: "iana"
        },
        "application/vnd.japannet-payment-wakeup": {
          source: "iana"
        },
        "application/vnd.japannet-registration": {
          source: "iana"
        },
        "application/vnd.japannet-registration-wakeup": {
          source: "iana"
        },
        "application/vnd.japannet-setstore-wakeup": {
          source: "iana"
        },
        "application/vnd.japannet-verification": {
          source: "iana"
        },
        "application/vnd.japannet-verification-wakeup": {
          source: "iana"
        },
        "application/vnd.jcp.javame.midlet-rms": {
          source: "iana",
          extensions: ["rms"]
        },
        "application/vnd.jisp": {
          source: "iana",
          extensions: ["jisp"]
        },
        "application/vnd.joost.joda-archive": {
          source: "iana",
          extensions: ["joda"]
        },
        "application/vnd.jsk.isdn-ngn": {
          source: "iana"
        },
        "application/vnd.kahootz": {
          source: "iana",
          extensions: ["ktz", "ktr"]
        },
        "application/vnd.kde.karbon": {
          source: "iana",
          extensions: ["karbon"]
        },
        "application/vnd.kde.kchart": {
          source: "iana",
          extensions: ["chrt"]
        },
        "application/vnd.kde.kformula": {
          source: "iana",
          extensions: ["kfo"]
        },
        "application/vnd.kde.kivio": {
          source: "iana",
          extensions: ["flw"]
        },
        "application/vnd.kde.kontour": {
          source: "iana",
          extensions: ["kon"]
        },
        "application/vnd.kde.kpresenter": {
          source: "iana",
          extensions: ["kpr", "kpt"]
        },
        "application/vnd.kde.kspread": {
          source: "iana",
          extensions: ["ksp"]
        },
        "application/vnd.kde.kword": {
          source: "iana",
          extensions: ["kwd", "kwt"]
        },
        "application/vnd.kenameaapp": {
          source: "iana",
          extensions: ["htke"]
        },
        "application/vnd.kidspiration": {
          source: "iana",
          extensions: ["kia"]
        },
        "application/vnd.kinar": {
          source: "iana",
          extensions: ["kne", "knp"]
        },
        "application/vnd.koan": {
          source: "iana",
          extensions: ["skp", "skd", "skt", "skm"]
        },
        "application/vnd.kodak-descriptor": {
          source: "iana",
          extensions: ["sse"]
        },
        "application/vnd.las": {
          source: "iana"
        },
        "application/vnd.las.las+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.las.las+xml": {
          source: "iana",
          compressible: true,
          extensions: ["lasxml"]
        },
        "application/vnd.laszip": {
          source: "iana"
        },
        "application/vnd.leap+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.liberty-request+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.llamagraphics.life-balance.desktop": {
          source: "iana",
          extensions: ["lbd"]
        },
        "application/vnd.llamagraphics.life-balance.exchange+xml": {
          source: "iana",
          compressible: true,
          extensions: ["lbe"]
        },
        "application/vnd.logipipe.circuit+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.loom": {
          source: "iana"
        },
        "application/vnd.lotus-1-2-3": {
          source: "iana",
          extensions: ["123"]
        },
        "application/vnd.lotus-approach": {
          source: "iana",
          extensions: ["apr"]
        },
        "application/vnd.lotus-freelance": {
          source: "iana",
          extensions: ["pre"]
        },
        "application/vnd.lotus-notes": {
          source: "iana",
          extensions: ["nsf"]
        },
        "application/vnd.lotus-organizer": {
          source: "iana",
          extensions: ["org"]
        },
        "application/vnd.lotus-screencam": {
          source: "iana",
          extensions: ["scm"]
        },
        "application/vnd.lotus-wordpro": {
          source: "iana",
          extensions: ["lwp"]
        },
        "application/vnd.macports.portpkg": {
          source: "iana",
          extensions: ["portpkg"]
        },
        "application/vnd.mapbox-vector-tile": {
          source: "iana",
          extensions: ["mvt"]
        },
        "application/vnd.marlin.drm.actiontoken+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.marlin.drm.conftoken+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.marlin.drm.license+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.marlin.drm.mdcf": {
          source: "iana"
        },
        "application/vnd.mason+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.maxmind.maxmind-db": {
          source: "iana"
        },
        "application/vnd.mcd": {
          source: "iana",
          extensions: ["mcd"]
        },
        "application/vnd.medcalcdata": {
          source: "iana",
          extensions: ["mc1"]
        },
        "application/vnd.mediastation.cdkey": {
          source: "iana",
          extensions: ["cdkey"]
        },
        "application/vnd.meridian-slingshot": {
          source: "iana"
        },
        "application/vnd.mfer": {
          source: "iana",
          extensions: ["mwf"]
        },
        "application/vnd.mfmp": {
          source: "iana",
          extensions: ["mfm"]
        },
        "application/vnd.micro+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.micrografx.flo": {
          source: "iana",
          extensions: ["flo"]
        },
        "application/vnd.micrografx.igx": {
          source: "iana",
          extensions: ["igx"]
        },
        "application/vnd.microsoft.portable-executable": {
          source: "iana"
        },
        "application/vnd.microsoft.windows.thumbnail-cache": {
          source: "iana"
        },
        "application/vnd.miele+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.mif": {
          source: "iana",
          extensions: ["mif"]
        },
        "application/vnd.minisoft-hp3000-save": {
          source: "iana"
        },
        "application/vnd.mitsubishi.misty-guard.trustweb": {
          source: "iana"
        },
        "application/vnd.mobius.daf": {
          source: "iana",
          extensions: ["daf"]
        },
        "application/vnd.mobius.dis": {
          source: "iana",
          extensions: ["dis"]
        },
        "application/vnd.mobius.mbk": {
          source: "iana",
          extensions: ["mbk"]
        },
        "application/vnd.mobius.mqy": {
          source: "iana",
          extensions: ["mqy"]
        },
        "application/vnd.mobius.msl": {
          source: "iana",
          extensions: ["msl"]
        },
        "application/vnd.mobius.plc": {
          source: "iana",
          extensions: ["plc"]
        },
        "application/vnd.mobius.txf": {
          source: "iana",
          extensions: ["txf"]
        },
        "application/vnd.mophun.application": {
          source: "iana",
          extensions: ["mpn"]
        },
        "application/vnd.mophun.certificate": {
          source: "iana",
          extensions: ["mpc"]
        },
        "application/vnd.motorola.flexsuite": {
          source: "iana"
        },
        "application/vnd.motorola.flexsuite.adsi": {
          source: "iana"
        },
        "application/vnd.motorola.flexsuite.fis": {
          source: "iana"
        },
        "application/vnd.motorola.flexsuite.gotap": {
          source: "iana"
        },
        "application/vnd.motorola.flexsuite.kmr": {
          source: "iana"
        },
        "application/vnd.motorola.flexsuite.ttc": {
          source: "iana"
        },
        "application/vnd.motorola.flexsuite.wem": {
          source: "iana"
        },
        "application/vnd.motorola.iprm": {
          source: "iana"
        },
        "application/vnd.mozilla.xul+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xul"]
        },
        "application/vnd.ms-3mfdocument": {
          source: "iana"
        },
        "application/vnd.ms-artgalry": {
          source: "iana",
          extensions: ["cil"]
        },
        "application/vnd.ms-asf": {
          source: "iana"
        },
        "application/vnd.ms-cab-compressed": {
          source: "iana",
          extensions: ["cab"]
        },
        "application/vnd.ms-color.iccprofile": {
          source: "apache"
        },
        "application/vnd.ms-excel": {
          source: "iana",
          compressible: false,
          extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
        },
        "application/vnd.ms-excel.addin.macroenabled.12": {
          source: "iana",
          extensions: ["xlam"]
        },
        "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
          source: "iana",
          extensions: ["xlsb"]
        },
        "application/vnd.ms-excel.sheet.macroenabled.12": {
          source: "iana",
          extensions: ["xlsm"]
        },
        "application/vnd.ms-excel.template.macroenabled.12": {
          source: "iana",
          extensions: ["xltm"]
        },
        "application/vnd.ms-fontobject": {
          source: "iana",
          compressible: true,
          extensions: ["eot"]
        },
        "application/vnd.ms-htmlhelp": {
          source: "iana",
          extensions: ["chm"]
        },
        "application/vnd.ms-ims": {
          source: "iana",
          extensions: ["ims"]
        },
        "application/vnd.ms-lrm": {
          source: "iana",
          extensions: ["lrm"]
        },
        "application/vnd.ms-office.activex+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.ms-officetheme": {
          source: "iana",
          extensions: ["thmx"]
        },
        "application/vnd.ms-opentype": {
          source: "apache",
          compressible: true
        },
        "application/vnd.ms-outlook": {
          compressible: false,
          extensions: ["msg"]
        },
        "application/vnd.ms-package.obfuscated-opentype": {
          source: "apache"
        },
        "application/vnd.ms-pki.seccat": {
          source: "apache",
          extensions: ["cat"]
        },
        "application/vnd.ms-pki.stl": {
          source: "apache",
          extensions: ["stl"]
        },
        "application/vnd.ms-playready.initiator+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.ms-powerpoint": {
          source: "iana",
          compressible: false,
          extensions: ["ppt", "pps", "pot"]
        },
        "application/vnd.ms-powerpoint.addin.macroenabled.12": {
          source: "iana",
          extensions: ["ppam"]
        },
        "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
          source: "iana",
          extensions: ["pptm"]
        },
        "application/vnd.ms-powerpoint.slide.macroenabled.12": {
          source: "iana",
          extensions: ["sldm"]
        },
        "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
          source: "iana",
          extensions: ["ppsm"]
        },
        "application/vnd.ms-powerpoint.template.macroenabled.12": {
          source: "iana",
          extensions: ["potm"]
        },
        "application/vnd.ms-printdevicecapabilities+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.ms-printing.printticket+xml": {
          source: "apache",
          compressible: true
        },
        "application/vnd.ms-printschematicket+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.ms-project": {
          source: "iana",
          extensions: ["mpp", "mpt"]
        },
        "application/vnd.ms-tnef": {
          source: "iana"
        },
        "application/vnd.ms-windows.devicepairing": {
          source: "iana"
        },
        "application/vnd.ms-windows.nwprinting.oob": {
          source: "iana"
        },
        "application/vnd.ms-windows.printerpairing": {
          source: "iana"
        },
        "application/vnd.ms-windows.wsd.oob": {
          source: "iana"
        },
        "application/vnd.ms-wmdrm.lic-chlg-req": {
          source: "iana"
        },
        "application/vnd.ms-wmdrm.lic-resp": {
          source: "iana"
        },
        "application/vnd.ms-wmdrm.meter-chlg-req": {
          source: "iana"
        },
        "application/vnd.ms-wmdrm.meter-resp": {
          source: "iana"
        },
        "application/vnd.ms-word.document.macroenabled.12": {
          source: "iana",
          extensions: ["docm"]
        },
        "application/vnd.ms-word.template.macroenabled.12": {
          source: "iana",
          extensions: ["dotm"]
        },
        "application/vnd.ms-works": {
          source: "iana",
          extensions: ["wps", "wks", "wcm", "wdb"]
        },
        "application/vnd.ms-wpl": {
          source: "iana",
          extensions: ["wpl"]
        },
        "application/vnd.ms-xpsdocument": {
          source: "iana",
          compressible: false,
          extensions: ["xps"]
        },
        "application/vnd.msa-disk-image": {
          source: "iana"
        },
        "application/vnd.mseq": {
          source: "iana",
          extensions: ["mseq"]
        },
        "application/vnd.msign": {
          source: "iana"
        },
        "application/vnd.multiad.creator": {
          source: "iana"
        },
        "application/vnd.multiad.creator.cif": {
          source: "iana"
        },
        "application/vnd.music-niff": {
          source: "iana"
        },
        "application/vnd.musician": {
          source: "iana",
          extensions: ["mus"]
        },
        "application/vnd.muvee.style": {
          source: "iana",
          extensions: ["msty"]
        },
        "application/vnd.mynfc": {
          source: "iana",
          extensions: ["taglet"]
        },
        "application/vnd.nacamar.ybrid+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.ncd.control": {
          source: "iana"
        },
        "application/vnd.ncd.reference": {
          source: "iana"
        },
        "application/vnd.nearst.inv+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.nebumind.line": {
          source: "iana"
        },
        "application/vnd.nervana": {
          source: "iana"
        },
        "application/vnd.netfpx": {
          source: "iana"
        },
        "application/vnd.neurolanguage.nlu": {
          source: "iana",
          extensions: ["nlu"]
        },
        "application/vnd.nimn": {
          source: "iana"
        },
        "application/vnd.nintendo.nitro.rom": {
          source: "iana"
        },
        "application/vnd.nintendo.snes.rom": {
          source: "iana"
        },
        "application/vnd.nitf": {
          source: "iana",
          extensions: ["ntf", "nitf"]
        },
        "application/vnd.noblenet-directory": {
          source: "iana",
          extensions: ["nnd"]
        },
        "application/vnd.noblenet-sealer": {
          source: "iana",
          extensions: ["nns"]
        },
        "application/vnd.noblenet-web": {
          source: "iana",
          extensions: ["nnw"]
        },
        "application/vnd.nokia.catalogs": {
          source: "iana"
        },
        "application/vnd.nokia.conml+wbxml": {
          source: "iana"
        },
        "application/vnd.nokia.conml+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.nokia.iptv.config+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.nokia.isds-radio-presets": {
          source: "iana"
        },
        "application/vnd.nokia.landmark+wbxml": {
          source: "iana"
        },
        "application/vnd.nokia.landmark+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.nokia.landmarkcollection+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.nokia.n-gage.ac+xml": {
          source: "iana",
          compressible: true,
          extensions: ["ac"]
        },
        "application/vnd.nokia.n-gage.data": {
          source: "iana",
          extensions: ["ngdat"]
        },
        "application/vnd.nokia.n-gage.symbian.install": {
          source: "iana",
          extensions: ["n-gage"]
        },
        "application/vnd.nokia.ncd": {
          source: "iana"
        },
        "application/vnd.nokia.pcd+wbxml": {
          source: "iana"
        },
        "application/vnd.nokia.pcd+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.nokia.radio-preset": {
          source: "iana",
          extensions: ["rpst"]
        },
        "application/vnd.nokia.radio-presets": {
          source: "iana",
          extensions: ["rpss"]
        },
        "application/vnd.novadigm.edm": {
          source: "iana",
          extensions: ["edm"]
        },
        "application/vnd.novadigm.edx": {
          source: "iana",
          extensions: ["edx"]
        },
        "application/vnd.novadigm.ext": {
          source: "iana",
          extensions: ["ext"]
        },
        "application/vnd.ntt-local.content-share": {
          source: "iana"
        },
        "application/vnd.ntt-local.file-transfer": {
          source: "iana"
        },
        "application/vnd.ntt-local.ogw_remote-access": {
          source: "iana"
        },
        "application/vnd.ntt-local.sip-ta_remote": {
          source: "iana"
        },
        "application/vnd.ntt-local.sip-ta_tcp_stream": {
          source: "iana"
        },
        "application/vnd.oasis.opendocument.chart": {
          source: "iana",
          extensions: ["odc"]
        },
        "application/vnd.oasis.opendocument.chart-template": {
          source: "iana",
          extensions: ["otc"]
        },
        "application/vnd.oasis.opendocument.database": {
          source: "iana",
          extensions: ["odb"]
        },
        "application/vnd.oasis.opendocument.formula": {
          source: "iana",
          extensions: ["odf"]
        },
        "application/vnd.oasis.opendocument.formula-template": {
          source: "iana",
          extensions: ["odft"]
        },
        "application/vnd.oasis.opendocument.graphics": {
          source: "iana",
          compressible: false,
          extensions: ["odg"]
        },
        "application/vnd.oasis.opendocument.graphics-template": {
          source: "iana",
          extensions: ["otg"]
        },
        "application/vnd.oasis.opendocument.image": {
          source: "iana",
          extensions: ["odi"]
        },
        "application/vnd.oasis.opendocument.image-template": {
          source: "iana",
          extensions: ["oti"]
        },
        "application/vnd.oasis.opendocument.presentation": {
          source: "iana",
          compressible: false,
          extensions: ["odp"]
        },
        "application/vnd.oasis.opendocument.presentation-template": {
          source: "iana",
          extensions: ["otp"]
        },
        "application/vnd.oasis.opendocument.spreadsheet": {
          source: "iana",
          compressible: false,
          extensions: ["ods"]
        },
        "application/vnd.oasis.opendocument.spreadsheet-template": {
          source: "iana",
          extensions: ["ots"]
        },
        "application/vnd.oasis.opendocument.text": {
          source: "iana",
          compressible: false,
          extensions: ["odt"]
        },
        "application/vnd.oasis.opendocument.text-master": {
          source: "iana",
          extensions: ["odm"]
        },
        "application/vnd.oasis.opendocument.text-template": {
          source: "iana",
          extensions: ["ott"]
        },
        "application/vnd.oasis.opendocument.text-web": {
          source: "iana",
          extensions: ["oth"]
        },
        "application/vnd.obn": {
          source: "iana"
        },
        "application/vnd.ocf+cbor": {
          source: "iana"
        },
        "application/vnd.oci.image.manifest.v1+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oftn.l10n+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oipf.contentaccessdownload+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oipf.contentaccessstreaming+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oipf.cspg-hexbinary": {
          source: "iana"
        },
        "application/vnd.oipf.dae.svg+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oipf.dae.xhtml+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oipf.mippvcontrolmessage+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oipf.pae.gem": {
          source: "iana"
        },
        "application/vnd.oipf.spdiscovery+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oipf.spdlist+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oipf.ueprofile+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oipf.userprofile+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.olpc-sugar": {
          source: "iana",
          extensions: ["xo"]
        },
        "application/vnd.oma-scws-config": {
          source: "iana"
        },
        "application/vnd.oma-scws-http-request": {
          source: "iana"
        },
        "application/vnd.oma-scws-http-response": {
          source: "iana"
        },
        "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.bcast.drm-trigger+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.bcast.imd+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.bcast.ltkm": {
          source: "iana"
        },
        "application/vnd.oma.bcast.notification+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.bcast.provisioningtrigger": {
          source: "iana"
        },
        "application/vnd.oma.bcast.sgboot": {
          source: "iana"
        },
        "application/vnd.oma.bcast.sgdd+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.bcast.sgdu": {
          source: "iana"
        },
        "application/vnd.oma.bcast.simple-symbol-container": {
          source: "iana"
        },
        "application/vnd.oma.bcast.smartcard-trigger+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.bcast.sprov+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.bcast.stkm": {
          source: "iana"
        },
        "application/vnd.oma.cab-address-book+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.cab-feature-handler+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.cab-pcc+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.cab-subs-invite+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.cab-user-prefs+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.dcd": {
          source: "iana"
        },
        "application/vnd.oma.dcdc": {
          source: "iana"
        },
        "application/vnd.oma.dd2+xml": {
          source: "iana",
          compressible: true,
          extensions: ["dd2"]
        },
        "application/vnd.oma.drm.risd+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.group-usage-list+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.lwm2m+cbor": {
          source: "iana"
        },
        "application/vnd.oma.lwm2m+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.lwm2m+tlv": {
          source: "iana"
        },
        "application/vnd.oma.pal+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.poc.detailed-progress-report+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.poc.final-report+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.poc.groups+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.poc.invocation-descriptor+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.poc.optimized-progress-report+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.push": {
          source: "iana"
        },
        "application/vnd.oma.scidm.messages+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.xcap-directory+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.omads-email+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/vnd.omads-file+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/vnd.omads-folder+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/vnd.omaloc-supl-init": {
          source: "iana"
        },
        "application/vnd.onepager": {
          source: "iana"
        },
        "application/vnd.onepagertamp": {
          source: "iana"
        },
        "application/vnd.onepagertamx": {
          source: "iana"
        },
        "application/vnd.onepagertat": {
          source: "iana"
        },
        "application/vnd.onepagertatp": {
          source: "iana"
        },
        "application/vnd.onepagertatx": {
          source: "iana"
        },
        "application/vnd.openblox.game+xml": {
          source: "iana",
          compressible: true,
          extensions: ["obgx"]
        },
        "application/vnd.openblox.game-binary": {
          source: "iana"
        },
        "application/vnd.openeye.oeb": {
          source: "iana"
        },
        "application/vnd.openofficeorg.extension": {
          source: "apache",
          extensions: ["oxt"]
        },
        "application/vnd.openstreetmap.data+xml": {
          source: "iana",
          compressible: true,
          extensions: ["osm"]
        },
        "application/vnd.opentimestamps.ots": {
          source: "iana"
        },
        "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.drawing+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
          source: "iana",
          compressible: false,
          extensions: ["pptx"]
        },
        "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.slide": {
          source: "iana",
          extensions: ["sldx"]
        },
        "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
          source: "iana",
          extensions: ["ppsx"]
        },
        "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.template": {
          source: "iana",
          extensions: ["potx"]
        },
        "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
          source: "iana",
          compressible: false,
          extensions: ["xlsx"]
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
          source: "iana",
          extensions: ["xltx"]
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.theme+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.vmldrawing": {
          source: "iana"
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
          source: "iana",
          compressible: false,
          extensions: ["docx"]
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
          source: "iana",
          extensions: ["dotx"]
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-package.core-properties+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-package.relationships+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oracle.resource+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.orange.indata": {
          source: "iana"
        },
        "application/vnd.osa.netdeploy": {
          source: "iana"
        },
        "application/vnd.osgeo.mapguide.package": {
          source: "iana",
          extensions: ["mgp"]
        },
        "application/vnd.osgi.bundle": {
          source: "iana"
        },
        "application/vnd.osgi.dp": {
          source: "iana",
          extensions: ["dp"]
        },
        "application/vnd.osgi.subsystem": {
          source: "iana",
          extensions: ["esa"]
        },
        "application/vnd.otps.ct-kip+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oxli.countgraph": {
          source: "iana"
        },
        "application/vnd.pagerduty+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.palm": {
          source: "iana",
          extensions: ["pdb", "pqa", "oprc"]
        },
        "application/vnd.panoply": {
          source: "iana"
        },
        "application/vnd.paos.xml": {
          source: "iana"
        },
        "application/vnd.patentdive": {
          source: "iana"
        },
        "application/vnd.patientecommsdoc": {
          source: "iana"
        },
        "application/vnd.pawaafile": {
          source: "iana",
          extensions: ["paw"]
        },
        "application/vnd.pcos": {
          source: "iana"
        },
        "application/vnd.pg.format": {
          source: "iana",
          extensions: ["str"]
        },
        "application/vnd.pg.osasli": {
          source: "iana",
          extensions: ["ei6"]
        },
        "application/vnd.piaccess.application-licence": {
          source: "iana"
        },
        "application/vnd.picsel": {
          source: "iana",
          extensions: ["efif"]
        },
        "application/vnd.pmi.widget": {
          source: "iana",
          extensions: ["wg"]
        },
        "application/vnd.poc.group-advertisement+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.pocketlearn": {
          source: "iana",
          extensions: ["plf"]
        },
        "application/vnd.powerbuilder6": {
          source: "iana",
          extensions: ["pbd"]
        },
        "application/vnd.powerbuilder6-s": {
          source: "iana"
        },
        "application/vnd.powerbuilder7": {
          source: "iana"
        },
        "application/vnd.powerbuilder7-s": {
          source: "iana"
        },
        "application/vnd.powerbuilder75": {
          source: "iana"
        },
        "application/vnd.powerbuilder75-s": {
          source: "iana"
        },
        "application/vnd.preminet": {
          source: "iana"
        },
        "application/vnd.previewsystems.box": {
          source: "iana",
          extensions: ["box"]
        },
        "application/vnd.proteus.magazine": {
          source: "iana",
          extensions: ["mgz"]
        },
        "application/vnd.psfs": {
          source: "iana"
        },
        "application/vnd.publishare-delta-tree": {
          source: "iana",
          extensions: ["qps"]
        },
        "application/vnd.pvi.ptid1": {
          source: "iana",
          extensions: ["ptid"]
        },
        "application/vnd.pwg-multiplexed": {
          source: "iana"
        },
        "application/vnd.pwg-xhtml-print+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.qualcomm.brew-app-res": {
          source: "iana"
        },
        "application/vnd.quarantainenet": {
          source: "iana"
        },
        "application/vnd.quark.quarkxpress": {
          source: "iana",
          extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
        },
        "application/vnd.quobject-quoxdocument": {
          source: "iana"
        },
        "application/vnd.radisys.moml+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml-audit+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml-audit-conf+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml-audit-conn+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml-audit-dialog+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml-audit-stream+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml-conf+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml-dialog+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml-dialog-base+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml-dialog-fax-detect+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml-dialog-group+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml-dialog-speech+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml-dialog-transform+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.rainstor.data": {
          source: "iana"
        },
        "application/vnd.rapid": {
          source: "iana"
        },
        "application/vnd.rar": {
          source: "iana",
          extensions: ["rar"]
        },
        "application/vnd.realvnc.bed": {
          source: "iana",
          extensions: ["bed"]
        },
        "application/vnd.recordare.musicxml": {
          source: "iana",
          extensions: ["mxl"]
        },
        "application/vnd.recordare.musicxml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["musicxml"]
        },
        "application/vnd.renlearn.rlprint": {
          source: "iana"
        },
        "application/vnd.resilient.logic": {
          source: "iana"
        },
        "application/vnd.restful+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.rig.cryptonote": {
          source: "iana",
          extensions: ["cryptonote"]
        },
        "application/vnd.rim.cod": {
          source: "apache",
          extensions: ["cod"]
        },
        "application/vnd.rn-realmedia": {
          source: "apache",
          extensions: ["rm"]
        },
        "application/vnd.rn-realmedia-vbr": {
          source: "apache",
          extensions: ["rmvb"]
        },
        "application/vnd.route66.link66+xml": {
          source: "iana",
          compressible: true,
          extensions: ["link66"]
        },
        "application/vnd.rs-274x": {
          source: "iana"
        },
        "application/vnd.ruckus.download": {
          source: "iana"
        },
        "application/vnd.s3sms": {
          source: "iana"
        },
        "application/vnd.sailingtracker.track": {
          source: "iana",
          extensions: ["st"]
        },
        "application/vnd.sar": {
          source: "iana"
        },
        "application/vnd.sbm.cid": {
          source: "iana"
        },
        "application/vnd.sbm.mid2": {
          source: "iana"
        },
        "application/vnd.scribus": {
          source: "iana"
        },
        "application/vnd.sealed.3df": {
          source: "iana"
        },
        "application/vnd.sealed.csf": {
          source: "iana"
        },
        "application/vnd.sealed.doc": {
          source: "iana"
        },
        "application/vnd.sealed.eml": {
          source: "iana"
        },
        "application/vnd.sealed.mht": {
          source: "iana"
        },
        "application/vnd.sealed.net": {
          source: "iana"
        },
        "application/vnd.sealed.ppt": {
          source: "iana"
        },
        "application/vnd.sealed.tiff": {
          source: "iana"
        },
        "application/vnd.sealed.xls": {
          source: "iana"
        },
        "application/vnd.sealedmedia.softseal.html": {
          source: "iana"
        },
        "application/vnd.sealedmedia.softseal.pdf": {
          source: "iana"
        },
        "application/vnd.seemail": {
          source: "iana",
          extensions: ["see"]
        },
        "application/vnd.seis+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.sema": {
          source: "iana",
          extensions: ["sema"]
        },
        "application/vnd.semd": {
          source: "iana",
          extensions: ["semd"]
        },
        "application/vnd.semf": {
          source: "iana",
          extensions: ["semf"]
        },
        "application/vnd.shade-save-file": {
          source: "iana"
        },
        "application/vnd.shana.informed.formdata": {
          source: "iana",
          extensions: ["ifm"]
        },
        "application/vnd.shana.informed.formtemplate": {
          source: "iana",
          extensions: ["itp"]
        },
        "application/vnd.shana.informed.interchange": {
          source: "iana",
          extensions: ["iif"]
        },
        "application/vnd.shana.informed.package": {
          source: "iana",
          extensions: ["ipk"]
        },
        "application/vnd.shootproof+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.shopkick+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.shp": {
          source: "iana"
        },
        "application/vnd.shx": {
          source: "iana"
        },
        "application/vnd.sigrok.session": {
          source: "iana"
        },
        "application/vnd.simtech-mindmapper": {
          source: "iana",
          extensions: ["twd", "twds"]
        },
        "application/vnd.siren+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.smaf": {
          source: "iana",
          extensions: ["mmf"]
        },
        "application/vnd.smart.notebook": {
          source: "iana"
        },
        "application/vnd.smart.teacher": {
          source: "iana",
          extensions: ["teacher"]
        },
        "application/vnd.snesdev-page-table": {
          source: "iana"
        },
        "application/vnd.software602.filler.form+xml": {
          source: "iana",
          compressible: true,
          extensions: ["fo"]
        },
        "application/vnd.software602.filler.form-xml-zip": {
          source: "iana"
        },
        "application/vnd.solent.sdkm+xml": {
          source: "iana",
          compressible: true,
          extensions: ["sdkm", "sdkd"]
        },
        "application/vnd.spotfire.dxp": {
          source: "iana",
          extensions: ["dxp"]
        },
        "application/vnd.spotfire.sfs": {
          source: "iana",
          extensions: ["sfs"]
        },
        "application/vnd.sqlite3": {
          source: "iana"
        },
        "application/vnd.sss-cod": {
          source: "iana"
        },
        "application/vnd.sss-dtf": {
          source: "iana"
        },
        "application/vnd.sss-ntf": {
          source: "iana"
        },
        "application/vnd.stardivision.calc": {
          source: "apache",
          extensions: ["sdc"]
        },
        "application/vnd.stardivision.draw": {
          source: "apache",
          extensions: ["sda"]
        },
        "application/vnd.stardivision.impress": {
          source: "apache",
          extensions: ["sdd"]
        },
        "application/vnd.stardivision.math": {
          source: "apache",
          extensions: ["smf"]
        },
        "application/vnd.stardivision.writer": {
          source: "apache",
          extensions: ["sdw", "vor"]
        },
        "application/vnd.stardivision.writer-global": {
          source: "apache",
          extensions: ["sgl"]
        },
        "application/vnd.stepmania.package": {
          source: "iana",
          extensions: ["smzip"]
        },
        "application/vnd.stepmania.stepchart": {
          source: "iana",
          extensions: ["sm"]
        },
        "application/vnd.street-stream": {
          source: "iana"
        },
        "application/vnd.sun.wadl+xml": {
          source: "iana",
          compressible: true,
          extensions: ["wadl"]
        },
        "application/vnd.sun.xml.calc": {
          source: "apache",
          extensions: ["sxc"]
        },
        "application/vnd.sun.xml.calc.template": {
          source: "apache",
          extensions: ["stc"]
        },
        "application/vnd.sun.xml.draw": {
          source: "apache",
          extensions: ["sxd"]
        },
        "application/vnd.sun.xml.draw.template": {
          source: "apache",
          extensions: ["std"]
        },
        "application/vnd.sun.xml.impress": {
          source: "apache",
          extensions: ["sxi"]
        },
        "application/vnd.sun.xml.impress.template": {
          source: "apache",
          extensions: ["sti"]
        },
        "application/vnd.sun.xml.math": {
          source: "apache",
          extensions: ["sxm"]
        },
        "application/vnd.sun.xml.writer": {
          source: "apache",
          extensions: ["sxw"]
        },
        "application/vnd.sun.xml.writer.global": {
          source: "apache",
          extensions: ["sxg"]
        },
        "application/vnd.sun.xml.writer.template": {
          source: "apache",
          extensions: ["stw"]
        },
        "application/vnd.sus-calendar": {
          source: "iana",
          extensions: ["sus", "susp"]
        },
        "application/vnd.svd": {
          source: "iana",
          extensions: ["svd"]
        },
        "application/vnd.swiftview-ics": {
          source: "iana"
        },
        "application/vnd.sycle+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.symbian.install": {
          source: "apache",
          extensions: ["sis", "sisx"]
        },
        "application/vnd.syncml+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true,
          extensions: ["xsm"]
        },
        "application/vnd.syncml.dm+wbxml": {
          source: "iana",
          charset: "UTF-8",
          extensions: ["bdm"]
        },
        "application/vnd.syncml.dm+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true,
          extensions: ["xdm"]
        },
        "application/vnd.syncml.dm.notification": {
          source: "iana"
        },
        "application/vnd.syncml.dmddf+wbxml": {
          source: "iana"
        },
        "application/vnd.syncml.dmddf+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true,
          extensions: ["ddf"]
        },
        "application/vnd.syncml.dmtnds+wbxml": {
          source: "iana"
        },
        "application/vnd.syncml.dmtnds+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/vnd.syncml.ds.notification": {
          source: "iana"
        },
        "application/vnd.tableschema+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.tao.intent-module-archive": {
          source: "iana",
          extensions: ["tao"]
        },
        "application/vnd.tcpdump.pcap": {
          source: "iana",
          extensions: ["pcap", "cap", "dmp"]
        },
        "application/vnd.think-cell.ppttc+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.tmd.mediaflex.api+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.tml": {
          source: "iana"
        },
        "application/vnd.tmobile-livetv": {
          source: "iana",
          extensions: ["tmo"]
        },
        "application/vnd.tri.onesource": {
          source: "iana"
        },
        "application/vnd.trid.tpt": {
          source: "iana",
          extensions: ["tpt"]
        },
        "application/vnd.triscape.mxs": {
          source: "iana",
          extensions: ["mxs"]
        },
        "application/vnd.trueapp": {
          source: "iana",
          extensions: ["tra"]
        },
        "application/vnd.truedoc": {
          source: "iana"
        },
        "application/vnd.ubisoft.webplayer": {
          source: "iana"
        },
        "application/vnd.ufdl": {
          source: "iana",
          extensions: ["ufd", "ufdl"]
        },
        "application/vnd.uiq.theme": {
          source: "iana",
          extensions: ["utz"]
        },
        "application/vnd.umajin": {
          source: "iana",
          extensions: ["umj"]
        },
        "application/vnd.unity": {
          source: "iana",
          extensions: ["unityweb"]
        },
        "application/vnd.uoml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["uoml"]
        },
        "application/vnd.uplanet.alert": {
          source: "iana"
        },
        "application/vnd.uplanet.alert-wbxml": {
          source: "iana"
        },
        "application/vnd.uplanet.bearer-choice": {
          source: "iana"
        },
        "application/vnd.uplanet.bearer-choice-wbxml": {
          source: "iana"
        },
        "application/vnd.uplanet.cacheop": {
          source: "iana"
        },
        "application/vnd.uplanet.cacheop-wbxml": {
          source: "iana"
        },
        "application/vnd.uplanet.channel": {
          source: "iana"
        },
        "application/vnd.uplanet.channel-wbxml": {
          source: "iana"
        },
        "application/vnd.uplanet.list": {
          source: "iana"
        },
        "application/vnd.uplanet.list-wbxml": {
          source: "iana"
        },
        "application/vnd.uplanet.listcmd": {
          source: "iana"
        },
        "application/vnd.uplanet.listcmd-wbxml": {
          source: "iana"
        },
        "application/vnd.uplanet.signal": {
          source: "iana"
        },
        "application/vnd.uri-map": {
          source: "iana"
        },
        "application/vnd.valve.source.material": {
          source: "iana"
        },
        "application/vnd.vcx": {
          source: "iana",
          extensions: ["vcx"]
        },
        "application/vnd.vd-study": {
          source: "iana"
        },
        "application/vnd.vectorworks": {
          source: "iana"
        },
        "application/vnd.vel+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.verimatrix.vcas": {
          source: "iana"
        },
        "application/vnd.veritone.aion+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.veryant.thin": {
          source: "iana"
        },
        "application/vnd.ves.encrypted": {
          source: "iana"
        },
        "application/vnd.vidsoft.vidconference": {
          source: "iana"
        },
        "application/vnd.visio": {
          source: "iana",
          extensions: ["vsd", "vst", "vss", "vsw"]
        },
        "application/vnd.visionary": {
          source: "iana",
          extensions: ["vis"]
        },
        "application/vnd.vividence.scriptfile": {
          source: "iana"
        },
        "application/vnd.vsf": {
          source: "iana",
          extensions: ["vsf"]
        },
        "application/vnd.wap.sic": {
          source: "iana"
        },
        "application/vnd.wap.slc": {
          source: "iana"
        },
        "application/vnd.wap.wbxml": {
          source: "iana",
          charset: "UTF-8",
          extensions: ["wbxml"]
        },
        "application/vnd.wap.wmlc": {
          source: "iana",
          extensions: ["wmlc"]
        },
        "application/vnd.wap.wmlscriptc": {
          source: "iana",
          extensions: ["wmlsc"]
        },
        "application/vnd.webturbo": {
          source: "iana",
          extensions: ["wtb"]
        },
        "application/vnd.wfa.dpp": {
          source: "iana"
        },
        "application/vnd.wfa.p2p": {
          source: "iana"
        },
        "application/vnd.wfa.wsc": {
          source: "iana"
        },
        "application/vnd.windows.devicepairing": {
          source: "iana"
        },
        "application/vnd.wmc": {
          source: "iana"
        },
        "application/vnd.wmf.bootstrap": {
          source: "iana"
        },
        "application/vnd.wolfram.mathematica": {
          source: "iana"
        },
        "application/vnd.wolfram.mathematica.package": {
          source: "iana"
        },
        "application/vnd.wolfram.player": {
          source: "iana",
          extensions: ["nbp"]
        },
        "application/vnd.wordperfect": {
          source: "iana",
          extensions: ["wpd"]
        },
        "application/vnd.wqd": {
          source: "iana",
          extensions: ["wqd"]
        },
        "application/vnd.wrq-hp3000-labelled": {
          source: "iana"
        },
        "application/vnd.wt.stf": {
          source: "iana",
          extensions: ["stf"]
        },
        "application/vnd.wv.csp+wbxml": {
          source: "iana"
        },
        "application/vnd.wv.csp+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.wv.ssp+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.xacml+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.xara": {
          source: "iana",
          extensions: ["xar"]
        },
        "application/vnd.xfdl": {
          source: "iana",
          extensions: ["xfdl"]
        },
        "application/vnd.xfdl.webform": {
          source: "iana"
        },
        "application/vnd.xmi+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.xmpie.cpkg": {
          source: "iana"
        },
        "application/vnd.xmpie.dpkg": {
          source: "iana"
        },
        "application/vnd.xmpie.plan": {
          source: "iana"
        },
        "application/vnd.xmpie.ppkg": {
          source: "iana"
        },
        "application/vnd.xmpie.xlim": {
          source: "iana"
        },
        "application/vnd.yamaha.hv-dic": {
          source: "iana",
          extensions: ["hvd"]
        },
        "application/vnd.yamaha.hv-script": {
          source: "iana",
          extensions: ["hvs"]
        },
        "application/vnd.yamaha.hv-voice": {
          source: "iana",
          extensions: ["hvp"]
        },
        "application/vnd.yamaha.openscoreformat": {
          source: "iana",
          extensions: ["osf"]
        },
        "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
          source: "iana",
          compressible: true,
          extensions: ["osfpvg"]
        },
        "application/vnd.yamaha.remote-setup": {
          source: "iana"
        },
        "application/vnd.yamaha.smaf-audio": {
          source: "iana",
          extensions: ["saf"]
        },
        "application/vnd.yamaha.smaf-phrase": {
          source: "iana",
          extensions: ["spf"]
        },
        "application/vnd.yamaha.through-ngn": {
          source: "iana"
        },
        "application/vnd.yamaha.tunnel-udpencap": {
          source: "iana"
        },
        "application/vnd.yaoweme": {
          source: "iana"
        },
        "application/vnd.yellowriver-custom-menu": {
          source: "iana",
          extensions: ["cmp"]
        },
        "application/vnd.youtube.yt": {
          source: "iana"
        },
        "application/vnd.zul": {
          source: "iana",
          extensions: ["zir", "zirz"]
        },
        "application/vnd.zzazz.deck+xml": {
          source: "iana",
          compressible: true,
          extensions: ["zaz"]
        },
        "application/voicexml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["vxml"]
        },
        "application/voucher-cms+json": {
          source: "iana",
          compressible: true
        },
        "application/vq-rtcpxr": {
          source: "iana"
        },
        "application/wasm": {
          source: "iana",
          compressible: true,
          extensions: ["wasm"]
        },
        "application/watcherinfo+xml": {
          source: "iana",
          compressible: true
        },
        "application/webpush-options+json": {
          source: "iana",
          compressible: true
        },
        "application/whoispp-query": {
          source: "iana"
        },
        "application/whoispp-response": {
          source: "iana"
        },
        "application/widget": {
          source: "iana",
          extensions: ["wgt"]
        },
        "application/winhlp": {
          source: "apache",
          extensions: ["hlp"]
        },
        "application/wita": {
          source: "iana"
        },
        "application/wordperfect5.1": {
          source: "iana"
        },
        "application/wsdl+xml": {
          source: "iana",
          compressible: true,
          extensions: ["wsdl"]
        },
        "application/wspolicy+xml": {
          source: "iana",
          compressible: true,
          extensions: ["wspolicy"]
        },
        "application/x-7z-compressed": {
          source: "apache",
          compressible: false,
          extensions: ["7z"]
        },
        "application/x-abiword": {
          source: "apache",
          extensions: ["abw"]
        },
        "application/x-ace-compressed": {
          source: "apache",
          extensions: ["ace"]
        },
        "application/x-amf": {
          source: "apache"
        },
        "application/x-apple-diskimage": {
          source: "apache",
          extensions: ["dmg"]
        },
        "application/x-arj": {
          compressible: false,
          extensions: ["arj"]
        },
        "application/x-authorware-bin": {
          source: "apache",
          extensions: ["aab", "x32", "u32", "vox"]
        },
        "application/x-authorware-map": {
          source: "apache",
          extensions: ["aam"]
        },
        "application/x-authorware-seg": {
          source: "apache",
          extensions: ["aas"]
        },
        "application/x-bcpio": {
          source: "apache",
          extensions: ["bcpio"]
        },
        "application/x-bdoc": {
          compressible: false,
          extensions: ["bdoc"]
        },
        "application/x-bittorrent": {
          source: "apache",
          extensions: ["torrent"]
        },
        "application/x-blorb": {
          source: "apache",
          extensions: ["blb", "blorb"]
        },
        "application/x-bzip": {
          source: "apache",
          compressible: false,
          extensions: ["bz"]
        },
        "application/x-bzip2": {
          source: "apache",
          compressible: false,
          extensions: ["bz2", "boz"]
        },
        "application/x-cbr": {
          source: "apache",
          extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
        },
        "application/x-cdlink": {
          source: "apache",
          extensions: ["vcd"]
        },
        "application/x-cfs-compressed": {
          source: "apache",
          extensions: ["cfs"]
        },
        "application/x-chat": {
          source: "apache",
          extensions: ["chat"]
        },
        "application/x-chess-pgn": {
          source: "apache",
          extensions: ["pgn"]
        },
        "application/x-chrome-extension": {
          extensions: ["crx"]
        },
        "application/x-cocoa": {
          source: "nginx",
          extensions: ["cco"]
        },
        "application/x-compress": {
          source: "apache"
        },
        "application/x-conference": {
          source: "apache",
          extensions: ["nsc"]
        },
        "application/x-cpio": {
          source: "apache",
          extensions: ["cpio"]
        },
        "application/x-csh": {
          source: "apache",
          extensions: ["csh"]
        },
        "application/x-deb": {
          compressible: false
        },
        "application/x-debian-package": {
          source: "apache",
          extensions: ["deb", "udeb"]
        },
        "application/x-dgc-compressed": {
          source: "apache",
          extensions: ["dgc"]
        },
        "application/x-director": {
          source: "apache",
          extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
        },
        "application/x-doom": {
          source: "apache",
          extensions: ["wad"]
        },
        "application/x-dtbncx+xml": {
          source: "apache",
          compressible: true,
          extensions: ["ncx"]
        },
        "application/x-dtbook+xml": {
          source: "apache",
          compressible: true,
          extensions: ["dtb"]
        },
        "application/x-dtbresource+xml": {
          source: "apache",
          compressible: true,
          extensions: ["res"]
        },
        "application/x-dvi": {
          source: "apache",
          compressible: false,
          extensions: ["dvi"]
        },
        "application/x-envoy": {
          source: "apache",
          extensions: ["evy"]
        },
        "application/x-eva": {
          source: "apache",
          extensions: ["eva"]
        },
        "application/x-font-bdf": {
          source: "apache",
          extensions: ["bdf"]
        },
        "application/x-font-dos": {
          source: "apache"
        },
        "application/x-font-framemaker": {
          source: "apache"
        },
        "application/x-font-ghostscript": {
          source: "apache",
          extensions: ["gsf"]
        },
        "application/x-font-libgrx": {
          source: "apache"
        },
        "application/x-font-linux-psf": {
          source: "apache",
          extensions: ["psf"]
        },
        "application/x-font-pcf": {
          source: "apache",
          extensions: ["pcf"]
        },
        "application/x-font-snf": {
          source: "apache",
          extensions: ["snf"]
        },
        "application/x-font-speedo": {
          source: "apache"
        },
        "application/x-font-sunos-news": {
          source: "apache"
        },
        "application/x-font-type1": {
          source: "apache",
          extensions: ["pfa", "pfb", "pfm", "afm"]
        },
        "application/x-font-vfont": {
          source: "apache"
        },
        "application/x-freearc": {
          source: "apache",
          extensions: ["arc"]
        },
        "application/x-futuresplash": {
          source: "apache",
          extensions: ["spl"]
        },
        "application/x-gca-compressed": {
          source: "apache",
          extensions: ["gca"]
        },
        "application/x-glulx": {
          source: "apache",
          extensions: ["ulx"]
        },
        "application/x-gnumeric": {
          source: "apache",
          extensions: ["gnumeric"]
        },
        "application/x-gramps-xml": {
          source: "apache",
          extensions: ["gramps"]
        },
        "application/x-gtar": {
          source: "apache",
          extensions: ["gtar"]
        },
        "application/x-gzip": {
          source: "apache"
        },
        "application/x-hdf": {
          source: "apache",
          extensions: ["hdf"]
        },
        "application/x-httpd-php": {
          compressible: true,
          extensions: ["php"]
        },
        "application/x-install-instructions": {
          source: "apache",
          extensions: ["install"]
        },
        "application/x-iso9660-image": {
          source: "apache",
          extensions: ["iso"]
        },
        "application/x-iwork-keynote-sffkey": {
          extensions: ["key"]
        },
        "application/x-iwork-numbers-sffnumbers": {
          extensions: ["numbers"]
        },
        "application/x-iwork-pages-sffpages": {
          extensions: ["pages"]
        },
        "application/x-java-archive-diff": {
          source: "nginx",
          extensions: ["jardiff"]
        },
        "application/x-java-jnlp-file": {
          source: "apache",
          compressible: false,
          extensions: ["jnlp"]
        },
        "application/x-javascript": {
          compressible: true
        },
        "application/x-keepass2": {
          extensions: ["kdbx"]
        },
        "application/x-latex": {
          source: "apache",
          compressible: false,
          extensions: ["latex"]
        },
        "application/x-lua-bytecode": {
          extensions: ["luac"]
        },
        "application/x-lzh-compressed": {
          source: "apache",
          extensions: ["lzh", "lha"]
        },
        "application/x-makeself": {
          source: "nginx",
          extensions: ["run"]
        },
        "application/x-mie": {
          source: "apache",
          extensions: ["mie"]
        },
        "application/x-mobipocket-ebook": {
          source: "apache",
          extensions: ["prc", "mobi"]
        },
        "application/x-mpegurl": {
          compressible: false
        },
        "application/x-ms-application": {
          source: "apache",
          extensions: ["application"]
        },
        "application/x-ms-shortcut": {
          source: "apache",
          extensions: ["lnk"]
        },
        "application/x-ms-wmd": {
          source: "apache",
          extensions: ["wmd"]
        },
        "application/x-ms-wmz": {
          source: "apache",
          extensions: ["wmz"]
        },
        "application/x-ms-xbap": {
          source: "apache",
          extensions: ["xbap"]
        },
        "application/x-msaccess": {
          source: "apache",
          extensions: ["mdb"]
        },
        "application/x-msbinder": {
          source: "apache",
          extensions: ["obd"]
        },
        "application/x-mscardfile": {
          source: "apache",
          extensions: ["crd"]
        },
        "application/x-msclip": {
          source: "apache",
          extensions: ["clp"]
        },
        "application/x-msdos-program": {
          extensions: ["exe"]
        },
        "application/x-msdownload": {
          source: "apache",
          extensions: ["exe", "dll", "com", "bat", "msi"]
        },
        "application/x-msmediaview": {
          source: "apache",
          extensions: ["mvb", "m13", "m14"]
        },
        "application/x-msmetafile": {
          source: "apache",
          extensions: ["wmf", "wmz", "emf", "emz"]
        },
        "application/x-msmoney": {
          source: "apache",
          extensions: ["mny"]
        },
        "application/x-mspublisher": {
          source: "apache",
          extensions: ["pub"]
        },
        "application/x-msschedule": {
          source: "apache",
          extensions: ["scd"]
        },
        "application/x-msterminal": {
          source: "apache",
          extensions: ["trm"]
        },
        "application/x-mswrite": {
          source: "apache",
          extensions: ["wri"]
        },
        "application/x-netcdf": {
          source: "apache",
          extensions: ["nc", "cdf"]
        },
        "application/x-ns-proxy-autoconfig": {
          compressible: true,
          extensions: ["pac"]
        },
        "application/x-nzb": {
          source: "apache",
          extensions: ["nzb"]
        },
        "application/x-perl": {
          source: "nginx",
          extensions: ["pl", "pm"]
        },
        "application/x-pilot": {
          source: "nginx",
          extensions: ["prc", "pdb"]
        },
        "application/x-pkcs12": {
          source: "apache",
          compressible: false,
          extensions: ["p12", "pfx"]
        },
        "application/x-pkcs7-certificates": {
          source: "apache",
          extensions: ["p7b", "spc"]
        },
        "application/x-pkcs7-certreqresp": {
          source: "apache",
          extensions: ["p7r"]
        },
        "application/x-pki-message": {
          source: "iana"
        },
        "application/x-rar-compressed": {
          source: "apache",
          compressible: false,
          extensions: ["rar"]
        },
        "application/x-redhat-package-manager": {
          source: "nginx",
          extensions: ["rpm"]
        },
        "application/x-research-info-systems": {
          source: "apache",
          extensions: ["ris"]
        },
        "application/x-sea": {
          source: "nginx",
          extensions: ["sea"]
        },
        "application/x-sh": {
          source: "apache",
          compressible: true,
          extensions: ["sh"]
        },
        "application/x-shar": {
          source: "apache",
          extensions: ["shar"]
        },
        "application/x-shockwave-flash": {
          source: "apache",
          compressible: false,
          extensions: ["swf"]
        },
        "application/x-silverlight-app": {
          source: "apache",
          extensions: ["xap"]
        },
        "application/x-sql": {
          source: "apache",
          extensions: ["sql"]
        },
        "application/x-stuffit": {
          source: "apache",
          compressible: false,
          extensions: ["sit"]
        },
        "application/x-stuffitx": {
          source: "apache",
          extensions: ["sitx"]
        },
        "application/x-subrip": {
          source: "apache",
          extensions: ["srt"]
        },
        "application/x-sv4cpio": {
          source: "apache",
          extensions: ["sv4cpio"]
        },
        "application/x-sv4crc": {
          source: "apache",
          extensions: ["sv4crc"]
        },
        "application/x-t3vm-image": {
          source: "apache",
          extensions: ["t3"]
        },
        "application/x-tads": {
          source: "apache",
          extensions: ["gam"]
        },
        "application/x-tar": {
          source: "apache",
          compressible: true,
          extensions: ["tar"]
        },
        "application/x-tcl": {
          source: "apache",
          extensions: ["tcl", "tk"]
        },
        "application/x-tex": {
          source: "apache",
          extensions: ["tex"]
        },
        "application/x-tex-tfm": {
          source: "apache",
          extensions: ["tfm"]
        },
        "application/x-texinfo": {
          source: "apache",
          extensions: ["texinfo", "texi"]
        },
        "application/x-tgif": {
          source: "apache",
          extensions: ["obj"]
        },
        "application/x-ustar": {
          source: "apache",
          extensions: ["ustar"]
        },
        "application/x-virtualbox-hdd": {
          compressible: true,
          extensions: ["hdd"]
        },
        "application/x-virtualbox-ova": {
          compressible: true,
          extensions: ["ova"]
        },
        "application/x-virtualbox-ovf": {
          compressible: true,
          extensions: ["ovf"]
        },
        "application/x-virtualbox-vbox": {
          compressible: true,
          extensions: ["vbox"]
        },
        "application/x-virtualbox-vbox-extpack": {
          compressible: false,
          extensions: ["vbox-extpack"]
        },
        "application/x-virtualbox-vdi": {
          compressible: true,
          extensions: ["vdi"]
        },
        "application/x-virtualbox-vhd": {
          compressible: true,
          extensions: ["vhd"]
        },
        "application/x-virtualbox-vmdk": {
          compressible: true,
          extensions: ["vmdk"]
        },
        "application/x-wais-source": {
          source: "apache",
          extensions: ["src"]
        },
        "application/x-web-app-manifest+json": {
          compressible: true,
          extensions: ["webapp"]
        },
        "application/x-www-form-urlencoded": {
          source: "iana",
          compressible: true
        },
        "application/x-x509-ca-cert": {
          source: "iana",
          extensions: ["der", "crt", "pem"]
        },
        "application/x-x509-ca-ra-cert": {
          source: "iana"
        },
        "application/x-x509-next-ca-cert": {
          source: "iana"
        },
        "application/x-xfig": {
          source: "apache",
          extensions: ["fig"]
        },
        "application/x-xliff+xml": {
          source: "apache",
          compressible: true,
          extensions: ["xlf"]
        },
        "application/x-xpinstall": {
          source: "apache",
          compressible: false,
          extensions: ["xpi"]
        },
        "application/x-xz": {
          source: "apache",
          extensions: ["xz"]
        },
        "application/x-zmachine": {
          source: "apache",
          extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
        },
        "application/x400-bp": {
          source: "iana"
        },
        "application/xacml+xml": {
          source: "iana",
          compressible: true
        },
        "application/xaml+xml": {
          source: "apache",
          compressible: true,
          extensions: ["xaml"]
        },
        "application/xcap-att+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xav"]
        },
        "application/xcap-caps+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xca"]
        },
        "application/xcap-diff+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xdf"]
        },
        "application/xcap-el+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xel"]
        },
        "application/xcap-error+xml": {
          source: "iana",
          compressible: true
        },
        "application/xcap-ns+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xns"]
        },
        "application/xcon-conference-info+xml": {
          source: "iana",
          compressible: true
        },
        "application/xcon-conference-info-diff+xml": {
          source: "iana",
          compressible: true
        },
        "application/xenc+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xenc"]
        },
        "application/xhtml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xhtml", "xht"]
        },
        "application/xhtml-voice+xml": {
          source: "apache",
          compressible: true
        },
        "application/xliff+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xlf"]
        },
        "application/xml": {
          source: "iana",
          compressible: true,
          extensions: ["xml", "xsl", "xsd", "rng"]
        },
        "application/xml-dtd": {
          source: "iana",
          compressible: true,
          extensions: ["dtd"]
        },
        "application/xml-external-parsed-entity": {
          source: "iana"
        },
        "application/xml-patch+xml": {
          source: "iana",
          compressible: true
        },
        "application/xmpp+xml": {
          source: "iana",
          compressible: true
        },
        "application/xop+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xop"]
        },
        "application/xproc+xml": {
          source: "apache",
          compressible: true,
          extensions: ["xpl"]
        },
        "application/xslt+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xsl", "xslt"]
        },
        "application/xspf+xml": {
          source: "apache",
          compressible: true,
          extensions: ["xspf"]
        },
        "application/xv+xml": {
          source: "iana",
          compressible: true,
          extensions: ["mxml", "xhvml", "xvml", "xvm"]
        },
        "application/yang": {
          source: "iana",
          extensions: ["yang"]
        },
        "application/yang-data+json": {
          source: "iana",
          compressible: true
        },
        "application/yang-data+xml": {
          source: "iana",
          compressible: true
        },
        "application/yang-patch+json": {
          source: "iana",
          compressible: true
        },
        "application/yang-patch+xml": {
          source: "iana",
          compressible: true
        },
        "application/yin+xml": {
          source: "iana",
          compressible: true,
          extensions: ["yin"]
        },
        "application/zip": {
          source: "iana",
          compressible: false,
          extensions: ["zip"]
        },
        "application/zlib": {
          source: "iana"
        },
        "application/zstd": {
          source: "iana"
        },
        "audio/1d-interleaved-parityfec": {
          source: "iana"
        },
        "audio/32kadpcm": {
          source: "iana"
        },
        "audio/3gpp": {
          source: "iana",
          compressible: false,
          extensions: ["3gpp"]
        },
        "audio/3gpp2": {
          source: "iana"
        },
        "audio/aac": {
          source: "iana"
        },
        "audio/ac3": {
          source: "iana"
        },
        "audio/adpcm": {
          source: "apache",
          extensions: ["adp"]
        },
        "audio/amr": {
          source: "iana",
          extensions: ["amr"]
        },
        "audio/amr-wb": {
          source: "iana"
        },
        "audio/amr-wb+": {
          source: "iana"
        },
        "audio/aptx": {
          source: "iana"
        },
        "audio/asc": {
          source: "iana"
        },
        "audio/atrac-advanced-lossless": {
          source: "iana"
        },
        "audio/atrac-x": {
          source: "iana"
        },
        "audio/atrac3": {
          source: "iana"
        },
        "audio/basic": {
          source: "iana",
          compressible: false,
          extensions: ["au", "snd"]
        },
        "audio/bv16": {
          source: "iana"
        },
        "audio/bv32": {
          source: "iana"
        },
        "audio/clearmode": {
          source: "iana"
        },
        "audio/cn": {
          source: "iana"
        },
        "audio/dat12": {
          source: "iana"
        },
        "audio/dls": {
          source: "iana"
        },
        "audio/dsr-es201108": {
          source: "iana"
        },
        "audio/dsr-es202050": {
          source: "iana"
        },
        "audio/dsr-es202211": {
          source: "iana"
        },
        "audio/dsr-es202212": {
          source: "iana"
        },
        "audio/dv": {
          source: "iana"
        },
        "audio/dvi4": {
          source: "iana"
        },
        "audio/eac3": {
          source: "iana"
        },
        "audio/encaprtp": {
          source: "iana"
        },
        "audio/evrc": {
          source: "iana"
        },
        "audio/evrc-qcp": {
          source: "iana"
        },
        "audio/evrc0": {
          source: "iana"
        },
        "audio/evrc1": {
          source: "iana"
        },
        "audio/evrcb": {
          source: "iana"
        },
        "audio/evrcb0": {
          source: "iana"
        },
        "audio/evrcb1": {
          source: "iana"
        },
        "audio/evrcnw": {
          source: "iana"
        },
        "audio/evrcnw0": {
          source: "iana"
        },
        "audio/evrcnw1": {
          source: "iana"
        },
        "audio/evrcwb": {
          source: "iana"
        },
        "audio/evrcwb0": {
          source: "iana"
        },
        "audio/evrcwb1": {
          source: "iana"
        },
        "audio/evs": {
          source: "iana"
        },
        "audio/flexfec": {
          source: "iana"
        },
        "audio/fwdred": {
          source: "iana"
        },
        "audio/g711-0": {
          source: "iana"
        },
        "audio/g719": {
          source: "iana"
        },
        "audio/g722": {
          source: "iana"
        },
        "audio/g7221": {
          source: "iana"
        },
        "audio/g723": {
          source: "iana"
        },
        "audio/g726-16": {
          source: "iana"
        },
        "audio/g726-24": {
          source: "iana"
        },
        "audio/g726-32": {
          source: "iana"
        },
        "audio/g726-40": {
          source: "iana"
        },
        "audio/g728": {
          source: "iana"
        },
        "audio/g729": {
          source: "iana"
        },
        "audio/g7291": {
          source: "iana"
        },
        "audio/g729d": {
          source: "iana"
        },
        "audio/g729e": {
          source: "iana"
        },
        "audio/gsm": {
          source: "iana"
        },
        "audio/gsm-efr": {
          source: "iana"
        },
        "audio/gsm-hr-08": {
          source: "iana"
        },
        "audio/ilbc": {
          source: "iana"
        },
        "audio/ip-mr_v2.5": {
          source: "iana"
        },
        "audio/isac": {
          source: "apache"
        },
        "audio/l16": {
          source: "iana"
        },
        "audio/l20": {
          source: "iana"
        },
        "audio/l24": {
          source: "iana",
          compressible: false
        },
        "audio/l8": {
          source: "iana"
        },
        "audio/lpc": {
          source: "iana"
        },
        "audio/melp": {
          source: "iana"
        },
        "audio/melp1200": {
          source: "iana"
        },
        "audio/melp2400": {
          source: "iana"
        },
        "audio/melp600": {
          source: "iana"
        },
        "audio/mhas": {
          source: "iana"
        },
        "audio/midi": {
          source: "apache",
          extensions: ["mid", "midi", "kar", "rmi"]
        },
        "audio/mobile-xmf": {
          source: "iana",
          extensions: ["mxmf"]
        },
        "audio/mp3": {
          compressible: false,
          extensions: ["mp3"]
        },
        "audio/mp4": {
          source: "iana",
          compressible: false,
          extensions: ["m4a", "mp4a"]
        },
        "audio/mp4a-latm": {
          source: "iana"
        },
        "audio/mpa": {
          source: "iana"
        },
        "audio/mpa-robust": {
          source: "iana"
        },
        "audio/mpeg": {
          source: "iana",
          compressible: false,
          extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
        },
        "audio/mpeg4-generic": {
          source: "iana"
        },
        "audio/musepack": {
          source: "apache"
        },
        "audio/ogg": {
          source: "iana",
          compressible: false,
          extensions: ["oga", "ogg", "spx", "opus"]
        },
        "audio/opus": {
          source: "iana"
        },
        "audio/parityfec": {
          source: "iana"
        },
        "audio/pcma": {
          source: "iana"
        },
        "audio/pcma-wb": {
          source: "iana"
        },
        "audio/pcmu": {
          source: "iana"
        },
        "audio/pcmu-wb": {
          source: "iana"
        },
        "audio/prs.sid": {
          source: "iana"
        },
        "audio/qcelp": {
          source: "iana"
        },
        "audio/raptorfec": {
          source: "iana"
        },
        "audio/red": {
          source: "iana"
        },
        "audio/rtp-enc-aescm128": {
          source: "iana"
        },
        "audio/rtp-midi": {
          source: "iana"
        },
        "audio/rtploopback": {
          source: "iana"
        },
        "audio/rtx": {
          source: "iana"
        },
        "audio/s3m": {
          source: "apache",
          extensions: ["s3m"]
        },
        "audio/scip": {
          source: "iana"
        },
        "audio/silk": {
          source: "apache",
          extensions: ["sil"]
        },
        "audio/smv": {
          source: "iana"
        },
        "audio/smv-qcp": {
          source: "iana"
        },
        "audio/smv0": {
          source: "iana"
        },
        "audio/sofa": {
          source: "iana"
        },
        "audio/sp-midi": {
          source: "iana"
        },
        "audio/speex": {
          source: "iana"
        },
        "audio/t140c": {
          source: "iana"
        },
        "audio/t38": {
          source: "iana"
        },
        "audio/telephone-event": {
          source: "iana"
        },
        "audio/tetra_acelp": {
          source: "iana"
        },
        "audio/tetra_acelp_bb": {
          source: "iana"
        },
        "audio/tone": {
          source: "iana"
        },
        "audio/tsvcis": {
          source: "iana"
        },
        "audio/uemclip": {
          source: "iana"
        },
        "audio/ulpfec": {
          source: "iana"
        },
        "audio/usac": {
          source: "iana"
        },
        "audio/vdvi": {
          source: "iana"
        },
        "audio/vmr-wb": {
          source: "iana"
        },
        "audio/vnd.3gpp.iufp": {
          source: "iana"
        },
        "audio/vnd.4sb": {
          source: "iana"
        },
        "audio/vnd.audiokoz": {
          source: "iana"
        },
        "audio/vnd.celp": {
          source: "iana"
        },
        "audio/vnd.cisco.nse": {
          source: "iana"
        },
        "audio/vnd.cmles.radio-events": {
          source: "iana"
        },
        "audio/vnd.cns.anp1": {
          source: "iana"
        },
        "audio/vnd.cns.inf1": {
          source: "iana"
        },
        "audio/vnd.dece.audio": {
          source: "iana",
          extensions: ["uva", "uvva"]
        },
        "audio/vnd.digital-winds": {
          source: "iana",
          extensions: ["eol"]
        },
        "audio/vnd.dlna.adts": {
          source: "iana"
        },
        "audio/vnd.dolby.heaac.1": {
          source: "iana"
        },
        "audio/vnd.dolby.heaac.2": {
          source: "iana"
        },
        "audio/vnd.dolby.mlp": {
          source: "iana"
        },
        "audio/vnd.dolby.mps": {
          source: "iana"
        },
        "audio/vnd.dolby.pl2": {
          source: "iana"
        },
        "audio/vnd.dolby.pl2x": {
          source: "iana"
        },
        "audio/vnd.dolby.pl2z": {
          source: "iana"
        },
        "audio/vnd.dolby.pulse.1": {
          source: "iana"
        },
        "audio/vnd.dra": {
          source: "iana",
          extensions: ["dra"]
        },
        "audio/vnd.dts": {
          source: "iana",
          extensions: ["dts"]
        },
        "audio/vnd.dts.hd": {
          source: "iana",
          extensions: ["dtshd"]
        },
        "audio/vnd.dts.uhd": {
          source: "iana"
        },
        "audio/vnd.dvb.file": {
          source: "iana"
        },
        "audio/vnd.everad.plj": {
          source: "iana"
        },
        "audio/vnd.hns.audio": {
          source: "iana"
        },
        "audio/vnd.lucent.voice": {
          source: "iana",
          extensions: ["lvp"]
        },
        "audio/vnd.ms-playready.media.pya": {
          source: "iana",
          extensions: ["pya"]
        },
        "audio/vnd.nokia.mobile-xmf": {
          source: "iana"
        },
        "audio/vnd.nortel.vbk": {
          source: "iana"
        },
        "audio/vnd.nuera.ecelp4800": {
          source: "iana",
          extensions: ["ecelp4800"]
        },
        "audio/vnd.nuera.ecelp7470": {
          source: "iana",
          extensions: ["ecelp7470"]
        },
        "audio/vnd.nuera.ecelp9600": {
          source: "iana",
          extensions: ["ecelp9600"]
        },
        "audio/vnd.octel.sbc": {
          source: "iana"
        },
        "audio/vnd.presonus.multitrack": {
          source: "iana"
        },
        "audio/vnd.qcelp": {
          source: "iana"
        },
        "audio/vnd.rhetorex.32kadpcm": {
          source: "iana"
        },
        "audio/vnd.rip": {
          source: "iana",
          extensions: ["rip"]
        },
        "audio/vnd.rn-realaudio": {
          compressible: false
        },
        "audio/vnd.sealedmedia.softseal.mpeg": {
          source: "iana"
        },
        "audio/vnd.vmx.cvsd": {
          source: "iana"
        },
        "audio/vnd.wave": {
          compressible: false
        },
        "audio/vorbis": {
          source: "iana",
          compressible: false
        },
        "audio/vorbis-config": {
          source: "iana"
        },
        "audio/wav": {
          compressible: false,
          extensions: ["wav"]
        },
        "audio/wave": {
          compressible: false,
          extensions: ["wav"]
        },
        "audio/webm": {
          source: "apache",
          compressible: false,
          extensions: ["weba"]
        },
        "audio/x-aac": {
          source: "apache",
          compressible: false,
          extensions: ["aac"]
        },
        "audio/x-aiff": {
          source: "apache",
          extensions: ["aif", "aiff", "aifc"]
        },
        "audio/x-caf": {
          source: "apache",
          compressible: false,
          extensions: ["caf"]
        },
        "audio/x-flac": {
          source: "apache",
          extensions: ["flac"]
        },
        "audio/x-m4a": {
          source: "nginx",
          extensions: ["m4a"]
        },
        "audio/x-matroska": {
          source: "apache",
          extensions: ["mka"]
        },
        "audio/x-mpegurl": {
          source: "apache",
          extensions: ["m3u"]
        },
        "audio/x-ms-wax": {
          source: "apache",
          extensions: ["wax"]
        },
        "audio/x-ms-wma": {
          source: "apache",
          extensions: ["wma"]
        },
        "audio/x-pn-realaudio": {
          source: "apache",
          extensions: ["ram", "ra"]
        },
        "audio/x-pn-realaudio-plugin": {
          source: "apache",
          extensions: ["rmp"]
        },
        "audio/x-realaudio": {
          source: "nginx",
          extensions: ["ra"]
        },
        "audio/x-tta": {
          source: "apache"
        },
        "audio/x-wav": {
          source: "apache",
          extensions: ["wav"]
        },
        "audio/xm": {
          source: "apache",
          extensions: ["xm"]
        },
        "chemical/x-cdx": {
          source: "apache",
          extensions: ["cdx"]
        },
        "chemical/x-cif": {
          source: "apache",
          extensions: ["cif"]
        },
        "chemical/x-cmdf": {
          source: "apache",
          extensions: ["cmdf"]
        },
        "chemical/x-cml": {
          source: "apache",
          extensions: ["cml"]
        },
        "chemical/x-csml": {
          source: "apache",
          extensions: ["csml"]
        },
        "chemical/x-pdb": {
          source: "apache"
        },
        "chemical/x-xyz": {
          source: "apache",
          extensions: ["xyz"]
        },
        "font/collection": {
          source: "iana",
          extensions: ["ttc"]
        },
        "font/otf": {
          source: "iana",
          compressible: true,
          extensions: ["otf"]
        },
        "font/sfnt": {
          source: "iana"
        },
        "font/ttf": {
          source: "iana",
          compressible: true,
          extensions: ["ttf"]
        },
        "font/woff": {
          source: "iana",
          extensions: ["woff"]
        },
        "font/woff2": {
          source: "iana",
          extensions: ["woff2"]
        },
        "image/aces": {
          source: "iana",
          extensions: ["exr"]
        },
        "image/apng": {
          compressible: false,
          extensions: ["apng"]
        },
        "image/avci": {
          source: "iana"
        },
        "image/avcs": {
          source: "iana"
        },
        "image/avif": {
          source: "iana",
          compressible: false,
          extensions: ["avif"]
        },
        "image/bmp": {
          source: "iana",
          compressible: true,
          extensions: ["bmp"]
        },
        "image/cgm": {
          source: "iana",
          extensions: ["cgm"]
        },
        "image/dicom-rle": {
          source: "iana",
          extensions: ["drle"]
        },
        "image/emf": {
          source: "iana",
          extensions: ["emf"]
        },
        "image/fits": {
          source: "iana",
          extensions: ["fits"]
        },
        "image/g3fax": {
          source: "iana",
          extensions: ["g3"]
        },
        "image/gif": {
          source: "iana",
          compressible: false,
          extensions: ["gif"]
        },
        "image/heic": {
          source: "iana",
          extensions: ["heic"]
        },
        "image/heic-sequence": {
          source: "iana",
          extensions: ["heics"]
        },
        "image/heif": {
          source: "iana",
          extensions: ["heif"]
        },
        "image/heif-sequence": {
          source: "iana",
          extensions: ["heifs"]
        },
        "image/hej2k": {
          source: "iana",
          extensions: ["hej2"]
        },
        "image/hsj2": {
          source: "iana",
          extensions: ["hsj2"]
        },
        "image/ief": {
          source: "iana",
          extensions: ["ief"]
        },
        "image/jls": {
          source: "iana",
          extensions: ["jls"]
        },
        "image/jp2": {
          source: "iana",
          compressible: false,
          extensions: ["jp2", "jpg2"]
        },
        "image/jpeg": {
          source: "iana",
          compressible: false,
          extensions: ["jpeg", "jpg", "jpe"]
        },
        "image/jph": {
          source: "iana",
          extensions: ["jph"]
        },
        "image/jphc": {
          source: "iana",
          extensions: ["jhc"]
        },
        "image/jpm": {
          source: "iana",
          compressible: false,
          extensions: ["jpm"]
        },
        "image/jpx": {
          source: "iana",
          compressible: false,
          extensions: ["jpx", "jpf"]
        },
        "image/jxr": {
          source: "iana",
          extensions: ["jxr"]
        },
        "image/jxra": {
          source: "iana",
          extensions: ["jxra"]
        },
        "image/jxrs": {
          source: "iana",
          extensions: ["jxrs"]
        },
        "image/jxs": {
          source: "iana",
          extensions: ["jxs"]
        },
        "image/jxsc": {
          source: "iana",
          extensions: ["jxsc"]
        },
        "image/jxsi": {
          source: "iana",
          extensions: ["jxsi"]
        },
        "image/jxss": {
          source: "iana",
          extensions: ["jxss"]
        },
        "image/ktx": {
          source: "iana",
          extensions: ["ktx"]
        },
        "image/ktx2": {
          source: "iana",
          extensions: ["ktx2"]
        },
        "image/naplps": {
          source: "iana"
        },
        "image/pjpeg": {
          compressible: false
        },
        "image/png": {
          source: "iana",
          compressible: false,
          extensions: ["png"]
        },
        "image/prs.btif": {
          source: "iana",
          extensions: ["btif"]
        },
        "image/prs.pti": {
          source: "iana",
          extensions: ["pti"]
        },
        "image/pwg-raster": {
          source: "iana"
        },
        "image/sgi": {
          source: "apache",
          extensions: ["sgi"]
        },
        "image/svg+xml": {
          source: "iana",
          compressible: true,
          extensions: ["svg", "svgz"]
        },
        "image/t38": {
          source: "iana",
          extensions: ["t38"]
        },
        "image/tiff": {
          source: "iana",
          compressible: false,
          extensions: ["tif", "tiff"]
        },
        "image/tiff-fx": {
          source: "iana",
          extensions: ["tfx"]
        },
        "image/vnd.adobe.photoshop": {
          source: "iana",
          compressible: true,
          extensions: ["psd"]
        },
        "image/vnd.airzip.accelerator.azv": {
          source: "iana",
          extensions: ["azv"]
        },
        "image/vnd.cns.inf2": {
          source: "iana"
        },
        "image/vnd.dece.graphic": {
          source: "iana",
          extensions: ["uvi", "uvvi", "uvg", "uvvg"]
        },
        "image/vnd.djvu": {
          source: "iana",
          extensions: ["djvu", "djv"]
        },
        "image/vnd.dvb.subtitle": {
          source: "iana",
          extensions: ["sub"]
        },
        "image/vnd.dwg": {
          source: "iana",
          extensions: ["dwg"]
        },
        "image/vnd.dxf": {
          source: "iana",
          extensions: ["dxf"]
        },
        "image/vnd.fastbidsheet": {
          source: "iana",
          extensions: ["fbs"]
        },
        "image/vnd.fpx": {
          source: "iana",
          extensions: ["fpx"]
        },
        "image/vnd.fst": {
          source: "iana",
          extensions: ["fst"]
        },
        "image/vnd.fujixerox.edmics-mmr": {
          source: "iana",
          extensions: ["mmr"]
        },
        "image/vnd.fujixerox.edmics-rlc": {
          source: "iana",
          extensions: ["rlc"]
        },
        "image/vnd.globalgraphics.pgb": {
          source: "iana"
        },
        "image/vnd.microsoft.icon": {
          source: "iana",
          compressible: true,
          extensions: ["ico"]
        },
        "image/vnd.mix": {
          source: "iana"
        },
        "image/vnd.mozilla.apng": {
          source: "iana"
        },
        "image/vnd.ms-dds": {
          compressible: true,
          extensions: ["dds"]
        },
        "image/vnd.ms-modi": {
          source: "iana",
          extensions: ["mdi"]
        },
        "image/vnd.ms-photo": {
          source: "apache",
          extensions: ["wdp"]
        },
        "image/vnd.net-fpx": {
          source: "iana",
          extensions: ["npx"]
        },
        "image/vnd.pco.b16": {
          source: "iana",
          extensions: ["b16"]
        },
        "image/vnd.radiance": {
          source: "iana"
        },
        "image/vnd.sealed.png": {
          source: "iana"
        },
        "image/vnd.sealedmedia.softseal.gif": {
          source: "iana"
        },
        "image/vnd.sealedmedia.softseal.jpg": {
          source: "iana"
        },
        "image/vnd.svf": {
          source: "iana"
        },
        "image/vnd.tencent.tap": {
          source: "iana",
          extensions: ["tap"]
        },
        "image/vnd.valve.source.texture": {
          source: "iana",
          extensions: ["vtf"]
        },
        "image/vnd.wap.wbmp": {
          source: "iana",
          extensions: ["wbmp"]
        },
        "image/vnd.xiff": {
          source: "iana",
          extensions: ["xif"]
        },
        "image/vnd.zbrush.pcx": {
          source: "iana",
          extensions: ["pcx"]
        },
        "image/webp": {
          source: "apache",
          extensions: ["webp"]
        },
        "image/wmf": {
          source: "iana",
          extensions: ["wmf"]
        },
        "image/x-3ds": {
          source: "apache",
          extensions: ["3ds"]
        },
        "image/x-cmu-raster": {
          source: "apache",
          extensions: ["ras"]
        },
        "image/x-cmx": {
          source: "apache",
          extensions: ["cmx"]
        },
        "image/x-freehand": {
          source: "apache",
          extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
        },
        "image/x-icon": {
          source: "apache",
          compressible: true,
          extensions: ["ico"]
        },
        "image/x-jng": {
          source: "nginx",
          extensions: ["jng"]
        },
        "image/x-mrsid-image": {
          source: "apache",
          extensions: ["sid"]
        },
        "image/x-ms-bmp": {
          source: "nginx",
          compressible: true,
          extensions: ["bmp"]
        },
        "image/x-pcx": {
          source: "apache",
          extensions: ["pcx"]
        },
        "image/x-pict": {
          source: "apache",
          extensions: ["pic", "pct"]
        },
        "image/x-portable-anymap": {
          source: "apache",
          extensions: ["pnm"]
        },
        "image/x-portable-bitmap": {
          source: "apache",
          extensions: ["pbm"]
        },
        "image/x-portable-graymap": {
          source: "apache",
          extensions: ["pgm"]
        },
        "image/x-portable-pixmap": {
          source: "apache",
          extensions: ["ppm"]
        },
        "image/x-rgb": {
          source: "apache",
          extensions: ["rgb"]
        },
        "image/x-tga": {
          source: "apache",
          extensions: ["tga"]
        },
        "image/x-xbitmap": {
          source: "apache",
          extensions: ["xbm"]
        },
        "image/x-xcf": {
          compressible: false
        },
        "image/x-xpixmap": {
          source: "apache",
          extensions: ["xpm"]
        },
        "image/x-xwindowdump": {
          source: "apache",
          extensions: ["xwd"]
        },
        "message/cpim": {
          source: "iana"
        },
        "message/delivery-status": {
          source: "iana"
        },
        "message/disposition-notification": {
          source: "iana",
          extensions: [
            "disposition-notification"
          ]
        },
        "message/external-body": {
          source: "iana"
        },
        "message/feedback-report": {
          source: "iana"
        },
        "message/global": {
          source: "iana",
          extensions: ["u8msg"]
        },
        "message/global-delivery-status": {
          source: "iana",
          extensions: ["u8dsn"]
        },
        "message/global-disposition-notification": {
          source: "iana",
          extensions: ["u8mdn"]
        },
        "message/global-headers": {
          source: "iana",
          extensions: ["u8hdr"]
        },
        "message/http": {
          source: "iana",
          compressible: false
        },
        "message/imdn+xml": {
          source: "iana",
          compressible: true
        },
        "message/news": {
          source: "iana"
        },
        "message/partial": {
          source: "iana",
          compressible: false
        },
        "message/rfc822": {
          source: "iana",
          compressible: true,
          extensions: ["eml", "mime"]
        },
        "message/s-http": {
          source: "iana"
        },
        "message/sip": {
          source: "iana"
        },
        "message/sipfrag": {
          source: "iana"
        },
        "message/tracking-status": {
          source: "iana"
        },
        "message/vnd.si.simp": {
          source: "iana"
        },
        "message/vnd.wfa.wsc": {
          source: "iana",
          extensions: ["wsc"]
        },
        "model/3mf": {
          source: "iana",
          extensions: ["3mf"]
        },
        "model/e57": {
          source: "iana"
        },
        "model/gltf+json": {
          source: "iana",
          compressible: true,
          extensions: ["gltf"]
        },
        "model/gltf-binary": {
          source: "iana",
          compressible: true,
          extensions: ["glb"]
        },
        "model/iges": {
          source: "iana",
          compressible: false,
          extensions: ["igs", "iges"]
        },
        "model/mesh": {
          source: "iana",
          compressible: false,
          extensions: ["msh", "mesh", "silo"]
        },
        "model/mtl": {
          source: "iana",
          extensions: ["mtl"]
        },
        "model/obj": {
          source: "iana",
          extensions: ["obj"]
        },
        "model/step": {
          source: "iana"
        },
        "model/step+xml": {
          source: "iana",
          compressible: true,
          extensions: ["stpx"]
        },
        "model/step+zip": {
          source: "iana",
          compressible: false,
          extensions: ["stpz"]
        },
        "model/step-xml+zip": {
          source: "iana",
          compressible: false,
          extensions: ["stpxz"]
        },
        "model/stl": {
          source: "iana",
          extensions: ["stl"]
        },
        "model/vnd.collada+xml": {
          source: "iana",
          compressible: true,
          extensions: ["dae"]
        },
        "model/vnd.dwf": {
          source: "iana",
          extensions: ["dwf"]
        },
        "model/vnd.flatland.3dml": {
          source: "iana"
        },
        "model/vnd.gdl": {
          source: "iana",
          extensions: ["gdl"]
        },
        "model/vnd.gs-gdl": {
          source: "apache"
        },
        "model/vnd.gs.gdl": {
          source: "iana"
        },
        "model/vnd.gtw": {
          source: "iana",
          extensions: ["gtw"]
        },
        "model/vnd.moml+xml": {
          source: "iana",
          compressible: true
        },
        "model/vnd.mts": {
          source: "iana",
          extensions: ["mts"]
        },
        "model/vnd.opengex": {
          source: "iana",
          extensions: ["ogex"]
        },
        "model/vnd.parasolid.transmit.binary": {
          source: "iana",
          extensions: ["x_b"]
        },
        "model/vnd.parasolid.transmit.text": {
          source: "iana",
          extensions: ["x_t"]
        },
        "model/vnd.pytha.pyox": {
          source: "iana"
        },
        "model/vnd.rosette.annotated-data-model": {
          source: "iana"
        },
        "model/vnd.sap.vds": {
          source: "iana",
          extensions: ["vds"]
        },
        "model/vnd.usdz+zip": {
          source: "iana",
          compressible: false,
          extensions: ["usdz"]
        },
        "model/vnd.valve.source.compiled-map": {
          source: "iana",
          extensions: ["bsp"]
        },
        "model/vnd.vtu": {
          source: "iana",
          extensions: ["vtu"]
        },
        "model/vrml": {
          source: "iana",
          compressible: false,
          extensions: ["wrl", "vrml"]
        },
        "model/x3d+binary": {
          source: "apache",
          compressible: false,
          extensions: ["x3db", "x3dbz"]
        },
        "model/x3d+fastinfoset": {
          source: "iana",
          extensions: ["x3db"]
        },
        "model/x3d+vrml": {
          source: "apache",
          compressible: false,
          extensions: ["x3dv", "x3dvz"]
        },
        "model/x3d+xml": {
          source: "iana",
          compressible: true,
          extensions: ["x3d", "x3dz"]
        },
        "model/x3d-vrml": {
          source: "iana",
          extensions: ["x3dv"]
        },
        "multipart/alternative": {
          source: "iana",
          compressible: false
        },
        "multipart/appledouble": {
          source: "iana"
        },
        "multipart/byteranges": {
          source: "iana"
        },
        "multipart/digest": {
          source: "iana"
        },
        "multipart/encrypted": {
          source: "iana",
          compressible: false
        },
        "multipart/form-data": {
          source: "iana",
          compressible: false
        },
        "multipart/header-set": {
          source: "iana"
        },
        "multipart/mixed": {
          source: "iana"
        },
        "multipart/multilingual": {
          source: "iana"
        },
        "multipart/parallel": {
          source: "iana"
        },
        "multipart/related": {
          source: "iana",
          compressible: false
        },
        "multipart/report": {
          source: "iana"
        },
        "multipart/signed": {
          source: "iana",
          compressible: false
        },
        "multipart/vnd.bint.med-plus": {
          source: "iana"
        },
        "multipart/voice-message": {
          source: "iana"
        },
        "multipart/x-mixed-replace": {
          source: "iana"
        },
        "text/1d-interleaved-parityfec": {
          source: "iana"
        },
        "text/cache-manifest": {
          source: "iana",
          compressible: true,
          extensions: ["appcache", "manifest"]
        },
        "text/calendar": {
          source: "iana",
          extensions: ["ics", "ifb"]
        },
        "text/calender": {
          compressible: true
        },
        "text/cmd": {
          compressible: true
        },
        "text/coffeescript": {
          extensions: ["coffee", "litcoffee"]
        },
        "text/cql": {
          source: "iana"
        },
        "text/cql-expression": {
          source: "iana"
        },
        "text/cql-identifier": {
          source: "iana"
        },
        "text/css": {
          source: "iana",
          charset: "UTF-8",
          compressible: true,
          extensions: ["css"]
        },
        "text/csv": {
          source: "iana",
          compressible: true,
          extensions: ["csv"]
        },
        "text/csv-schema": {
          source: "iana"
        },
        "text/directory": {
          source: "iana"
        },
        "text/dns": {
          source: "iana"
        },
        "text/ecmascript": {
          source: "iana"
        },
        "text/encaprtp": {
          source: "iana"
        },
        "text/enriched": {
          source: "iana"
        },
        "text/fhirpath": {
          source: "iana"
        },
        "text/flexfec": {
          source: "iana"
        },
        "text/fwdred": {
          source: "iana"
        },
        "text/gff3": {
          source: "iana"
        },
        "text/grammar-ref-list": {
          source: "iana"
        },
        "text/html": {
          source: "iana",
          compressible: true,
          extensions: ["html", "htm", "shtml"]
        },
        "text/jade": {
          extensions: ["jade"]
        },
        "text/javascript": {
          source: "iana",
          compressible: true
        },
        "text/jcr-cnd": {
          source: "iana"
        },
        "text/jsx": {
          compressible: true,
          extensions: ["jsx"]
        },
        "text/less": {
          compressible: true,
          extensions: ["less"]
        },
        "text/markdown": {
          source: "iana",
          compressible: true,
          extensions: ["markdown", "md"]
        },
        "text/mathml": {
          source: "nginx",
          extensions: ["mml"]
        },
        "text/mdx": {
          compressible: true,
          extensions: ["mdx"]
        },
        "text/mizar": {
          source: "iana"
        },
        "text/n3": {
          source: "iana",
          charset: "UTF-8",
          compressible: true,
          extensions: ["n3"]
        },
        "text/parameters": {
          source: "iana",
          charset: "UTF-8"
        },
        "text/parityfec": {
          source: "iana"
        },
        "text/plain": {
          source: "iana",
          compressible: true,
          extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
        },
        "text/provenance-notation": {
          source: "iana",
          charset: "UTF-8"
        },
        "text/prs.fallenstein.rst": {
          source: "iana"
        },
        "text/prs.lines.tag": {
          source: "iana",
          extensions: ["dsc"]
        },
        "text/prs.prop.logic": {
          source: "iana"
        },
        "text/raptorfec": {
          source: "iana"
        },
        "text/red": {
          source: "iana"
        },
        "text/rfc822-headers": {
          source: "iana"
        },
        "text/richtext": {
          source: "iana",
          compressible: true,
          extensions: ["rtx"]
        },
        "text/rtf": {
          source: "iana",
          compressible: true,
          extensions: ["rtf"]
        },
        "text/rtp-enc-aescm128": {
          source: "iana"
        },
        "text/rtploopback": {
          source: "iana"
        },
        "text/rtx": {
          source: "iana"
        },
        "text/sgml": {
          source: "iana",
          extensions: ["sgml", "sgm"]
        },
        "text/shaclc": {
          source: "iana"
        },
        "text/shex": {
          source: "iana",
          extensions: ["shex"]
        },
        "text/slim": {
          extensions: ["slim", "slm"]
        },
        "text/spdx": {
          source: "iana",
          extensions: ["spdx"]
        },
        "text/strings": {
          source: "iana"
        },
        "text/stylus": {
          extensions: ["stylus", "styl"]
        },
        "text/t140": {
          source: "iana"
        },
        "text/tab-separated-values": {
          source: "iana",
          compressible: true,
          extensions: ["tsv"]
        },
        "text/troff": {
          source: "iana",
          extensions: ["t", "tr", "roff", "man", "me", "ms"]
        },
        "text/turtle": {
          source: "iana",
          charset: "UTF-8",
          extensions: ["ttl"]
        },
        "text/ulpfec": {
          source: "iana"
        },
        "text/uri-list": {
          source: "iana",
          compressible: true,
          extensions: ["uri", "uris", "urls"]
        },
        "text/vcard": {
          source: "iana",
          compressible: true,
          extensions: ["vcard"]
        },
        "text/vnd.a": {
          source: "iana"
        },
        "text/vnd.abc": {
          source: "iana"
        },
        "text/vnd.ascii-art": {
          source: "iana"
        },
        "text/vnd.curl": {
          source: "iana",
          extensions: ["curl"]
        },
        "text/vnd.curl.dcurl": {
          source: "apache",
          extensions: ["dcurl"]
        },
        "text/vnd.curl.mcurl": {
          source: "apache",
          extensions: ["mcurl"]
        },
        "text/vnd.curl.scurl": {
          source: "apache",
          extensions: ["scurl"]
        },
        "text/vnd.debian.copyright": {
          source: "iana",
          charset: "UTF-8"
        },
        "text/vnd.dmclientscript": {
          source: "iana"
        },
        "text/vnd.dvb.subtitle": {
          source: "iana",
          extensions: ["sub"]
        },
        "text/vnd.esmertec.theme-descriptor": {
          source: "iana",
          charset: "UTF-8"
        },
        "text/vnd.familysearch.gedcom": {
          source: "iana",
          extensions: ["ged"]
        },
        "text/vnd.ficlab.flt": {
          source: "iana"
        },
        "text/vnd.fly": {
          source: "iana",
          extensions: ["fly"]
        },
        "text/vnd.fmi.flexstor": {
          source: "iana",
          extensions: ["flx"]
        },
        "text/vnd.gml": {
          source: "iana"
        },
        "text/vnd.graphviz": {
          source: "iana",
          extensions: ["gv"]
        },
        "text/vnd.hans": {
          source: "iana"
        },
        "text/vnd.hgl": {
          source: "iana"
        },
        "text/vnd.in3d.3dml": {
          source: "iana",
          extensions: ["3dml"]
        },
        "text/vnd.in3d.spot": {
          source: "iana",
          extensions: ["spot"]
        },
        "text/vnd.iptc.newsml": {
          source: "iana"
        },
        "text/vnd.iptc.nitf": {
          source: "iana"
        },
        "text/vnd.latex-z": {
          source: "iana"
        },
        "text/vnd.motorola.reflex": {
          source: "iana"
        },
        "text/vnd.ms-mediapackage": {
          source: "iana"
        },
        "text/vnd.net2phone.commcenter.command": {
          source: "iana"
        },
        "text/vnd.radisys.msml-basic-layout": {
          source: "iana"
        },
        "text/vnd.senx.warpscript": {
          source: "iana"
        },
        "text/vnd.si.uricatalogue": {
          source: "iana"
        },
        "text/vnd.sosi": {
          source: "iana"
        },
        "text/vnd.sun.j2me.app-descriptor": {
          source: "iana",
          charset: "UTF-8",
          extensions: ["jad"]
        },
        "text/vnd.trolltech.linguist": {
          source: "iana",
          charset: "UTF-8"
        },
        "text/vnd.wap.si": {
          source: "iana"
        },
        "text/vnd.wap.sl": {
          source: "iana"
        },
        "text/vnd.wap.wml": {
          source: "iana",
          extensions: ["wml"]
        },
        "text/vnd.wap.wmlscript": {
          source: "iana",
          extensions: ["wmls"]
        },
        "text/vtt": {
          source: "iana",
          charset: "UTF-8",
          compressible: true,
          extensions: ["vtt"]
        },
        "text/x-asm": {
          source: "apache",
          extensions: ["s", "asm"]
        },
        "text/x-c": {
          source: "apache",
          extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
        },
        "text/x-component": {
          source: "nginx",
          extensions: ["htc"]
        },
        "text/x-fortran": {
          source: "apache",
          extensions: ["f", "for", "f77", "f90"]
        },
        "text/x-gwt-rpc": {
          compressible: true
        },
        "text/x-handlebars-template": {
          extensions: ["hbs"]
        },
        "text/x-java-source": {
          source: "apache",
          extensions: ["java"]
        },
        "text/x-jquery-tmpl": {
          compressible: true
        },
        "text/x-lua": {
          extensions: ["lua"]
        },
        "text/x-markdown": {
          compressible: true,
          extensions: ["mkd"]
        },
        "text/x-nfo": {
          source: "apache",
          extensions: ["nfo"]
        },
        "text/x-opml": {
          source: "apache",
          extensions: ["opml"]
        },
        "text/x-org": {
          compressible: true,
          extensions: ["org"]
        },
        "text/x-pascal": {
          source: "apache",
          extensions: ["p", "pas"]
        },
        "text/x-processing": {
          compressible: true,
          extensions: ["pde"]
        },
        "text/x-sass": {
          extensions: ["sass"]
        },
        "text/x-scss": {
          extensions: ["scss"]
        },
        "text/x-setext": {
          source: "apache",
          extensions: ["etx"]
        },
        "text/x-sfv": {
          source: "apache",
          extensions: ["sfv"]
        },
        "text/x-suse-ymp": {
          compressible: true,
          extensions: ["ymp"]
        },
        "text/x-uuencode": {
          source: "apache",
          extensions: ["uu"]
        },
        "text/x-vcalendar": {
          source: "apache",
          extensions: ["vcs"]
        },
        "text/x-vcard": {
          source: "apache",
          extensions: ["vcf"]
        },
        "text/xml": {
          source: "iana",
          compressible: true,
          extensions: ["xml"]
        },
        "text/xml-external-parsed-entity": {
          source: "iana"
        },
        "text/yaml": {
          compressible: true,
          extensions: ["yaml", "yml"]
        },
        "video/1d-interleaved-parityfec": {
          source: "iana"
        },
        "video/3gpp": {
          source: "iana",
          extensions: ["3gp", "3gpp"]
        },
        "video/3gpp-tt": {
          source: "iana"
        },
        "video/3gpp2": {
          source: "iana",
          extensions: ["3g2"]
        },
        "video/av1": {
          source: "iana"
        },
        "video/bmpeg": {
          source: "iana"
        },
        "video/bt656": {
          source: "iana"
        },
        "video/celb": {
          source: "iana"
        },
        "video/dv": {
          source: "iana"
        },
        "video/encaprtp": {
          source: "iana"
        },
        "video/ffv1": {
          source: "iana"
        },
        "video/flexfec": {
          source: "iana"
        },
        "video/h261": {
          source: "iana",
          extensions: ["h261"]
        },
        "video/h263": {
          source: "iana",
          extensions: ["h263"]
        },
        "video/h263-1998": {
          source: "iana"
        },
        "video/h263-2000": {
          source: "iana"
        },
        "video/h264": {
          source: "iana",
          extensions: ["h264"]
        },
        "video/h264-rcdo": {
          source: "iana"
        },
        "video/h264-svc": {
          source: "iana"
        },
        "video/h265": {
          source: "iana"
        },
        "video/iso.segment": {
          source: "iana",
          extensions: ["m4s"]
        },
        "video/jpeg": {
          source: "iana",
          extensions: ["jpgv"]
        },
        "video/jpeg2000": {
          source: "iana"
        },
        "video/jpm": {
          source: "apache",
          extensions: ["jpm", "jpgm"]
        },
        "video/jxsv": {
          source: "iana"
        },
        "video/mj2": {
          source: "iana",
          extensions: ["mj2", "mjp2"]
        },
        "video/mp1s": {
          source: "iana"
        },
        "video/mp2p": {
          source: "iana"
        },
        "video/mp2t": {
          source: "iana",
          extensions: ["ts"]
        },
        "video/mp4": {
          source: "iana",
          compressible: false,
          extensions: ["mp4", "mp4v", "mpg4"]
        },
        "video/mp4v-es": {
          source: "iana"
        },
        "video/mpeg": {
          source: "iana",
          compressible: false,
          extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
        },
        "video/mpeg4-generic": {
          source: "iana"
        },
        "video/mpv": {
          source: "iana"
        },
        "video/nv": {
          source: "iana"
        },
        "video/ogg": {
          source: "iana",
          compressible: false,
          extensions: ["ogv"]
        },
        "video/parityfec": {
          source: "iana"
        },
        "video/pointer": {
          source: "iana"
        },
        "video/quicktime": {
          source: "iana",
          compressible: false,
          extensions: ["qt", "mov"]
        },
        "video/raptorfec": {
          source: "iana"
        },
        "video/raw": {
          source: "iana"
        },
        "video/rtp-enc-aescm128": {
          source: "iana"
        },
        "video/rtploopback": {
          source: "iana"
        },
        "video/rtx": {
          source: "iana"
        },
        "video/scip": {
          source: "iana"
        },
        "video/smpte291": {
          source: "iana"
        },
        "video/smpte292m": {
          source: "iana"
        },
        "video/ulpfec": {
          source: "iana"
        },
        "video/vc1": {
          source: "iana"
        },
        "video/vc2": {
          source: "iana"
        },
        "video/vnd.cctv": {
          source: "iana"
        },
        "video/vnd.dece.hd": {
          source: "iana",
          extensions: ["uvh", "uvvh"]
        },
        "video/vnd.dece.mobile": {
          source: "iana",
          extensions: ["uvm", "uvvm"]
        },
        "video/vnd.dece.mp4": {
          source: "iana"
        },
        "video/vnd.dece.pd": {
          source: "iana",
          extensions: ["uvp", "uvvp"]
        },
        "video/vnd.dece.sd": {
          source: "iana",
          extensions: ["uvs", "uvvs"]
        },
        "video/vnd.dece.video": {
          source: "iana",
          extensions: ["uvv", "uvvv"]
        },
        "video/vnd.directv.mpeg": {
          source: "iana"
        },
        "video/vnd.directv.mpeg-tts": {
          source: "iana"
        },
        "video/vnd.dlna.mpeg-tts": {
          source: "iana"
        },
        "video/vnd.dvb.file": {
          source: "iana",
          extensions: ["dvb"]
        },
        "video/vnd.fvt": {
          source: "iana",
          extensions: ["fvt"]
        },
        "video/vnd.hns.video": {
          source: "iana"
        },
        "video/vnd.iptvforum.1dparityfec-1010": {
          source: "iana"
        },
        "video/vnd.iptvforum.1dparityfec-2005": {
          source: "iana"
        },
        "video/vnd.iptvforum.2dparityfec-1010": {
          source: "iana"
        },
        "video/vnd.iptvforum.2dparityfec-2005": {
          source: "iana"
        },
        "video/vnd.iptvforum.ttsavc": {
          source: "iana"
        },
        "video/vnd.iptvforum.ttsmpeg2": {
          source: "iana"
        },
        "video/vnd.motorola.video": {
          source: "iana"
        },
        "video/vnd.motorola.videop": {
          source: "iana"
        },
        "video/vnd.mpegurl": {
          source: "iana",
          extensions: ["mxu", "m4u"]
        },
        "video/vnd.ms-playready.media.pyv": {
          source: "iana",
          extensions: ["pyv"]
        },
        "video/vnd.nokia.interleaved-multimedia": {
          source: "iana"
        },
        "video/vnd.nokia.mp4vr": {
          source: "iana"
        },
        "video/vnd.nokia.videovoip": {
          source: "iana"
        },
        "video/vnd.objectvideo": {
          source: "iana"
        },
        "video/vnd.radgamettools.bink": {
          source: "iana"
        },
        "video/vnd.radgamettools.smacker": {
          source: "iana"
        },
        "video/vnd.sealed.mpeg1": {
          source: "iana"
        },
        "video/vnd.sealed.mpeg4": {
          source: "iana"
        },
        "video/vnd.sealed.swf": {
          source: "iana"
        },
        "video/vnd.sealedmedia.softseal.mov": {
          source: "iana"
        },
        "video/vnd.uvvu.mp4": {
          source: "iana",
          extensions: ["uvu", "uvvu"]
        },
        "video/vnd.vivo": {
          source: "iana",
          extensions: ["viv"]
        },
        "video/vnd.youtube.yt": {
          source: "iana"
        },
        "video/vp8": {
          source: "iana"
        },
        "video/vp9": {
          source: "iana"
        },
        "video/webm": {
          source: "apache",
          compressible: false,
          extensions: ["webm"]
        },
        "video/x-f4v": {
          source: "apache",
          extensions: ["f4v"]
        },
        "video/x-fli": {
          source: "apache",
          extensions: ["fli"]
        },
        "video/x-flv": {
          source: "apache",
          compressible: false,
          extensions: ["flv"]
        },
        "video/x-m4v": {
          source: "apache",
          extensions: ["m4v"]
        },
        "video/x-matroska": {
          source: "apache",
          compressible: false,
          extensions: ["mkv", "mk3d", "mks"]
        },
        "video/x-mng": {
          source: "apache",
          extensions: ["mng"]
        },
        "video/x-ms-asf": {
          source: "apache",
          extensions: ["asf", "asx"]
        },
        "video/x-ms-vob": {
          source: "apache",
          extensions: ["vob"]
        },
        "video/x-ms-wm": {
          source: "apache",
          extensions: ["wm"]
        },
        "video/x-ms-wmv": {
          source: "apache",
          compressible: false,
          extensions: ["wmv"]
        },
        "video/x-ms-wmx": {
          source: "apache",
          extensions: ["wmx"]
        },
        "video/x-ms-wvx": {
          source: "apache",
          extensions: ["wvx"]
        },
        "video/x-msvideo": {
          source: "apache",
          extensions: ["avi"]
        },
        "video/x-sgi-movie": {
          source: "apache",
          extensions: ["movie"]
        },
        "video/x-smv": {
          source: "apache",
          extensions: ["smv"]
        },
        "x-conference/x-cooltalk": {
          source: "apache",
          extensions: ["ice"]
        },
        "x-shader/x-fragment": {
          compressible: true
        },
        "x-shader/x-vertex": {
          compressible: true
        }
      };
    }
  });

  // node_modules/mime-db/index.js
  var require_mime_db = __commonJS({
    "node_modules/mime-db/index.js"(exports2, module2) {
      module2.exports = require_db();
    }
  });

  // node_modules/mime-types/index.js
  var require_mime_types = __commonJS({
    "node_modules/mime-types/index.js"(exports2) {
      "use strict";
      var db = require_mime_db();
      var extname = __require("path").extname;
      var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
      var TEXT_TYPE_REGEXP = /^text\//i;
      exports2.charset = charset;
      exports2.charsets = { lookup: charset };
      exports2.contentType = contentType;
      exports2.extension = extension;
      exports2.extensions = /* @__PURE__ */ Object.create(null);
      exports2.lookup = lookup;
      exports2.types = /* @__PURE__ */ Object.create(null);
      populateMaps(exports2.extensions, exports2.types);
      function charset(type) {
        if (!type || typeof type !== "string") {
          return false;
        }
        var match = EXTRACT_TYPE_REGEXP.exec(type);
        var mime = match && db[match[1].toLowerCase()];
        if (mime && mime.charset) {
          return mime.charset;
        }
        if (match && TEXT_TYPE_REGEXP.test(match[1])) {
          return "UTF-8";
        }
        return false;
      }
      function contentType(str) {
        if (!str || typeof str !== "string") {
          return false;
        }
        var mime = str.indexOf("/") === -1 ? exports2.lookup(str) : str;
        if (!mime) {
          return false;
        }
        if (mime.indexOf("charset") === -1) {
          var charset2 = exports2.charset(mime);
          if (charset2)
            mime += "; charset=" + charset2.toLowerCase();
        }
        return mime;
      }
      function extension(type) {
        if (!type || typeof type !== "string") {
          return false;
        }
        var match = EXTRACT_TYPE_REGEXP.exec(type);
        var exts = match && exports2.extensions[match[1].toLowerCase()];
        if (!exts || !exts.length) {
          return false;
        }
        return exts[0];
      }
      function lookup(path2) {
        if (!path2 || typeof path2 !== "string") {
          return false;
        }
        var extension2 = extname("x." + path2).toLowerCase().substr(1);
        if (!extension2) {
          return false;
        }
        return exports2.types[extension2] || false;
      }
      function populateMaps(extensions, types) {
        var preference = ["nginx", "apache", void 0, "iana"];
        Object.keys(db).forEach(function forEachMimeType(type) {
          var mime = db[type];
          var exts = mime.extensions;
          if (!exts || !exts.length) {
            return;
          }
          extensions[type] = exts;
          for (var i = 0; i < exts.length; i++) {
            var extension2 = exts[i];
            if (types[extension2]) {
              var from = preference.indexOf(db[types[extension2]].source);
              var to = preference.indexOf(mime.source);
              if (types[extension2] !== "application/octet-stream" && (from > to || from === to && types[extension2].substr(0, 12) === "application/")) {
                continue;
              }
            }
            types[extension2] = type;
          }
        });
      }
    }
  });

  // node_modules/asynckit/lib/defer.js
  var require_defer = __commonJS({
    "node_modules/asynckit/lib/defer.js"(exports2, module2) {
      module2.exports = defer;
      function defer(fn) {
        var nextTick = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
        if (nextTick) {
          nextTick(fn);
        } else {
          setTimeout(fn, 0);
        }
      }
    }
  });

  // node_modules/asynckit/lib/async.js
  var require_async = __commonJS({
    "node_modules/asynckit/lib/async.js"(exports2, module2) {
      var defer = require_defer();
      module2.exports = async;
      function async(callback) {
        var isAsync = false;
        defer(function() {
          isAsync = true;
        });
        return function async_callback(err, result) {
          if (isAsync) {
            callback(err, result);
          } else {
            defer(function nextTick_callback() {
              callback(err, result);
            });
          }
        };
      }
    }
  });

  // node_modules/asynckit/lib/abort.js
  var require_abort = __commonJS({
    "node_modules/asynckit/lib/abort.js"(exports2, module2) {
      module2.exports = abort;
      function abort(state) {
        Object.keys(state.jobs).forEach(clean.bind(state));
        state.jobs = {};
      }
      function clean(key) {
        if (typeof this.jobs[key] == "function") {
          this.jobs[key]();
        }
      }
    }
  });

  // node_modules/asynckit/lib/iterate.js
  var require_iterate = __commonJS({
    "node_modules/asynckit/lib/iterate.js"(exports2, module2) {
      var async = require_async();
      var abort = require_abort();
      module2.exports = iterate;
      function iterate(list, iterator, state, callback) {
        var key = state["keyedList"] ? state["keyedList"][state.index] : state.index;
        state.jobs[key] = runJob(iterator, key, list[key], function(error, output) {
          if (!(key in state.jobs)) {
            return;
          }
          delete state.jobs[key];
          if (error) {
            abort(state);
          } else {
            state.results[key] = output;
          }
          callback(error, state.results);
        });
      }
      function runJob(iterator, key, item, callback) {
        var aborter;
        if (iterator.length == 2) {
          aborter = iterator(item, async(callback));
        } else {
          aborter = iterator(item, key, async(callback));
        }
        return aborter;
      }
    }
  });

  // node_modules/asynckit/lib/state.js
  var require_state = __commonJS({
    "node_modules/asynckit/lib/state.js"(exports2, module2) {
      module2.exports = state;
      function state(list, sortMethod) {
        var isNamedList = !Array.isArray(list), initState = {
          index: 0,
          keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
          jobs: {},
          results: isNamedList ? {} : [],
          size: isNamedList ? Object.keys(list).length : list.length
        };
        if (sortMethod) {
          initState.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
            return sortMethod(list[a], list[b]);
          });
        }
        return initState;
      }
    }
  });

  // node_modules/asynckit/lib/terminator.js
  var require_terminator = __commonJS({
    "node_modules/asynckit/lib/terminator.js"(exports2, module2) {
      var abort = require_abort();
      var async = require_async();
      module2.exports = terminator;
      function terminator(callback) {
        if (!Object.keys(this.jobs).length) {
          return;
        }
        this.index = this.size;
        abort(this);
        async(callback)(null, this.results);
      }
    }
  });

  // node_modules/asynckit/parallel.js
  var require_parallel = __commonJS({
    "node_modules/asynckit/parallel.js"(exports2, module2) {
      var iterate = require_iterate();
      var initState = require_state();
      var terminator = require_terminator();
      module2.exports = parallel;
      function parallel(list, iterator, callback) {
        var state = initState(list);
        while (state.index < (state["keyedList"] || list).length) {
          iterate(list, iterator, state, function(error, result) {
            if (error) {
              callback(error, result);
              return;
            }
            if (Object.keys(state.jobs).length === 0) {
              callback(null, state.results);
              return;
            }
          });
          state.index++;
        }
        return terminator.bind(state, callback);
      }
    }
  });

  // node_modules/asynckit/serialOrdered.js
  var require_serialOrdered = __commonJS({
    "node_modules/asynckit/serialOrdered.js"(exports2, module2) {
      var iterate = require_iterate();
      var initState = require_state();
      var terminator = require_terminator();
      module2.exports = serialOrdered;
      module2.exports.ascending = ascending;
      module2.exports.descending = descending;
      function serialOrdered(list, iterator, sortMethod, callback) {
        var state = initState(list, sortMethod);
        iterate(list, iterator, state, function iteratorHandler(error, result) {
          if (error) {
            callback(error, result);
            return;
          }
          state.index++;
          if (state.index < (state["keyedList"] || list).length) {
            iterate(list, iterator, state, iteratorHandler);
            return;
          }
          callback(null, state.results);
        });
        return terminator.bind(state, callback);
      }
      function ascending(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
      }
      function descending(a, b) {
        return -1 * ascending(a, b);
      }
    }
  });

  // node_modules/asynckit/serial.js
  var require_serial = __commonJS({
    "node_modules/asynckit/serial.js"(exports2, module2) {
      var serialOrdered = require_serialOrdered();
      module2.exports = serial;
      function serial(list, iterator, callback) {
        return serialOrdered(list, iterator, null, callback);
      }
    }
  });

  // node_modules/asynckit/index.js
  var require_asynckit = __commonJS({
    "node_modules/asynckit/index.js"(exports2, module2) {
      module2.exports = {
        parallel: require_parallel(),
        serial: require_serial(),
        serialOrdered: require_serialOrdered()
      };
    }
  });

  // node_modules/form-data/lib/populate.js
  var require_populate = __commonJS({
    "node_modules/form-data/lib/populate.js"(exports2, module2) {
      module2.exports = function(dst, src) {
        Object.keys(src).forEach(function(prop) {
          dst[prop] = dst[prop] || src[prop];
        });
        return dst;
      };
    }
  });

  // node_modules/form-data/lib/form_data.js
  var require_form_data = __commonJS({
    "node_modules/form-data/lib/form_data.js"(exports2, module2) {
      var CombinedStream = require_combined_stream();
      var util = __require("util");
      var path2 = __require("path");
      var http = __require("http");
      var https = __require("https");
      var parseUrl = __require("url").parse;
      var fs = __require("fs");
      var mime = require_mime_types();
      var asynckit = require_asynckit();
      var populate = require_populate();
      module2.exports = FormData;
      util.inherits(FormData, CombinedStream);
      function FormData(options) {
        if (!(this instanceof FormData)) {
          return new FormData(options);
        }
        this._overheadLength = 0;
        this._valueLength = 0;
        this._valuesToMeasure = [];
        CombinedStream.call(this);
        options = options || {};
        for (var option in options) {
          this[option] = options[option];
        }
      }
      FormData.LINE_BREAK = "\r\n";
      FormData.DEFAULT_CONTENT_TYPE = "application/octet-stream";
      FormData.prototype.append = function(field, value, options) {
        options = options || {};
        if (typeof options == "string") {
          options = { filename: options };
        }
        var append = CombinedStream.prototype.append.bind(this);
        if (typeof value == "number") {
          value = "" + value;
        }
        if (util.isArray(value)) {
          this._error(new Error("Arrays are not supported."));
          return;
        }
        var header = this._multiPartHeader(field, value, options);
        var footer = this._multiPartFooter();
        append(header);
        append(value);
        append(footer);
        this._trackLength(header, value, options);
      };
      FormData.prototype._trackLength = function(header, value, options) {
        var valueLength = 0;
        if (options.knownLength != null) {
          valueLength += +options.knownLength;
        } else if (Buffer.isBuffer(value)) {
          valueLength = value.length;
        } else if (typeof value === "string") {
          valueLength = Buffer.byteLength(value);
        }
        this._valueLength += valueLength;
        this._overheadLength += Buffer.byteLength(header) + FormData.LINE_BREAK.length;
        if (!value || !value.path && !(value.readable && value.hasOwnProperty("httpVersion"))) {
          return;
        }
        if (!options.knownLength) {
          this._valuesToMeasure.push(value);
        }
      };
      FormData.prototype._lengthRetriever = function(value, callback) {
        if (value.hasOwnProperty("fd")) {
          if (value.end != void 0 && value.end != Infinity && value.start != void 0) {
            callback(null, value.end + 1 - (value.start ? value.start : 0));
          } else {
            fs.stat(value.path, function(err, stat) {
              var fileSize;
              if (err) {
                callback(err);
                return;
              }
              fileSize = stat.size - (value.start ? value.start : 0);
              callback(null, fileSize);
            });
          }
        } else if (value.hasOwnProperty("httpVersion")) {
          callback(null, +value.headers["content-length"]);
        } else if (value.hasOwnProperty("httpModule")) {
          value.on("response", function(response) {
            value.pause();
            callback(null, +response.headers["content-length"]);
          });
          value.resume();
        } else {
          callback("Unknown stream");
        }
      };
      FormData.prototype._multiPartHeader = function(field, value, options) {
        if (typeof options.header == "string") {
          return options.header;
        }
        var contentDisposition = this._getContentDisposition(value, options);
        var contentType = this._getContentType(value, options);
        var contents = "";
        var headers = {
          "Content-Disposition": ["form-data", 'name="' + field + '"'].concat(contentDisposition || []),
          "Content-Type": [].concat(contentType || [])
        };
        if (typeof options.header == "object") {
          populate(headers, options.header);
        }
        var header;
        for (var prop in headers) {
          if (!headers.hasOwnProperty(prop))
            continue;
          header = headers[prop];
          if (header == null) {
            continue;
          }
          if (!Array.isArray(header)) {
            header = [header];
          }
          if (header.length) {
            contents += prop + ": " + header.join("; ") + FormData.LINE_BREAK;
          }
        }
        return "--" + this.getBoundary() + FormData.LINE_BREAK + contents + FormData.LINE_BREAK;
      };
      FormData.prototype._getContentDisposition = function(value, options) {
        var filename, contentDisposition;
        if (typeof options.filepath === "string") {
          filename = path2.normalize(options.filepath).replace(/\\/g, "/");
        } else if (options.filename || value.name || value.path) {
          filename = path2.basename(options.filename || value.name || value.path);
        } else if (value.readable && value.hasOwnProperty("httpVersion")) {
          filename = path2.basename(value.client._httpMessage.path || "");
        }
        if (filename) {
          contentDisposition = 'filename="' + filename + '"';
        }
        return contentDisposition;
      };
      FormData.prototype._getContentType = function(value, options) {
        var contentType = options.contentType;
        if (!contentType && value.name) {
          contentType = mime.lookup(value.name);
        }
        if (!contentType && value.path) {
          contentType = mime.lookup(value.path);
        }
        if (!contentType && value.readable && value.hasOwnProperty("httpVersion")) {
          contentType = value.headers["content-type"];
        }
        if (!contentType && (options.filepath || options.filename)) {
          contentType = mime.lookup(options.filepath || options.filename);
        }
        if (!contentType && typeof value == "object") {
          contentType = FormData.DEFAULT_CONTENT_TYPE;
        }
        return contentType;
      };
      FormData.prototype._multiPartFooter = function() {
        return function(next) {
          var footer = FormData.LINE_BREAK;
          var lastPart = this._streams.length === 0;
          if (lastPart) {
            footer += this._lastBoundary();
          }
          next(footer);
        }.bind(this);
      };
      FormData.prototype._lastBoundary = function() {
        return "--" + this.getBoundary() + "--" + FormData.LINE_BREAK;
      };
      FormData.prototype.getHeaders = function(userHeaders) {
        var header;
        var formHeaders = {
          "content-type": "multipart/form-data; boundary=" + this.getBoundary()
        };
        for (header in userHeaders) {
          if (userHeaders.hasOwnProperty(header)) {
            formHeaders[header.toLowerCase()] = userHeaders[header];
          }
        }
        return formHeaders;
      };
      FormData.prototype.setBoundary = function(boundary) {
        this._boundary = boundary;
      };
      FormData.prototype.getBoundary = function() {
        if (!this._boundary) {
          this._generateBoundary();
        }
        return this._boundary;
      };
      FormData.prototype.getBuffer = function() {
        var dataBuffer = new Buffer.alloc(0);
        var boundary = this.getBoundary();
        for (var i = 0, len = this._streams.length; i < len; i++) {
          if (typeof this._streams[i] !== "function") {
            if (Buffer.isBuffer(this._streams[i])) {
              dataBuffer = Buffer.concat([dataBuffer, this._streams[i]]);
            } else {
              dataBuffer = Buffer.concat([dataBuffer, Buffer.from(this._streams[i])]);
            }
            if (typeof this._streams[i] !== "string" || this._streams[i].substring(2, boundary.length + 2) !== boundary) {
              dataBuffer = Buffer.concat([dataBuffer, Buffer.from(FormData.LINE_BREAK)]);
            }
          }
        }
        return Buffer.concat([dataBuffer, Buffer.from(this._lastBoundary())]);
      };
      FormData.prototype._generateBoundary = function() {
        var boundary = "--------------------------";
        for (var i = 0; i < 24; i++) {
          boundary += Math.floor(Math.random() * 10).toString(16);
        }
        this._boundary = boundary;
      };
      FormData.prototype.getLengthSync = function() {
        var knownLength = this._overheadLength + this._valueLength;
        if (this._streams.length) {
          knownLength += this._lastBoundary().length;
        }
        if (!this.hasKnownLength()) {
          this._error(new Error("Cannot calculate proper length in synchronous way."));
        }
        return knownLength;
      };
      FormData.prototype.hasKnownLength = function() {
        var hasKnownLength = true;
        if (this._valuesToMeasure.length) {
          hasKnownLength = false;
        }
        return hasKnownLength;
      };
      FormData.prototype.getLength = function(cb) {
        var knownLength = this._overheadLength + this._valueLength;
        if (this._streams.length) {
          knownLength += this._lastBoundary().length;
        }
        if (!this._valuesToMeasure.length) {
          process.nextTick(cb.bind(this, null, knownLength));
          return;
        }
        asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
          if (err) {
            cb(err);
            return;
          }
          values.forEach(function(length) {
            knownLength += length;
          });
          cb(null, knownLength);
        });
      };
      FormData.prototype.submit = function(params, cb) {
        var request2, options, defaults = { method: "post" };
        if (typeof params == "string") {
          params = parseUrl(params);
          options = populate({
            port: params.port,
            path: params.pathname,
            host: params.hostname,
            protocol: params.protocol
          }, defaults);
        } else {
          options = populate(params, defaults);
          if (!options.port) {
            options.port = options.protocol == "https:" ? 443 : 80;
          }
        }
        options.headers = this.getHeaders(params.headers);
        if (options.protocol == "https:") {
          request2 = https.request(options);
        } else {
          request2 = http.request(options);
        }
        this.getLength(function(err, length) {
          if (err) {
            this._error(err);
            return;
          }
          request2.setHeader("Content-Length", length);
          this.pipe(request2);
          if (cb) {
            var onResponse;
            var callback = function(error, responce) {
              request2.removeListener("error", callback);
              request2.removeListener("response", onResponse);
              return cb.call(this, error, responce);
            };
            onResponse = callback.bind(this, null);
            request2.on("error", callback);
            request2.on("response", onResponse);
          }
        }.bind(this));
        return request2;
      };
      FormData.prototype._error = function(err) {
        if (!this.error) {
          this.error = err;
          this.pause();
          this.emit("error", err);
        }
      };
      FormData.prototype.toString = function() {
        return "[object FormData]";
      };
    }
  });

  // node_modules/formidable/lib/file.js
  var require_file = __commonJS({
    "node_modules/formidable/lib/file.js"(exports2, module2) {
      if (global.GENTLY)
        __require = GENTLY.hijack(__require);
      var util = __require("util");
      var fs = __require("fs");
      var EventEmitter = __require("events").EventEmitter;
      var crypto2 = __require("crypto");
      function File(properties) {
        EventEmitter.call(this);
        this.size = 0;
        this.path = null;
        this.name = null;
        this.type = null;
        this.hash = null;
        this.lastModifiedDate = null;
        this._writeStream = null;
        for (var key in properties) {
          this[key] = properties[key];
        }
        if (typeof this.hash === "string") {
          this.hash = crypto2.createHash(properties.hash);
        } else {
          this.hash = null;
        }
      }
      module2.exports = File;
      util.inherits(File, EventEmitter);
      File.prototype.open = function() {
        this._writeStream = new fs.WriteStream(this.path);
      };
      File.prototype.toJSON = function() {
        var json = {
          size: this.size,
          path: this.path,
          name: this.name,
          type: this.type,
          mtime: this.lastModifiedDate,
          length: this.length,
          filename: this.filename,
          mime: this.mime
        };
        if (this.hash && this.hash != "") {
          json.hash = this.hash;
        }
        return json;
      };
      File.prototype.write = function(buffer, cb) {
        var self2 = this;
        if (self2.hash) {
          self2.hash.update(buffer);
        }
        if (this._writeStream.closed) {
          return cb();
        }
        this._writeStream.write(buffer, function() {
          self2.lastModifiedDate = new Date();
          self2.size += buffer.length;
          self2.emit("progress", self2.size);
          cb();
        });
      };
      File.prototype.end = function(cb) {
        var self2 = this;
        if (self2.hash) {
          self2.hash = self2.hash.digest("hex");
        }
        this._writeStream.end(function() {
          self2.emit("end");
          cb();
        });
      };
    }
  });

  // node_modules/formidable/lib/multipart_parser.js
  var require_multipart_parser = __commonJS({
    "node_modules/formidable/lib/multipart_parser.js"(exports2) {
      var Buffer2 = __require("buffer").Buffer;
      var s = 0;
      var S = {
        PARSER_UNINITIALIZED: s++,
        START: s++,
        START_BOUNDARY: s++,
        HEADER_FIELD_START: s++,
        HEADER_FIELD: s++,
        HEADER_VALUE_START: s++,
        HEADER_VALUE: s++,
        HEADER_VALUE_ALMOST_DONE: s++,
        HEADERS_ALMOST_DONE: s++,
        PART_DATA_START: s++,
        PART_DATA: s++,
        PART_END: s++,
        END: s++
      };
      var f = 1;
      var F = {
        PART_BOUNDARY: f,
        LAST_BOUNDARY: f *= 2
      };
      var LF = 10;
      var CR = 13;
      var SPACE = 32;
      var HYPHEN = 45;
      var COLON = 58;
      var A = 97;
      var Z = 122;
      var lower = function(c) {
        return c | 32;
      };
      for (s in S) {
        exports2[s] = S[s];
      }
      function MultipartParser() {
        this.boundary = null;
        this.boundaryChars = null;
        this.lookbehind = null;
        this.state = S.PARSER_UNINITIALIZED;
        this.index = null;
        this.flags = 0;
      }
      exports2.MultipartParser = MultipartParser;
      MultipartParser.stateToString = function(stateNumber) {
        for (var state in S) {
          var number = S[state];
          if (number === stateNumber)
            return state;
        }
      };
      MultipartParser.prototype.initWithBoundary = function(str) {
        this.boundary = new Buffer2(str.length + 4);
        this.boundary.write("\r\n--", 0);
        this.boundary.write(str, 4);
        this.lookbehind = new Buffer2(this.boundary.length + 8);
        this.state = S.START;
        this.boundaryChars = {};
        for (var i = 0; i < this.boundary.length; i++) {
          this.boundaryChars[this.boundary[i]] = true;
        }
      };
      MultipartParser.prototype.write = function(buffer) {
        var self2 = this, i = 0, len = buffer.length, prevIndex = this.index, index = this.index, state = this.state, flags = this.flags, lookbehind = this.lookbehind, boundary = this.boundary, boundaryChars = this.boundaryChars, boundaryLength = this.boundary.length, boundaryEnd = boundaryLength - 1, bufferLength = buffer.length, c, cl, mark = function(name) {
          self2[name + "Mark"] = i;
        }, clear = function(name) {
          delete self2[name + "Mark"];
        }, callback = function(name, buffer2, start, end) {
          if (start !== void 0 && start === end) {
            return;
          }
          var callbackSymbol = "on" + name.substr(0, 1).toUpperCase() + name.substr(1);
          if (callbackSymbol in self2) {
            self2[callbackSymbol](buffer2, start, end);
          }
        }, dataCallback = function(name, clear2) {
          var markSymbol = name + "Mark";
          if (!(markSymbol in self2)) {
            return;
          }
          if (!clear2) {
            callback(name, buffer, self2[markSymbol], buffer.length);
            self2[markSymbol] = 0;
          } else {
            callback(name, buffer, self2[markSymbol], i);
            delete self2[markSymbol];
          }
        };
        for (i = 0; i < len; i++) {
          c = buffer[i];
          switch (state) {
            case S.PARSER_UNINITIALIZED:
              return i;
            case S.START:
              index = 0;
              state = S.START_BOUNDARY;
            case S.START_BOUNDARY:
              if (index == boundary.length - 2) {
                if (c == HYPHEN) {
                  flags |= F.LAST_BOUNDARY;
                } else if (c != CR) {
                  return i;
                }
                index++;
                break;
              } else if (index - 1 == boundary.length - 2) {
                if (flags & F.LAST_BOUNDARY && c == HYPHEN) {
                  callback("end");
                  state = S.END;
                  flags = 0;
                } else if (!(flags & F.LAST_BOUNDARY) && c == LF) {
                  index = 0;
                  callback("partBegin");
                  state = S.HEADER_FIELD_START;
                } else {
                  return i;
                }
                break;
              }
              if (c != boundary[index + 2]) {
                index = -2;
              }
              if (c == boundary[index + 2]) {
                index++;
              }
              break;
            case S.HEADER_FIELD_START:
              state = S.HEADER_FIELD;
              mark("headerField");
              index = 0;
            case S.HEADER_FIELD:
              if (c == CR) {
                clear("headerField");
                state = S.HEADERS_ALMOST_DONE;
                break;
              }
              index++;
              if (c == HYPHEN) {
                break;
              }
              if (c == COLON) {
                if (index == 1) {
                  return i;
                }
                dataCallback("headerField", true);
                state = S.HEADER_VALUE_START;
                break;
              }
              cl = lower(c);
              if (cl < A || cl > Z) {
                return i;
              }
              break;
            case S.HEADER_VALUE_START:
              if (c == SPACE) {
                break;
              }
              mark("headerValue");
              state = S.HEADER_VALUE;
            case S.HEADER_VALUE:
              if (c == CR) {
                dataCallback("headerValue", true);
                callback("headerEnd");
                state = S.HEADER_VALUE_ALMOST_DONE;
              }
              break;
            case S.HEADER_VALUE_ALMOST_DONE:
              if (c != LF) {
                return i;
              }
              state = S.HEADER_FIELD_START;
              break;
            case S.HEADERS_ALMOST_DONE:
              if (c != LF) {
                return i;
              }
              callback("headersEnd");
              state = S.PART_DATA_START;
              break;
            case S.PART_DATA_START:
              state = S.PART_DATA;
              mark("partData");
            case S.PART_DATA:
              prevIndex = index;
              if (index === 0) {
                i += boundaryEnd;
                while (i < bufferLength && !(buffer[i] in boundaryChars)) {
                  i += boundaryLength;
                }
                i -= boundaryEnd;
                c = buffer[i];
              }
              if (index < boundary.length) {
                if (boundary[index] == c) {
                  if (index === 0) {
                    dataCallback("partData", true);
                  }
                  index++;
                } else {
                  index = 0;
                }
              } else if (index == boundary.length) {
                index++;
                if (c == CR) {
                  flags |= F.PART_BOUNDARY;
                } else if (c == HYPHEN) {
                  flags |= F.LAST_BOUNDARY;
                } else {
                  index = 0;
                }
              } else if (index - 1 == boundary.length) {
                if (flags & F.PART_BOUNDARY) {
                  index = 0;
                  if (c == LF) {
                    flags &= ~F.PART_BOUNDARY;
                    callback("partEnd");
                    callback("partBegin");
                    state = S.HEADER_FIELD_START;
                    break;
                  }
                } else if (flags & F.LAST_BOUNDARY) {
                  if (c == HYPHEN) {
                    callback("partEnd");
                    callback("end");
                    state = S.END;
                    flags = 0;
                  } else {
                    index = 0;
                  }
                } else {
                  index = 0;
                }
              }
              if (index > 0) {
                lookbehind[index - 1] = c;
              } else if (prevIndex > 0) {
                callback("partData", lookbehind, 0, prevIndex);
                prevIndex = 0;
                mark("partData");
                i--;
              }
              break;
            case S.END:
              break;
            default:
              return i;
          }
        }
        dataCallback("headerField");
        dataCallback("headerValue");
        dataCallback("partData");
        this.index = index;
        this.state = state;
        this.flags = flags;
        return len;
      };
      MultipartParser.prototype.end = function() {
        var callback = function(self2, name) {
          var callbackSymbol = "on" + name.substr(0, 1).toUpperCase() + name.substr(1);
          if (callbackSymbol in self2) {
            self2[callbackSymbol]();
          }
        };
        if (this.state == S.HEADER_FIELD_START && this.index === 0 || this.state == S.PART_DATA && this.index == this.boundary.length) {
          callback(this, "partEnd");
          callback(this, "end");
        } else if (this.state != S.END) {
          return new Error("MultipartParser.end(): stream ended unexpectedly: " + this.explain());
        }
      };
      MultipartParser.prototype.explain = function() {
        return "state = " + MultipartParser.stateToString(this.state);
      };
    }
  });

  // node_modules/formidable/lib/querystring_parser.js
  var require_querystring_parser = __commonJS({
    "node_modules/formidable/lib/querystring_parser.js"(exports2) {
      if (global.GENTLY)
        __require = GENTLY.hijack(__require);
      var querystring = __require("querystring");
      function QuerystringParser(maxKeys) {
        this.maxKeys = maxKeys;
        this.buffer = "";
      }
      exports2.QuerystringParser = QuerystringParser;
      QuerystringParser.prototype.write = function(buffer) {
        this.buffer += buffer.toString("ascii");
        return buffer.length;
      };
      QuerystringParser.prototype.end = function() {
        var fields = querystring.parse(this.buffer, "&", "=", { maxKeys: this.maxKeys });
        for (var field in fields) {
          this.onField(field, fields[field]);
        }
        this.buffer = "";
        this.onEnd();
      };
    }
  });

  // node_modules/formidable/lib/octet_parser.js
  var require_octet_parser = __commonJS({
    "node_modules/formidable/lib/octet_parser.js"(exports2) {
      var EventEmitter = __require("events").EventEmitter;
      var util = __require("util");
      function OctetParser(options) {
        if (!(this instanceof OctetParser))
          return new OctetParser(options);
        EventEmitter.call(this);
      }
      util.inherits(OctetParser, EventEmitter);
      exports2.OctetParser = OctetParser;
      OctetParser.prototype.write = function(buffer) {
        this.emit("data", buffer);
        return buffer.length;
      };
      OctetParser.prototype.end = function() {
        this.emit("end");
      };
    }
  });

  // node_modules/formidable/lib/json_parser.js
  var require_json_parser = __commonJS({
    "node_modules/formidable/lib/json_parser.js"(exports2) {
      if (global.GENTLY)
        __require = GENTLY.hijack(__require);
      var Buffer2 = __require("buffer").Buffer;
      function JSONParser(parent) {
        this.parent = parent;
        this.chunks = [];
        this.bytesWritten = 0;
      }
      exports2.JSONParser = JSONParser;
      JSONParser.prototype.write = function(buffer) {
        this.bytesWritten += buffer.length;
        this.chunks.push(buffer);
        return buffer.length;
      };
      JSONParser.prototype.end = function() {
        try {
          var fields = JSON.parse(Buffer2.concat(this.chunks));
          for (var field in fields) {
            this.onField(field, fields[field]);
          }
        } catch (e) {
          this.parent.emit("error", e);
        }
        this.data = null;
        this.onEnd();
      };
    }
  });

  // node_modules/formidable/lib/incoming_form.js
  var require_incoming_form = __commonJS({
    "node_modules/formidable/lib/incoming_form.js"(exports2) {
      if (global.GENTLY)
        __require = GENTLY.hijack(__require);
      var crypto2 = __require("crypto");
      var fs = __require("fs");
      var util = __require("util");
      var path2 = __require("path");
      var File = require_file();
      var MultipartParser = require_multipart_parser().MultipartParser;
      var QuerystringParser = require_querystring_parser().QuerystringParser;
      var OctetParser = require_octet_parser().OctetParser;
      var JSONParser = require_json_parser().JSONParser;
      var StringDecoder = __require("string_decoder").StringDecoder;
      var EventEmitter = __require("events").EventEmitter;
      var Stream = __require("stream").Stream;
      var os = __require("os");
      function IncomingForm(opts) {
        if (!(this instanceof IncomingForm))
          return new IncomingForm(opts);
        EventEmitter.call(this);
        opts = opts || {};
        this.error = null;
        this.ended = false;
        this.maxFields = opts.maxFields || 1e3;
        this.maxFieldsSize = opts.maxFieldsSize || 20 * 1024 * 1024;
        this.maxFileSize = opts.maxFileSize || 200 * 1024 * 1024;
        this.keepExtensions = opts.keepExtensions || false;
        this.uploadDir = opts.uploadDir || os.tmpdir && os.tmpdir() || os.tmpDir();
        this.encoding = opts.encoding || "utf-8";
        this.headers = null;
        this.type = null;
        this.hash = opts.hash || false;
        this.multiples = opts.multiples || false;
        this.bytesReceived = null;
        this.bytesExpected = null;
        this._parser = null;
        this._flushing = 0;
        this._fieldsSize = 0;
        this._fileSize = 0;
        this.openedFiles = [];
        return this;
      }
      util.inherits(IncomingForm, EventEmitter);
      exports2.IncomingForm = IncomingForm;
      IncomingForm.prototype.parse = function(req, cb) {
        this.pause = function() {
          try {
            req.pause();
          } catch (err) {
            if (!this.ended) {
              this._error(err);
            }
            return false;
          }
          return true;
        };
        this.resume = function() {
          try {
            req.resume();
          } catch (err) {
            if (!this.ended) {
              this._error(err);
            }
            return false;
          }
          return true;
        };
        if (cb) {
          var fields = {}, files = {};
          this.on("field", function(name, value) {
            fields[name] = value;
          }).on("file", function(name, file) {
            if (this.multiples) {
              if (files[name]) {
                if (!Array.isArray(files[name])) {
                  files[name] = [files[name]];
                }
                files[name].push(file);
              } else {
                files[name] = file;
              }
            } else {
              files[name] = file;
            }
          }).on("error", function(err) {
            cb(err, fields, files);
          }).on("end", function() {
            cb(null, fields, files);
          });
        }
        this.writeHeaders(req.headers);
        var self2 = this;
        req.on("error", function(err) {
          self2._error(err);
        }).on("aborted", function() {
          self2.emit("aborted");
          self2._error(new Error("Request aborted"));
        }).on("data", function(buffer) {
          self2.write(buffer);
        }).on("end", function() {
          if (self2.error) {
            return;
          }
          var err = self2._parser.end();
          if (err) {
            self2._error(err);
          }
        });
        return this;
      };
      IncomingForm.prototype.writeHeaders = function(headers) {
        this.headers = headers;
        this._parseContentLength();
        this._parseContentType();
      };
      IncomingForm.prototype.write = function(buffer) {
        if (this.error) {
          return;
        }
        if (!this._parser) {
          this._error(new Error("uninitialized parser"));
          return;
        }
        if (typeof this._parser.write !== "function") {
          this._error(new Error("did not expect data"));
          return;
        }
        this.bytesReceived += buffer.length;
        this.emit("progress", this.bytesReceived, this.bytesExpected);
        var bytesParsed = this._parser.write(buffer);
        if (bytesParsed !== buffer.length) {
          this._error(new Error("parser error, " + bytesParsed + " of " + buffer.length + " bytes parsed"));
        }
        return bytesParsed;
      };
      IncomingForm.prototype.pause = function() {
        return false;
      };
      IncomingForm.prototype.resume = function() {
        return false;
      };
      IncomingForm.prototype.onPart = function(part) {
        this.handlePart(part);
      };
      IncomingForm.prototype.handlePart = function(part) {
        var self2 = this;
        if (part.filename === void 0) {
          var value = "", decoder = new StringDecoder(this.encoding);
          part.on("data", function(buffer) {
            self2._fieldsSize += buffer.length;
            if (self2._fieldsSize > self2.maxFieldsSize) {
              self2._error(new Error("maxFieldsSize exceeded, received " + self2._fieldsSize + " bytes of field data"));
              return;
            }
            value += decoder.write(buffer);
          });
          part.on("end", function() {
            self2.emit("field", part.name, value);
          });
          return;
        }
        this._flushing++;
        var file = new File({
          path: this._uploadPath(part.filename),
          name: part.filename,
          type: part.mime,
          hash: self2.hash
        });
        this.emit("fileBegin", part.name, file);
        file.open();
        this.openedFiles.push(file);
        part.on("data", function(buffer) {
          self2._fileSize += buffer.length;
          if (self2._fileSize > self2.maxFileSize) {
            self2._error(new Error("maxFileSize exceeded, received " + self2._fileSize + " bytes of file data"));
            return;
          }
          if (buffer.length == 0) {
            return;
          }
          self2.pause();
          file.write(buffer, function() {
            self2.resume();
          });
        });
        part.on("end", function() {
          file.end(function() {
            self2._flushing--;
            self2.emit("file", part.name, file);
            self2._maybeEnd();
          });
        });
      };
      function dummyParser(self2) {
        return {
          end: function() {
            self2.ended = true;
            self2._maybeEnd();
            return null;
          }
        };
      }
      IncomingForm.prototype._parseContentType = function() {
        if (this.bytesExpected === 0) {
          this._parser = dummyParser(this);
          return;
        }
        if (!this.headers["content-type"]) {
          this._error(new Error("bad content-type header, no content-type"));
          return;
        }
        if (this.headers["content-type"].match(/octet-stream/i)) {
          this._initOctetStream();
          return;
        }
        if (this.headers["content-type"].match(/urlencoded/i)) {
          this._initUrlencoded();
          return;
        }
        if (this.headers["content-type"].match(/multipart/i)) {
          var m = this.headers["content-type"].match(/boundary=(?:"([^"]+)"|([^;]+))/i);
          if (m) {
            this._initMultipart(m[1] || m[2]);
          } else {
            this._error(new Error("bad content-type header, no multipart boundary"));
          }
          return;
        }
        if (this.headers["content-type"].match(/json/i)) {
          this._initJSONencoded();
          return;
        }
        this._error(new Error("bad content-type header, unknown content-type: " + this.headers["content-type"]));
      };
      IncomingForm.prototype._error = function(err) {
        if (this.error || this.ended) {
          return;
        }
        this.error = err;
        this.emit("error", err);
        if (Array.isArray(this.openedFiles)) {
          this.openedFiles.forEach(function(file) {
            file._writeStream.on("error", function() {
            }).destroy();
            setTimeout(fs.unlink, 0, file.path, function(error) {
            });
          });
        }
      };
      IncomingForm.prototype._parseContentLength = function() {
        this.bytesReceived = 0;
        if (this.headers["content-length"]) {
          this.bytesExpected = parseInt(this.headers["content-length"], 10);
        } else if (this.headers["transfer-encoding"] === void 0) {
          this.bytesExpected = 0;
        }
        if (this.bytesExpected !== null) {
          this.emit("progress", this.bytesReceived, this.bytesExpected);
        }
      };
      IncomingForm.prototype._newParser = function() {
        return new MultipartParser();
      };
      IncomingForm.prototype._initMultipart = function(boundary) {
        this.type = "multipart";
        var parser = new MultipartParser(), self2 = this, headerField, headerValue, part;
        parser.initWithBoundary(boundary);
        parser.onPartBegin = function() {
          part = new Stream();
          part.readable = true;
          part.headers = {};
          part.name = null;
          part.filename = null;
          part.mime = null;
          part.transferEncoding = "binary";
          part.transferBuffer = "";
          headerField = "";
          headerValue = "";
        };
        parser.onHeaderField = function(b, start, end) {
          headerField += b.toString(self2.encoding, start, end);
        };
        parser.onHeaderValue = function(b, start, end) {
          headerValue += b.toString(self2.encoding, start, end);
        };
        parser.onHeaderEnd = function() {
          headerField = headerField.toLowerCase();
          part.headers[headerField] = headerValue;
          var m = headerValue.match(/\bname=("([^"]*)"|([^\(\)<>@,;:\\"\/\[\]\?=\{\}\s\t/]+))/i);
          if (headerField == "content-disposition") {
            if (m) {
              part.name = m[2] || m[3] || "";
            }
            part.filename = self2._fileName(headerValue);
          } else if (headerField == "content-type") {
            part.mime = headerValue;
          } else if (headerField == "content-transfer-encoding") {
            part.transferEncoding = headerValue.toLowerCase();
          }
          headerField = "";
          headerValue = "";
        };
        parser.onHeadersEnd = function() {
          switch (part.transferEncoding) {
            case "binary":
            case "7bit":
            case "8bit":
              parser.onPartData = function(b, start, end) {
                part.emit("data", b.slice(start, end));
              };
              parser.onPartEnd = function() {
                part.emit("end");
              };
              break;
            case "base64":
              parser.onPartData = function(b, start, end) {
                part.transferBuffer += b.slice(start, end).toString("ascii");
                var offset = parseInt(part.transferBuffer.length / 4, 10) * 4;
                part.emit("data", new Buffer(part.transferBuffer.substring(0, offset), "base64"));
                part.transferBuffer = part.transferBuffer.substring(offset);
              };
              parser.onPartEnd = function() {
                part.emit("data", new Buffer(part.transferBuffer, "base64"));
                part.emit("end");
              };
              break;
            default:
              return self2._error(new Error("unknown transfer-encoding"));
          }
          self2.onPart(part);
        };
        parser.onEnd = function() {
          self2.ended = true;
          self2._maybeEnd();
        };
        this._parser = parser;
      };
      IncomingForm.prototype._fileName = function(headerValue) {
        var m = headerValue.match(/\bfilename=("(.*?)"|([^\(\)<>@,;:\\"\/\[\]\?=\{\}\s\t/]+))($|;\s)/i);
        if (!m)
          return;
        var match = m[2] || m[3] || "";
        var filename = match.substr(match.lastIndexOf("\\") + 1);
        filename = filename.replace(/%22/g, '"');
        filename = filename.replace(/&#([\d]{4});/g, function(m2, code) {
          return String.fromCharCode(code);
        });
        return filename;
      };
      IncomingForm.prototype._initUrlencoded = function() {
        this.type = "urlencoded";
        var parser = new QuerystringParser(this.maxFields), self2 = this;
        parser.onField = function(key, val) {
          self2.emit("field", key, val);
        };
        parser.onEnd = function() {
          self2.ended = true;
          self2._maybeEnd();
        };
        this._parser = parser;
      };
      IncomingForm.prototype._initOctetStream = function() {
        this.type = "octet-stream";
        var filename = this.headers["x-file-name"];
        var mime = this.headers["content-type"];
        var file = new File({
          path: this._uploadPath(filename),
          name: filename,
          type: mime
        });
        this.emit("fileBegin", filename, file);
        file.open();
        this.openedFiles.push(file);
        this._flushing++;
        var self2 = this;
        self2._parser = new OctetParser();
        var outstandingWrites = 0;
        self2._parser.on("data", function(buffer) {
          self2.pause();
          outstandingWrites++;
          file.write(buffer, function() {
            outstandingWrites--;
            self2.resume();
            if (self2.ended) {
              self2._parser.emit("doneWritingFile");
            }
          });
        });
        self2._parser.on("end", function() {
          self2._flushing--;
          self2.ended = true;
          var done = function() {
            file.end(function() {
              self2.emit("file", "file", file);
              self2._maybeEnd();
            });
          };
          if (outstandingWrites === 0) {
            done();
          } else {
            self2._parser.once("doneWritingFile", done);
          }
        });
      };
      IncomingForm.prototype._initJSONencoded = function() {
        this.type = "json";
        var parser = new JSONParser(this), self2 = this;
        parser.onField = function(key, val) {
          self2.emit("field", key, val);
        };
        parser.onEnd = function() {
          self2.ended = true;
          self2._maybeEnd();
        };
        this._parser = parser;
      };
      IncomingForm.prototype._uploadPath = function(filename) {
        var buf = crypto2.randomBytes(16);
        var name = "upload_" + buf.toString("hex");
        if (this.keepExtensions) {
          var ext = path2.extname(filename);
          ext = ext.replace(/(\.[a-z0-9]+).*/i, "$1");
          name += ext;
        }
        return path2.join(this.uploadDir, name);
      };
      IncomingForm.prototype._maybeEnd = function() {
        if (!this.ended || this._flushing || this.error) {
          return;
        }
        this.emit("end");
      };
    }
  });

  // node_modules/formidable/lib/index.js
  var require_lib2 = __commonJS({
    "node_modules/formidable/lib/index.js"(exports2, module2) {
      var IncomingForm = require_incoming_form().IncomingForm;
      IncomingForm.IncomingForm = IncomingForm;
      module2.exports = IncomingForm;
    }
  });

  // node_modules/ms/index.js
  var require_ms = __commonJS({
    "node_modules/ms/index.js"(exports2, module2) {
      var s = 1e3;
      var m = s * 60;
      var h = m * 60;
      var d = h * 24;
      var w = d * 7;
      var y = d * 365.25;
      module2.exports = function(val, options) {
        options = options || {};
        var type = typeof val;
        if (type === "string" && val.length > 0) {
          return parse(val);
        } else if (type === "number" && isFinite(val)) {
          return options.long ? fmtLong(val) : fmtShort(val);
        }
        throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
      };
      function parse(str) {
        str = String(str);
        if (str.length > 100) {
          return;
        }
        var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
        if (!match) {
          return;
        }
        var n = parseFloat(match[1]);
        var type = (match[2] || "ms").toLowerCase();
        switch (type) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return n * y;
          case "weeks":
          case "week":
          case "w":
            return n * w;
          case "days":
          case "day":
          case "d":
            return n * d;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return n * h;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return n * m;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return n * s;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return n;
          default:
            return void 0;
        }
      }
      function fmtShort(ms) {
        var msAbs = Math.abs(ms);
        if (msAbs >= d) {
          return Math.round(ms / d) + "d";
        }
        if (msAbs >= h) {
          return Math.round(ms / h) + "h";
        }
        if (msAbs >= m) {
          return Math.round(ms / m) + "m";
        }
        if (msAbs >= s) {
          return Math.round(ms / s) + "s";
        }
        return ms + "ms";
      }
      function fmtLong(ms) {
        var msAbs = Math.abs(ms);
        if (msAbs >= d) {
          return plural(ms, msAbs, d, "day");
        }
        if (msAbs >= h) {
          return plural(ms, msAbs, h, "hour");
        }
        if (msAbs >= m) {
          return plural(ms, msAbs, m, "minute");
        }
        if (msAbs >= s) {
          return plural(ms, msAbs, s, "second");
        }
        return ms + " ms";
      }
      function plural(ms, msAbs, n, name) {
        var isPlural = msAbs >= n * 1.5;
        return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
      }
    }
  });

  // node_modules/superagent/node_modules/debug/src/common.js
  var require_common = __commonJS({
    "node_modules/superagent/node_modules/debug/src/common.js"(exports2, module2) {
      function setup(env) {
        createDebug.debug = createDebug;
        createDebug.default = createDebug;
        createDebug.coerce = coerce;
        createDebug.disable = disable;
        createDebug.enable = enable;
        createDebug.enabled = enabled;
        createDebug.humanize = require_ms();
        createDebug.destroy = destroy;
        Object.keys(env).forEach((key) => {
          createDebug[key] = env[key];
        });
        createDebug.names = [];
        createDebug.skips = [];
        createDebug.formatters = {};
        function selectColor(namespace) {
          let hash = 0;
          for (let i = 0; i < namespace.length; i++) {
            hash = (hash << 5) - hash + namespace.charCodeAt(i);
            hash |= 0;
          }
          return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
        }
        createDebug.selectColor = selectColor;
        function createDebug(namespace) {
          let prevTime;
          let enableOverride = null;
          let namespacesCache;
          let enabledCache;
          function debug(...args) {
            if (!debug.enabled) {
              return;
            }
            const self2 = debug;
            const curr = Number(new Date());
            const ms = curr - (prevTime || curr);
            self2.diff = ms;
            self2.prev = prevTime;
            self2.curr = curr;
            prevTime = curr;
            args[0] = createDebug.coerce(args[0]);
            if (typeof args[0] !== "string") {
              args.unshift("%O");
            }
            let index = 0;
            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
              if (match === "%%") {
                return "%";
              }
              index++;
              const formatter = createDebug.formatters[format];
              if (typeof formatter === "function") {
                const val = args[index];
                match = formatter.call(self2, val);
                args.splice(index, 1);
                index--;
              }
              return match;
            });
            createDebug.formatArgs.call(self2, args);
            const logFn = self2.log || createDebug.log;
            logFn.apply(self2, args);
          }
          debug.namespace = namespace;
          debug.useColors = createDebug.useColors();
          debug.color = createDebug.selectColor(namespace);
          debug.extend = extend;
          debug.destroy = createDebug.destroy;
          Object.defineProperty(debug, "enabled", {
            enumerable: true,
            configurable: false,
            get: () => {
              if (enableOverride !== null) {
                return enableOverride;
              }
              if (namespacesCache !== createDebug.namespaces) {
                namespacesCache = createDebug.namespaces;
                enabledCache = createDebug.enabled(namespace);
              }
              return enabledCache;
            },
            set: (v) => {
              enableOverride = v;
            }
          });
          if (typeof createDebug.init === "function") {
            createDebug.init(debug);
          }
          return debug;
        }
        function extend(namespace, delimiter) {
          const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
          newDebug.log = this.log;
          return newDebug;
        }
        function enable(namespaces) {
          createDebug.save(namespaces);
          createDebug.namespaces = namespaces;
          createDebug.names = [];
          createDebug.skips = [];
          let i;
          const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
          const len = split.length;
          for (i = 0; i < len; i++) {
            if (!split[i]) {
              continue;
            }
            namespaces = split[i].replace(/\*/g, ".*?");
            if (namespaces[0] === "-") {
              createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
            } else {
              createDebug.names.push(new RegExp("^" + namespaces + "$"));
            }
          }
        }
        function disable() {
          const namespaces = [
            ...createDebug.names.map(toNamespace),
            ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
          ].join(",");
          createDebug.enable("");
          return namespaces;
        }
        function enabled(name) {
          if (name[name.length - 1] === "*") {
            return true;
          }
          let i;
          let len;
          for (i = 0, len = createDebug.skips.length; i < len; i++) {
            if (createDebug.skips[i].test(name)) {
              return false;
            }
          }
          for (i = 0, len = createDebug.names.length; i < len; i++) {
            if (createDebug.names[i].test(name)) {
              return true;
            }
          }
          return false;
        }
        function toNamespace(regexp) {
          return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
        }
        function coerce(val) {
          if (val instanceof Error) {
            return val.stack || val.message;
          }
          return val;
        }
        function destroy() {
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
        createDebug.enable(createDebug.load());
        return createDebug;
      }
      module2.exports = setup;
    }
  });

  // node_modules/superagent/node_modules/debug/src/browser.js
  var require_browser = __commonJS({
    "node_modules/superagent/node_modules/debug/src/browser.js"(exports2, module2) {
      exports2.formatArgs = formatArgs;
      exports2.save = save;
      exports2.load = load;
      exports2.useColors = useColors;
      exports2.storage = localstorage();
      exports2.destroy = (() => {
        let warned = false;
        return () => {
          if (!warned) {
            warned = true;
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
          }
        };
      })();
      exports2.colors = [
        "#0000CC",
        "#0000FF",
        "#0033CC",
        "#0033FF",
        "#0066CC",
        "#0066FF",
        "#0099CC",
        "#0099FF",
        "#00CC00",
        "#00CC33",
        "#00CC66",
        "#00CC99",
        "#00CCCC",
        "#00CCFF",
        "#3300CC",
        "#3300FF",
        "#3333CC",
        "#3333FF",
        "#3366CC",
        "#3366FF",
        "#3399CC",
        "#3399FF",
        "#33CC00",
        "#33CC33",
        "#33CC66",
        "#33CC99",
        "#33CCCC",
        "#33CCFF",
        "#6600CC",
        "#6600FF",
        "#6633CC",
        "#6633FF",
        "#66CC00",
        "#66CC33",
        "#9900CC",
        "#9900FF",
        "#9933CC",
        "#9933FF",
        "#99CC00",
        "#99CC33",
        "#CC0000",
        "#CC0033",
        "#CC0066",
        "#CC0099",
        "#CC00CC",
        "#CC00FF",
        "#CC3300",
        "#CC3333",
        "#CC3366",
        "#CC3399",
        "#CC33CC",
        "#CC33FF",
        "#CC6600",
        "#CC6633",
        "#CC9900",
        "#CC9933",
        "#CCCC00",
        "#CCCC33",
        "#FF0000",
        "#FF0033",
        "#FF0066",
        "#FF0099",
        "#FF00CC",
        "#FF00FF",
        "#FF3300",
        "#FF3333",
        "#FF3366",
        "#FF3399",
        "#FF33CC",
        "#FF33FF",
        "#FF6600",
        "#FF6633",
        "#FF9900",
        "#FF9933",
        "#FFCC00",
        "#FFCC33"
      ];
      function useColors() {
        if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
          return true;
        }
        if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
          return false;
        }
        return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
      }
      function formatArgs(args) {
        args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
        if (!this.useColors) {
          return;
        }
        const c = "color: " + this.color;
        args.splice(1, 0, c, "color: inherit");
        let index = 0;
        let lastC = 0;
        args[0].replace(/%[a-zA-Z%]/g, (match) => {
          if (match === "%%") {
            return;
          }
          index++;
          if (match === "%c") {
            lastC = index;
          }
        });
        args.splice(lastC, 0, c);
      }
      exports2.log = console.debug || console.log || (() => {
      });
      function save(namespaces) {
        try {
          if (namespaces) {
            exports2.storage.setItem("debug", namespaces);
          } else {
            exports2.storage.removeItem("debug");
          }
        } catch (error) {
        }
      }
      function load() {
        let r;
        try {
          r = exports2.storage.getItem("debug");
        } catch (error) {
        }
        if (!r && typeof process !== "undefined" && "env" in process) {
          r = process.env.DEBUG;
        }
        return r;
      }
      function localstorage() {
        try {
          return localStorage;
        } catch (error) {
        }
      }
      module2.exports = require_common()(exports2);
      var { formatters } = module2.exports;
      formatters.j = function(v) {
        try {
          return JSON.stringify(v);
        } catch (error) {
          return "[UnexpectedJSONParseError]: " + error.message;
        }
      };
    }
  });

  // node_modules/has-flag/index.js
  var require_has_flag = __commonJS({
    "node_modules/has-flag/index.js"(exports2, module2) {
      "use strict";
      module2.exports = (flag, argv = process.argv) => {
        const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
        const position = argv.indexOf(prefix + flag);
        const terminatorPosition = argv.indexOf("--");
        return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
      };
    }
  });

  // node_modules/supports-color/index.js
  var require_supports_color = __commonJS({
    "node_modules/supports-color/index.js"(exports2, module2) {
      "use strict";
      var os = __require("os");
      var tty = __require("tty");
      var hasFlag = require_has_flag();
      var { env } = process;
      var flagForceColor;
      if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
        flagForceColor = 0;
      } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
        flagForceColor = 1;
      }
      function envForceColor() {
        if ("FORCE_COLOR" in env) {
          if (env.FORCE_COLOR === "true") {
            return 1;
          }
          if (env.FORCE_COLOR === "false") {
            return 0;
          }
          return env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
        }
      }
      function translateLevel(level) {
        if (level === 0) {
          return false;
        }
        return {
          level,
          hasBasic: true,
          has256: level >= 2,
          has16m: level >= 3
        };
      }
      function supportsColor(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
        const noFlagForceColor = envForceColor();
        if (noFlagForceColor !== void 0) {
          flagForceColor = noFlagForceColor;
        }
        const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
        if (forceColor === 0) {
          return 0;
        }
        if (sniffFlags) {
          if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
            return 3;
          }
          if (hasFlag("color=256")) {
            return 2;
          }
        }
        if (haveStream && !streamIsTTY && forceColor === void 0) {
          return 0;
        }
        const min = forceColor || 0;
        if (env.TERM === "dumb") {
          return min;
        }
        if (process.platform === "win32") {
          const osRelease = os.release().split(".");
          if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
            return Number(osRelease[2]) >= 14931 ? 3 : 2;
          }
          return 1;
        }
        if ("CI" in env) {
          if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE", "DRONE"].some((sign2) => sign2 in env) || env.CI_NAME === "codeship") {
            return 1;
          }
          return min;
        }
        if ("TEAMCITY_VERSION" in env) {
          return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
        }
        if (env.COLORTERM === "truecolor") {
          return 3;
        }
        if ("TERM_PROGRAM" in env) {
          const version = Number.parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
          switch (env.TERM_PROGRAM) {
            case "iTerm.app":
              return version >= 3 ? 3 : 2;
            case "Apple_Terminal":
              return 2;
          }
        }
        if (/-256(color)?$/i.test(env.TERM)) {
          return 2;
        }
        if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
          return 1;
        }
        if ("COLORTERM" in env) {
          return 1;
        }
        return min;
      }
      function getSupportLevel(stream, options = {}) {
        const level = supportsColor(stream, __spreadValues({
          streamIsTTY: stream && stream.isTTY
        }, options));
        return translateLevel(level);
      }
      module2.exports = {
        supportsColor: getSupportLevel,
        stdout: getSupportLevel({ isTTY: tty.isatty(1) }),
        stderr: getSupportLevel({ isTTY: tty.isatty(2) })
      };
    }
  });

  // node_modules/superagent/node_modules/debug/src/node.js
  var require_node = __commonJS({
    "node_modules/superagent/node_modules/debug/src/node.js"(exports2, module2) {
      var tty = __require("tty");
      var util = __require("util");
      exports2.init = init;
      exports2.log = log;
      exports2.formatArgs = formatArgs;
      exports2.save = save;
      exports2.load = load;
      exports2.useColors = useColors;
      exports2.destroy = util.deprecate(() => {
      }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      exports2.colors = [6, 2, 3, 4, 5, 1];
      try {
        const supportsColor = require_supports_color();
        if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
          exports2.colors = [
            20,
            21,
            26,
            27,
            32,
            33,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            56,
            57,
            62,
            63,
            68,
            69,
            74,
            75,
            76,
            77,
            78,
            79,
            80,
            81,
            92,
            93,
            98,
            99,
            112,
            113,
            128,
            129,
            134,
            135,
            148,
            149,
            160,
            161,
            162,
            163,
            164,
            165,
            166,
            167,
            168,
            169,
            170,
            171,
            172,
            173,
            178,
            179,
            184,
            185,
            196,
            197,
            198,
            199,
            200,
            201,
            202,
            203,
            204,
            205,
            206,
            207,
            208,
            209,
            214,
            215,
            220,
            221
          ];
        }
      } catch (error) {
      }
      exports2.inspectOpts = Object.keys(process.env).filter((key) => {
        return /^debug_/i.test(key);
      }).reduce((obj, key) => {
        const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
          return k.toUpperCase();
        });
        let val = process.env[key];
        if (/^(yes|on|true|enabled)$/i.test(val)) {
          val = true;
        } else if (/^(no|off|false|disabled)$/i.test(val)) {
          val = false;
        } else if (val === "null") {
          val = null;
        } else {
          val = Number(val);
        }
        obj[prop] = val;
        return obj;
      }, {});
      function useColors() {
        return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
      }
      function formatArgs(args) {
        const { namespace: name, useColors: useColors2 } = this;
        if (useColors2) {
          const c = this.color;
          const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
          const prefix = `  ${colorCode};1m${name} \x1B[0m`;
          args[0] = prefix + args[0].split("\n").join("\n" + prefix);
          args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
        } else {
          args[0] = getDate() + name + " " + args[0];
        }
      }
      function getDate() {
        if (exports2.inspectOpts.hideDate) {
          return "";
        }
        return new Date().toISOString() + " ";
      }
      function log(...args) {
        return process.stderr.write(util.format(...args) + "\n");
      }
      function save(namespaces) {
        if (namespaces) {
          process.env.DEBUG = namespaces;
        } else {
          delete process.env.DEBUG;
        }
      }
      function load() {
        return process.env.DEBUG;
      }
      function init(debug) {
        debug.inspectOpts = {};
        const keys = Object.keys(exports2.inspectOpts);
        for (let i = 0; i < keys.length; i++) {
          debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
        }
      }
      module2.exports = require_common()(exports2);
      var { formatters } = module2.exports;
      formatters.o = function(v) {
        this.inspectOpts.colors = this.useColors;
        return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
      };
      formatters.O = function(v) {
        this.inspectOpts.colors = this.useColors;
        return util.inspect(v, this.inspectOpts);
      };
    }
  });

  // node_modules/superagent/node_modules/debug/src/index.js
  var require_src2 = __commonJS({
    "node_modules/superagent/node_modules/debug/src/index.js"(exports2, module2) {
      if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
        module2.exports = require_browser();
      } else {
        module2.exports = require_node();
      }
    }
  });

  // node_modules/cookiejar/cookiejar.js
  var require_cookiejar = __commonJS({
    "node_modules/cookiejar/cookiejar.js"(exports2) {
      (function() {
        "use strict";
        function CookieAccessInfo(domain, path2, secure, script) {
          if (this instanceof CookieAccessInfo) {
            this.domain = domain || void 0;
            this.path = path2 || "/";
            this.secure = !!secure;
            this.script = !!script;
            return this;
          }
          return new CookieAccessInfo(domain, path2, secure, script);
        }
        CookieAccessInfo.All = Object.freeze(/* @__PURE__ */ Object.create(null));
        exports2.CookieAccessInfo = CookieAccessInfo;
        function Cookie(cookiestr, request_domain, request_path) {
          if (cookiestr instanceof Cookie) {
            return cookiestr;
          }
          if (this instanceof Cookie) {
            this.name = null;
            this.value = null;
            this.expiration_date = Infinity;
            this.path = String(request_path || "/");
            this.explicit_path = false;
            this.domain = request_domain || null;
            this.explicit_domain = false;
            this.secure = false;
            this.noscript = false;
            if (cookiestr) {
              this.parse(cookiestr, request_domain, request_path);
            }
            return this;
          }
          return new Cookie(cookiestr, request_domain, request_path);
        }
        exports2.Cookie = Cookie;
        Cookie.prototype.toString = function toString() {
          var str = [this.name + "=" + this.value];
          if (this.expiration_date !== Infinity) {
            str.push("expires=" + new Date(this.expiration_date).toGMTString());
          }
          if (this.domain) {
            str.push("domain=" + this.domain);
          }
          if (this.path) {
            str.push("path=" + this.path);
          }
          if (this.secure) {
            str.push("secure");
          }
          if (this.noscript) {
            str.push("httponly");
          }
          return str.join("; ");
        };
        Cookie.prototype.toValueString = function toValueString() {
          return this.name + "=" + this.value;
        };
        var cookie_str_splitter = /[:](?=\s*[a-zA-Z0-9_\-]+\s*[=])/g;
        Cookie.prototype.parse = function parse(str, request_domain, request_path) {
          if (this instanceof Cookie) {
            var parts = str.split(";").filter(function(value2) {
              return !!value2;
            });
            var i;
            var pair = parts[0].match(/([^=]+)=([\s\S]*)/);
            if (!pair) {
              console.warn("Invalid cookie header encountered. Header: '" + str + "'");
              return;
            }
            var key = pair[1];
            var value = pair[2];
            if (typeof key !== "string" || key.length === 0 || typeof value !== "string") {
              console.warn("Unable to extract values from cookie header. Cookie: '" + str + "'");
              return;
            }
            this.name = key;
            this.value = value;
            for (i = 1; i < parts.length; i += 1) {
              pair = parts[i].match(/([^=]+)(?:=([\s\S]*))?/);
              key = pair[1].trim().toLowerCase();
              value = pair[2];
              switch (key) {
                case "httponly":
                  this.noscript = true;
                  break;
                case "expires":
                  this.expiration_date = value ? Number(Date.parse(value)) : Infinity;
                  break;
                case "path":
                  this.path = value ? value.trim() : "";
                  this.explicit_path = true;
                  break;
                case "domain":
                  this.domain = value ? value.trim() : "";
                  this.explicit_domain = !!this.domain;
                  break;
                case "secure":
                  this.secure = true;
                  break;
              }
            }
            if (!this.explicit_path) {
              this.path = request_path || "/";
            }
            if (!this.explicit_domain) {
              this.domain = request_domain;
            }
            return this;
          }
          return new Cookie().parse(str, request_domain, request_path);
        };
        Cookie.prototype.matches = function matches(access_info) {
          if (access_info === CookieAccessInfo.All) {
            return true;
          }
          if (this.noscript && access_info.script || this.secure && !access_info.secure || !this.collidesWith(access_info)) {
            return false;
          }
          return true;
        };
        Cookie.prototype.collidesWith = function collidesWith(access_info) {
          if (this.path && !access_info.path || this.domain && !access_info.domain) {
            return false;
          }
          if (this.path && access_info.path.indexOf(this.path) !== 0) {
            return false;
          }
          if (this.explicit_path && access_info.path.indexOf(this.path) !== 0) {
            return false;
          }
          var access_domain = access_info.domain && access_info.domain.replace(/^[\.]/, "");
          var cookie_domain = this.domain && this.domain.replace(/^[\.]/, "");
          if (cookie_domain === access_domain) {
            return true;
          }
          if (cookie_domain) {
            if (!this.explicit_domain) {
              return false;
            }
            var wildcard = access_domain.indexOf(cookie_domain);
            if (wildcard === -1 || wildcard !== access_domain.length - cookie_domain.length) {
              return false;
            }
            return true;
          }
          return true;
        };
        function CookieJar() {
          var cookies, cookies_list, collidable_cookie;
          if (this instanceof CookieJar) {
            cookies = /* @__PURE__ */ Object.create(null);
            this.setCookie = function setCookie(cookie, request_domain, request_path) {
              var remove, i;
              cookie = new Cookie(cookie, request_domain, request_path);
              remove = cookie.expiration_date <= Date.now();
              if (cookies[cookie.name] !== void 0) {
                cookies_list = cookies[cookie.name];
                for (i = 0; i < cookies_list.length; i += 1) {
                  collidable_cookie = cookies_list[i];
                  if (collidable_cookie.collidesWith(cookie)) {
                    if (remove) {
                      cookies_list.splice(i, 1);
                      if (cookies_list.length === 0) {
                        delete cookies[cookie.name];
                      }
                      return false;
                    }
                    cookies_list[i] = cookie;
                    return cookie;
                  }
                }
                if (remove) {
                  return false;
                }
                cookies_list.push(cookie);
                return cookie;
              }
              if (remove) {
                return false;
              }
              cookies[cookie.name] = [cookie];
              return cookies[cookie.name];
            };
            this.getCookie = function getCookie(cookie_name, access_info) {
              var cookie, i;
              cookies_list = cookies[cookie_name];
              if (!cookies_list) {
                return;
              }
              for (i = 0; i < cookies_list.length; i += 1) {
                cookie = cookies_list[i];
                if (cookie.expiration_date <= Date.now()) {
                  if (cookies_list.length === 0) {
                    delete cookies[cookie.name];
                  }
                  continue;
                }
                if (cookie.matches(access_info)) {
                  return cookie;
                }
              }
            };
            this.getCookies = function getCookies(access_info) {
              var matches = [], cookie_name, cookie;
              for (cookie_name in cookies) {
                cookie = this.getCookie(cookie_name, access_info);
                if (cookie) {
                  matches.push(cookie);
                }
              }
              matches.toString = function toString() {
                return matches.join(":");
              };
              matches.toValueString = function toValueString() {
                return matches.map(function(c) {
                  return c.toValueString();
                }).join("; ");
              };
              return matches;
            };
            return this;
          }
          return new CookieJar();
        }
        exports2.CookieJar = CookieJar;
        CookieJar.prototype.setCookies = function setCookies(cookies, request_domain, request_path) {
          cookies = Array.isArray(cookies) ? cookies : cookies.split(cookie_str_splitter);
          var successful = [], i, cookie;
          cookies = cookies.map(function(item) {
            return new Cookie(item, request_domain, request_path);
          });
          for (i = 0; i < cookies.length; i += 1) {
            cookie = cookies[i];
            if (this.setCookie(cookie, request_domain, request_path)) {
              successful.push(cookie);
            }
          }
          return successful;
        };
      })();
    }
  });

  // node_modules/superagent/node_modules/semver/internal/constants.js
  var require_constants = __commonJS({
    "node_modules/superagent/node_modules/semver/internal/constants.js"(exports2, module2) {
      var SEMVER_SPEC_VERSION = "2.0.0";
      var MAX_LENGTH = 256;
      var MAX_SAFE_INTEGER2 = Number.MAX_SAFE_INTEGER || 9007199254740991;
      var MAX_SAFE_COMPONENT_LENGTH = 16;
      module2.exports = {
        SEMVER_SPEC_VERSION,
        MAX_LENGTH,
        MAX_SAFE_INTEGER: MAX_SAFE_INTEGER2,
        MAX_SAFE_COMPONENT_LENGTH
      };
    }
  });

  // node_modules/superagent/node_modules/semver/internal/debug.js
  var require_debug = __commonJS({
    "node_modules/superagent/node_modules/semver/internal/debug.js"(exports2, module2) {
      var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
      };
      module2.exports = debug;
    }
  });

  // node_modules/superagent/node_modules/semver/internal/re.js
  var require_re = __commonJS({
    "node_modules/superagent/node_modules/semver/internal/re.js"(exports2, module2) {
      var { MAX_SAFE_COMPONENT_LENGTH } = require_constants();
      var debug = require_debug();
      exports2 = module2.exports = {};
      var re = exports2.re = [];
      var src = exports2.src = [];
      var t = exports2.t = {};
      var R = 0;
      var createToken = (name, value, isGlobal) => {
        const index = R++;
        debug(index, value);
        t[name] = index;
        src[index] = value;
        re[index] = new RegExp(value, isGlobal ? "g" : void 0);
      };
      createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
      createToken("NUMERICIDENTIFIERLOOSE", "[0-9]+");
      createToken("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*");
      createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
      createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
      createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
      createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
      createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
      createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
      createToken("BUILDIDENTIFIER", "[0-9A-Za-z-]+");
      createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
      createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
      createToken("FULL", `^${src[t.FULLPLAIN]}$`);
      createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
      createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
      createToken("GTLT", "((?:<|>)?=?)");
      createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
      createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
      createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
      createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
      createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
      createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
      createToken("COERCE", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:$|[^\\d])`);
      createToken("COERCERTL", src[t.COERCE], true);
      createToken("LONETILDE", "(?:~>?)");
      createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
      exports2.tildeTrimReplace = "$1~";
      createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
      createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
      createToken("LONECARET", "(?:\\^)");
      createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
      exports2.caretTrimReplace = "$1^";
      createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
      createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
      createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
      createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
      createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
      exports2.comparatorTrimReplace = "$1$2$3";
      createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
      createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
      createToken("STAR", "(<|>)?=?\\s*\\*");
      createToken("GTE0", "^\\s*>=\\s*0.0.0\\s*$");
      createToken("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
    }
  });

  // node_modules/superagent/node_modules/semver/internal/parse-options.js
  var require_parse_options = __commonJS({
    "node_modules/superagent/node_modules/semver/internal/parse-options.js"(exports2, module2) {
      var opts = ["includePrerelease", "loose", "rtl"];
      var parseOptions = (options) => !options ? {} : typeof options !== "object" ? { loose: true } : opts.filter((k) => options[k]).reduce((options2, k) => {
        options2[k] = true;
        return options2;
      }, {});
      module2.exports = parseOptions;
    }
  });

  // node_modules/superagent/node_modules/semver/internal/identifiers.js
  var require_identifiers = __commonJS({
    "node_modules/superagent/node_modules/semver/internal/identifiers.js"(exports2, module2) {
      var numeric = /^[0-9]+$/;
      var compareIdentifiers = (a, b) => {
        const anum = numeric.test(a);
        const bnum = numeric.test(b);
        if (anum && bnum) {
          a = +a;
          b = +b;
        }
        return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
      };
      var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
      module2.exports = {
        compareIdentifiers,
        rcompareIdentifiers
      };
    }
  });

  // node_modules/superagent/node_modules/semver/classes/semver.js
  var require_semver = __commonJS({
    "node_modules/superagent/node_modules/semver/classes/semver.js"(exports2, module2) {
      var debug = require_debug();
      var { MAX_LENGTH, MAX_SAFE_INTEGER: MAX_SAFE_INTEGER2 } = require_constants();
      var { re, t } = require_re();
      var parseOptions = require_parse_options();
      var { compareIdentifiers } = require_identifiers();
      var SemVer = class {
        constructor(version, options) {
          options = parseOptions(options);
          if (version instanceof SemVer) {
            if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
              return version;
            } else {
              version = version.version;
            }
          } else if (typeof version !== "string") {
            throw new TypeError(`Invalid Version: ${version}`);
          }
          if (version.length > MAX_LENGTH) {
            throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
          }
          debug("SemVer", version, options);
          this.options = options;
          this.loose = !!options.loose;
          this.includePrerelease = !!options.includePrerelease;
          const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
          if (!m) {
            throw new TypeError(`Invalid Version: ${version}`);
          }
          this.raw = version;
          this.major = +m[1];
          this.minor = +m[2];
          this.patch = +m[3];
          if (this.major > MAX_SAFE_INTEGER2 || this.major < 0) {
            throw new TypeError("Invalid major version");
          }
          if (this.minor > MAX_SAFE_INTEGER2 || this.minor < 0) {
            throw new TypeError("Invalid minor version");
          }
          if (this.patch > MAX_SAFE_INTEGER2 || this.patch < 0) {
            throw new TypeError("Invalid patch version");
          }
          if (!m[4]) {
            this.prerelease = [];
          } else {
            this.prerelease = m[4].split(".").map((id) => {
              if (/^[0-9]+$/.test(id)) {
                const num = +id;
                if (num >= 0 && num < MAX_SAFE_INTEGER2) {
                  return num;
                }
              }
              return id;
            });
          }
          this.build = m[5] ? m[5].split(".") : [];
          this.format();
        }
        format() {
          this.version = `${this.major}.${this.minor}.${this.patch}`;
          if (this.prerelease.length) {
            this.version += `-${this.prerelease.join(".")}`;
          }
          return this.version;
        }
        toString() {
          return this.version;
        }
        compare(other) {
          debug("SemVer.compare", this.version, this.options, other);
          if (!(other instanceof SemVer)) {
            if (typeof other === "string" && other === this.version) {
              return 0;
            }
            other = new SemVer(other, this.options);
          }
          if (other.version === this.version) {
            return 0;
          }
          return this.compareMain(other) || this.comparePre(other);
        }
        compareMain(other) {
          if (!(other instanceof SemVer)) {
            other = new SemVer(other, this.options);
          }
          return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
        }
        comparePre(other) {
          if (!(other instanceof SemVer)) {
            other = new SemVer(other, this.options);
          }
          if (this.prerelease.length && !other.prerelease.length) {
            return -1;
          } else if (!this.prerelease.length && other.prerelease.length) {
            return 1;
          } else if (!this.prerelease.length && !other.prerelease.length) {
            return 0;
          }
          let i = 0;
          do {
            const a = this.prerelease[i];
            const b = other.prerelease[i];
            debug("prerelease compare", i, a, b);
            if (a === void 0 && b === void 0) {
              return 0;
            } else if (b === void 0) {
              return 1;
            } else if (a === void 0) {
              return -1;
            } else if (a === b) {
              continue;
            } else {
              return compareIdentifiers(a, b);
            }
          } while (++i);
        }
        compareBuild(other) {
          if (!(other instanceof SemVer)) {
            other = new SemVer(other, this.options);
          }
          let i = 0;
          do {
            const a = this.build[i];
            const b = other.build[i];
            debug("prerelease compare", i, a, b);
            if (a === void 0 && b === void 0) {
              return 0;
            } else if (b === void 0) {
              return 1;
            } else if (a === void 0) {
              return -1;
            } else if (a === b) {
              continue;
            } else {
              return compareIdentifiers(a, b);
            }
          } while (++i);
        }
        inc(release, identifier) {
          switch (release) {
            case "premajor":
              this.prerelease.length = 0;
              this.patch = 0;
              this.minor = 0;
              this.major++;
              this.inc("pre", identifier);
              break;
            case "preminor":
              this.prerelease.length = 0;
              this.patch = 0;
              this.minor++;
              this.inc("pre", identifier);
              break;
            case "prepatch":
              this.prerelease.length = 0;
              this.inc("patch", identifier);
              this.inc("pre", identifier);
              break;
            case "prerelease":
              if (this.prerelease.length === 0) {
                this.inc("patch", identifier);
              }
              this.inc("pre", identifier);
              break;
            case "major":
              if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
                this.major++;
              }
              this.minor = 0;
              this.patch = 0;
              this.prerelease = [];
              break;
            case "minor":
              if (this.patch !== 0 || this.prerelease.length === 0) {
                this.minor++;
              }
              this.patch = 0;
              this.prerelease = [];
              break;
            case "patch":
              if (this.prerelease.length === 0) {
                this.patch++;
              }
              this.prerelease = [];
              break;
            case "pre":
              if (this.prerelease.length === 0) {
                this.prerelease = [0];
              } else {
                let i = this.prerelease.length;
                while (--i >= 0) {
                  if (typeof this.prerelease[i] === "number") {
                    this.prerelease[i]++;
                    i = -2;
                  }
                }
                if (i === -1) {
                  this.prerelease.push(0);
                }
              }
              if (identifier) {
                if (this.prerelease[0] === identifier) {
                  if (isNaN(this.prerelease[1])) {
                    this.prerelease = [identifier, 0];
                  }
                } else {
                  this.prerelease = [identifier, 0];
                }
              }
              break;
            default:
              throw new Error(`invalid increment argument: ${release}`);
          }
          this.format();
          this.raw = this.version;
          return this;
        }
      };
      module2.exports = SemVer;
    }
  });

  // node_modules/superagent/node_modules/semver/functions/parse.js
  var require_parse3 = __commonJS({
    "node_modules/superagent/node_modules/semver/functions/parse.js"(exports2, module2) {
      var { MAX_LENGTH } = require_constants();
      var { re, t } = require_re();
      var SemVer = require_semver();
      var parseOptions = require_parse_options();
      var parse = (version, options) => {
        options = parseOptions(options);
        if (version instanceof SemVer) {
          return version;
        }
        if (typeof version !== "string") {
          return null;
        }
        if (version.length > MAX_LENGTH) {
          return null;
        }
        const r = options.loose ? re[t.LOOSE] : re[t.FULL];
        if (!r.test(version)) {
          return null;
        }
        try {
          return new SemVer(version, options);
        } catch (er) {
          return null;
        }
      };
      module2.exports = parse;
    }
  });

  // node_modules/superagent/node_modules/semver/functions/valid.js
  var require_valid = __commonJS({
    "node_modules/superagent/node_modules/semver/functions/valid.js"(exports2, module2) {
      var parse = require_parse3();
      var valid = (version, options) => {
        const v = parse(version, options);
        return v ? v.version : null;
      };
      module2.exports = valid;
    }
  });

  // node_modules/superagent/node_modules/semver/functions/clean.js
  var require_clean = __commonJS({
    "node_modules/superagent/node_modules/semver/functions/clean.js"(exports2, module2) {
      var parse = require_parse3();
      var clean = (version, options) => {
        const s = parse(version.trim().replace(/^[=v]+/, ""), options);
        return s ? s.version : null;
      };
      module2.exports = clean;
    }
  });

  // node_modules/superagent/node_modules/semver/functions/inc.js
  var require_inc = __commonJS({
    "node_modules/superagent/node_modules/semver/functions/inc.js"(exports2, module2) {
      var SemVer = require_semver();
      var inc = (version, release, options, identifier) => {
        if (typeof options === "string") {
          identifier = options;
          options = void 0;
        }
        try {
          return new SemVer(version, options).inc(release, identifier).version;
        } catch (er) {
          return null;
        }
      };
      module2.exports = inc;
    }
  });

  // node_modules/superagent/node_modules/semver/functions/compare.js
  var require_compare = __commonJS({
    "node_modules/superagent/node_modules/semver/functions/compare.js"(exports2, module2) {
      var SemVer = require_semver();
      var compare2 = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
      module2.exports = compare2;
    }
  });

  // node_modules/superagent/node_modules/semver/functions/eq.js
  var require_eq = __commonJS({
    "node_modules/superagent/node_modules/semver/functions/eq.js"(exports2, module2) {
      var compare2 = require_compare();
      var eq = (a, b, loose) => compare2(a, b, loose) === 0;
      module2.exports = eq;
    }
  });

  // node_modules/superagent/node_modules/semver/functions/diff.js
  var require_diff = __commonJS({
    "node_modules/superagent/node_modules/semver/functions/diff.js"(exports2, module2) {
      var parse = require_parse3();
      var eq = require_eq();
      var diff = (version1, version2) => {
        if (eq(version1, version2)) {
          return null;
        } else {
          const v1 = parse(version1);
          const v2 = parse(version2);
          const hasPre = v1.prerelease.length || v2.prerelease.length;
          const prefix = hasPre ? "pre" : "";
          const defaultResult = hasPre ? "prerelease" : "";
          for (const key in v1) {
            if (key === "major" || key === "minor" || key === "patch") {
              if (v1[key] !== v2[key]) {
                return prefix + key;
              }
            }
          }
          return defaultResult;
        }
      };
      module2.exports = diff;
    }
  });

  // node_modules/superagent/node_modules/semver/functions/major.js
  var require_major = __commonJS({
    "node_modules/superagent/node_modules/semver/functions/major.js"(exports2, module2) {
      var SemVer = require_semver();
      var major = (a, loose) => new SemVer(a, loose).major;
      module2.exports = major;
    }
  });

  // node_modules/superagent/node_modules/semver/functions/minor.js
  var require_minor = __commonJS({
    "node_modules/superagent/node_modules/semver/functions/minor.js"(exports2, module2) {
      var SemVer = require_semver();
      var minor = (a, loose) => new SemVer(a, loose).minor;
      module2.exports = minor;
    }
  });

  // node_modules/superagent/node_modules/semver/functions/patch.js
  var require_patch = __commonJS({
    "node_modules/superagent/node_modules/semver/functions/patch.js"(exports2, module2) {
      var SemVer = require_semver();
      var patch = (a, loose) => new SemVer(a, loose).patch;
      module2.exports = patch;
    }
  });

  // node_modules/superagent/node_modules/semver/functions/prerelease.js
  var require_prerelease = __commonJS({
    "node_modules/superagent/node_modules/semver/functions/prerelease.js"(exports2, module2) {
      var parse = require_parse3();
      var prerelease = (version, options) => {
        const parsed = parse(version, options);
        return parsed && parsed.prerelease.length ? parsed.prerelease : null;
      };
      module2.exports = prerelease;
    }
  });

  // node_modules/superagent/node_modules/semver/functions/rcompare.js
  var require_rcompare = __commonJS({
    "node_modules/superagent/node_modules/semver/functions/rcompare.js"(exports2, module2) {
      var compare2 = require_compare();
      var rcompare = (a, b, loose) => compare2(b, a, loose);
      module2.exports = rcompare;
    }
  });

  // node_modules/superagent/node_modules/semver/functions/compare-loose.js
  var require_compare_loose = __commonJS({
    "node_modules/superagent/node_modules/semver/functions/compare-loose.js"(exports2, module2) {
      var compare2 = require_compare();
      var compareLoose = (a, b) => compare2(a, b, true);
      module2.exports = compareLoose;
    }
  });

  // node_modules/superagent/node_modules/semver/functions/compare-build.js
  var require_compare_build = __commonJS({
    "node_modules/superagent/node_modules/semver/functions/compare-build.js"(exports2, module2) {
      var SemVer = require_semver();
      var compareBuild = (a, b, loose) => {
        const versionA = new SemVer(a, loose);
        const versionB = new SemVer(b, loose);
        return versionA.compare(versionB) || versionA.compareBuild(versionB);
      };
      module2.exports = compareBuild;
    }
  });

  // node_modules/superagent/node_modules/semver/functions/sort.js
  var require_sort = __commonJS({
    "node_modules/superagent/node_modules/semver/functions/sort.js"(exports2, module2) {
      var compareBuild = require_compare_build();
      var sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
      module2.exports = sort;
    }
  });

  // node_modules/superagent/node_modules/semver/functions/rsort.js
  var require_rsort = __commonJS({
    "node_modules/superagent/node_modules/semver/functions/rsort.js"(exports2, module2) {
      var compareBuild = require_compare_build();
      var rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
      module2.exports = rsort;
    }
  });

  // node_modules/superagent/node_modules/semver/functions/gt.js
  var require_gt = __commonJS({
    "node_modules/superagent/node_modules/semver/functions/gt.js"(exports2, module2) {
      var compare2 = require_compare();
      var gt = (a, b, loose) => compare2(a, b, loose) > 0;
      module2.exports = gt;
    }
  });

  // node_modules/superagent/node_modules/semver/functions/lt.js
  var require_lt = __commonJS({
    "node_modules/superagent/node_modules/semver/functions/lt.js"(exports2, module2) {
      var compare2 = require_compare();
      var lt = (a, b, loose) => compare2(a, b, loose) < 0;
      module2.exports = lt;
    }
  });

  // node_modules/superagent/node_modules/semver/functions/neq.js
  var require_neq = __commonJS({
    "node_modules/superagent/node_modules/semver/functions/neq.js"(exports2, module2) {
      var compare2 = require_compare();
      var neq = (a, b, loose) => compare2(a, b, loose) !== 0;
      module2.exports = neq;
    }
  });

  // node_modules/superagent/node_modules/semver/functions/gte.js
  var require_gte = __commonJS({
    "node_modules/superagent/node_modules/semver/functions/gte.js"(exports2, module2) {
      var compare2 = require_compare();
      var gte = (a, b, loose) => compare2(a, b, loose) >= 0;
      module2.exports = gte;
    }
  });

  // node_modules/superagent/node_modules/semver/functions/lte.js
  var require_lte = __commonJS({
    "node_modules/superagent/node_modules/semver/functions/lte.js"(exports2, module2) {
      var compare2 = require_compare();
      var lte = (a, b, loose) => compare2(a, b, loose) <= 0;
      module2.exports = lte;
    }
  });

  // node_modules/superagent/node_modules/semver/functions/cmp.js
  var require_cmp = __commonJS({
    "node_modules/superagent/node_modules/semver/functions/cmp.js"(exports2, module2) {
      var eq = require_eq();
      var neq = require_neq();
      var gt = require_gt();
      var gte = require_gte();
      var lt = require_lt();
      var lte = require_lte();
      var cmp = (a, op, b, loose) => {
        switch (op) {
          case "===":
            if (typeof a === "object")
              a = a.version;
            if (typeof b === "object")
              b = b.version;
            return a === b;
          case "!==":
            if (typeof a === "object")
              a = a.version;
            if (typeof b === "object")
              b = b.version;
            return a !== b;
          case "":
          case "=":
          case "==":
            return eq(a, b, loose);
          case "!=":
            return neq(a, b, loose);
          case ">":
            return gt(a, b, loose);
          case ">=":
            return gte(a, b, loose);
          case "<":
            return lt(a, b, loose);
          case "<=":
            return lte(a, b, loose);
          default:
            throw new TypeError(`Invalid operator: ${op}`);
        }
      };
      module2.exports = cmp;
    }
  });

  // node_modules/superagent/node_modules/semver/functions/coerce.js
  var require_coerce = __commonJS({
    "node_modules/superagent/node_modules/semver/functions/coerce.js"(exports2, module2) {
      var SemVer = require_semver();
      var parse = require_parse3();
      var { re, t } = require_re();
      var coerce = (version, options) => {
        if (version instanceof SemVer) {
          return version;
        }
        if (typeof version === "number") {
          version = String(version);
        }
        if (typeof version !== "string") {
          return null;
        }
        options = options || {};
        let match = null;
        if (!options.rtl) {
          match = version.match(re[t.COERCE]);
        } else {
          let next;
          while ((next = re[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
            if (!match || next.index + next[0].length !== match.index + match[0].length) {
              match = next;
            }
            re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
          }
          re[t.COERCERTL].lastIndex = -1;
        }
        if (match === null)
          return null;
        return parse(`${match[2]}.${match[3] || "0"}.${match[4] || "0"}`, options);
      };
      module2.exports = coerce;
    }
  });

  // node_modules/yallist/iterator.js
  var require_iterator = __commonJS({
    "node_modules/yallist/iterator.js"(exports2, module2) {
      "use strict";
      module2.exports = function(Yallist) {
        Yallist.prototype[Symbol.iterator] = function* () {
          for (let walker = this.head; walker; walker = walker.next) {
            yield walker.value;
          }
        };
      };
    }
  });

  // node_modules/yallist/yallist.js
  var require_yallist = __commonJS({
    "node_modules/yallist/yallist.js"(exports2, module2) {
      "use strict";
      module2.exports = Yallist;
      Yallist.Node = Node;
      Yallist.create = Yallist;
      function Yallist(list) {
        var self2 = this;
        if (!(self2 instanceof Yallist)) {
          self2 = new Yallist();
        }
        self2.tail = null;
        self2.head = null;
        self2.length = 0;
        if (list && typeof list.forEach === "function") {
          list.forEach(function(item) {
            self2.push(item);
          });
        } else if (arguments.length > 0) {
          for (var i = 0, l = arguments.length; i < l; i++) {
            self2.push(arguments[i]);
          }
        }
        return self2;
      }
      Yallist.prototype.removeNode = function(node) {
        if (node.list !== this) {
          throw new Error("removing node which does not belong to this list");
        }
        var next = node.next;
        var prev = node.prev;
        if (next) {
          next.prev = prev;
        }
        if (prev) {
          prev.next = next;
        }
        if (node === this.head) {
          this.head = next;
        }
        if (node === this.tail) {
          this.tail = prev;
        }
        node.list.length--;
        node.next = null;
        node.prev = null;
        node.list = null;
        return next;
      };
      Yallist.prototype.unshiftNode = function(node) {
        if (node === this.head) {
          return;
        }
        if (node.list) {
          node.list.removeNode(node);
        }
        var head = this.head;
        node.list = this;
        node.next = head;
        if (head) {
          head.prev = node;
        }
        this.head = node;
        if (!this.tail) {
          this.tail = node;
        }
        this.length++;
      };
      Yallist.prototype.pushNode = function(node) {
        if (node === this.tail) {
          return;
        }
        if (node.list) {
          node.list.removeNode(node);
        }
        var tail = this.tail;
        node.list = this;
        node.prev = tail;
        if (tail) {
          tail.next = node;
        }
        this.tail = node;
        if (!this.head) {
          this.head = node;
        }
        this.length++;
      };
      Yallist.prototype.push = function() {
        for (var i = 0, l = arguments.length; i < l; i++) {
          push(this, arguments[i]);
        }
        return this.length;
      };
      Yallist.prototype.unshift = function() {
        for (var i = 0, l = arguments.length; i < l; i++) {
          unshift(this, arguments[i]);
        }
        return this.length;
      };
      Yallist.prototype.pop = function() {
        if (!this.tail) {
          return void 0;
        }
        var res = this.tail.value;
        this.tail = this.tail.prev;
        if (this.tail) {
          this.tail.next = null;
        } else {
          this.head = null;
        }
        this.length--;
        return res;
      };
      Yallist.prototype.shift = function() {
        if (!this.head) {
          return void 0;
        }
        var res = this.head.value;
        this.head = this.head.next;
        if (this.head) {
          this.head.prev = null;
        } else {
          this.tail = null;
        }
        this.length--;
        return res;
      };
      Yallist.prototype.forEach = function(fn, thisp) {
        thisp = thisp || this;
        for (var walker = this.head, i = 0; walker !== null; i++) {
          fn.call(thisp, walker.value, i, this);
          walker = walker.next;
        }
      };
      Yallist.prototype.forEachReverse = function(fn, thisp) {
        thisp = thisp || this;
        for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
          fn.call(thisp, walker.value, i, this);
          walker = walker.prev;
        }
      };
      Yallist.prototype.get = function(n) {
        for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
          walker = walker.next;
        }
        if (i === n && walker !== null) {
          return walker.value;
        }
      };
      Yallist.prototype.getReverse = function(n) {
        for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
          walker = walker.prev;
        }
        if (i === n && walker !== null) {
          return walker.value;
        }
      };
      Yallist.prototype.map = function(fn, thisp) {
        thisp = thisp || this;
        var res = new Yallist();
        for (var walker = this.head; walker !== null; ) {
          res.push(fn.call(thisp, walker.value, this));
          walker = walker.next;
        }
        return res;
      };
      Yallist.prototype.mapReverse = function(fn, thisp) {
        thisp = thisp || this;
        var res = new Yallist();
        for (var walker = this.tail; walker !== null; ) {
          res.push(fn.call(thisp, walker.value, this));
          walker = walker.prev;
        }
        return res;
      };
      Yallist.prototype.reduce = function(fn, initial) {
        var acc;
        var walker = this.head;
        if (arguments.length > 1) {
          acc = initial;
        } else if (this.head) {
          walker = this.head.next;
          acc = this.head.value;
        } else {
          throw new TypeError("Reduce of empty list with no initial value");
        }
        for (var i = 0; walker !== null; i++) {
          acc = fn(acc, walker.value, i);
          walker = walker.next;
        }
        return acc;
      };
      Yallist.prototype.reduceReverse = function(fn, initial) {
        var acc;
        var walker = this.tail;
        if (arguments.length > 1) {
          acc = initial;
        } else if (this.tail) {
          walker = this.tail.prev;
          acc = this.tail.value;
        } else {
          throw new TypeError("Reduce of empty list with no initial value");
        }
        for (var i = this.length - 1; walker !== null; i--) {
          acc = fn(acc, walker.value, i);
          walker = walker.prev;
        }
        return acc;
      };
      Yallist.prototype.toArray = function() {
        var arr = new Array(this.length);
        for (var i = 0, walker = this.head; walker !== null; i++) {
          arr[i] = walker.value;
          walker = walker.next;
        }
        return arr;
      };
      Yallist.prototype.toArrayReverse = function() {
        var arr = new Array(this.length);
        for (var i = 0, walker = this.tail; walker !== null; i++) {
          arr[i] = walker.value;
          walker = walker.prev;
        }
        return arr;
      };
      Yallist.prototype.slice = function(from, to) {
        to = to || this.length;
        if (to < 0) {
          to += this.length;
        }
        from = from || 0;
        if (from < 0) {
          from += this.length;
        }
        var ret = new Yallist();
        if (to < from || to < 0) {
          return ret;
        }
        if (from < 0) {
          from = 0;
        }
        if (to > this.length) {
          to = this.length;
        }
        for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
          walker = walker.next;
        }
        for (; walker !== null && i < to; i++, walker = walker.next) {
          ret.push(walker.value);
        }
        return ret;
      };
      Yallist.prototype.sliceReverse = function(from, to) {
        to = to || this.length;
        if (to < 0) {
          to += this.length;
        }
        from = from || 0;
        if (from < 0) {
          from += this.length;
        }
        var ret = new Yallist();
        if (to < from || to < 0) {
          return ret;
        }
        if (from < 0) {
          from = 0;
        }
        if (to > this.length) {
          to = this.length;
        }
        for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
          walker = walker.prev;
        }
        for (; walker !== null && i > from; i--, walker = walker.prev) {
          ret.push(walker.value);
        }
        return ret;
      };
      Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
        if (start > this.length) {
          start = this.length - 1;
        }
        if (start < 0) {
          start = this.length + start;
        }
        for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
          walker = walker.next;
        }
        var ret = [];
        for (var i = 0; walker && i < deleteCount; i++) {
          ret.push(walker.value);
          walker = this.removeNode(walker);
        }
        if (walker === null) {
          walker = this.tail;
        }
        if (walker !== this.head && walker !== this.tail) {
          walker = walker.prev;
        }
        for (var i = 0; i < nodes.length; i++) {
          walker = insert(this, walker, nodes[i]);
        }
        return ret;
      };
      Yallist.prototype.reverse = function() {
        var head = this.head;
        var tail = this.tail;
        for (var walker = head; walker !== null; walker = walker.prev) {
          var p = walker.prev;
          walker.prev = walker.next;
          walker.next = p;
        }
        this.head = tail;
        this.tail = head;
        return this;
      };
      function insert(self2, node, value) {
        var inserted = node === self2.head ? new Node(value, null, node, self2) : new Node(value, node, node.next, self2);
        if (inserted.next === null) {
          self2.tail = inserted;
        }
        if (inserted.prev === null) {
          self2.head = inserted;
        }
        self2.length++;
        return inserted;
      }
      function push(self2, item) {
        self2.tail = new Node(item, self2.tail, null, self2);
        if (!self2.head) {
          self2.head = self2.tail;
        }
        self2.length++;
      }
      function unshift(self2, item) {
        self2.head = new Node(item, null, self2.head, self2);
        if (!self2.tail) {
          self2.tail = self2.head;
        }
        self2.length++;
      }
      function Node(value, prev, next, list) {
        if (!(this instanceof Node)) {
          return new Node(value, prev, next, list);
        }
        this.list = list;
        this.value = value;
        if (prev) {
          prev.next = this;
          this.prev = prev;
        } else {
          this.prev = null;
        }
        if (next) {
          next.prev = this;
          this.next = next;
        } else {
          this.next = null;
        }
      }
      try {
        require_iterator()(Yallist);
      } catch (er) {
      }
    }
  });

  // node_modules/lru-cache/index.js
  var require_lru_cache = __commonJS({
    "node_modules/lru-cache/index.js"(exports2, module2) {
      "use strict";
      var Yallist = require_yallist();
      var MAX2 = Symbol("max");
      var LENGTH = Symbol("length");
      var LENGTH_CALCULATOR = Symbol("lengthCalculator");
      var ALLOW_STALE = Symbol("allowStale");
      var MAX_AGE = Symbol("maxAge");
      var DISPOSE = Symbol("dispose");
      var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
      var LRU_LIST = Symbol("lruList");
      var CACHE = Symbol("cache");
      var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
      var naiveLength = () => 1;
      var LRUCache = class {
        constructor(options) {
          if (typeof options === "number")
            options = { max: options };
          if (!options)
            options = {};
          if (options.max && (typeof options.max !== "number" || options.max < 0))
            throw new TypeError("max must be a non-negative number");
          const max = this[MAX2] = options.max || Infinity;
          const lc = options.length || naiveLength;
          this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
          this[ALLOW_STALE] = options.stale || false;
          if (options.maxAge && typeof options.maxAge !== "number")
            throw new TypeError("maxAge must be a number");
          this[MAX_AGE] = options.maxAge || 0;
          this[DISPOSE] = options.dispose;
          this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
          this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
          this.reset();
        }
        set max(mL) {
          if (typeof mL !== "number" || mL < 0)
            throw new TypeError("max must be a non-negative number");
          this[MAX2] = mL || Infinity;
          trim(this);
        }
        get max() {
          return this[MAX2];
        }
        set allowStale(allowStale) {
          this[ALLOW_STALE] = !!allowStale;
        }
        get allowStale() {
          return this[ALLOW_STALE];
        }
        set maxAge(mA) {
          if (typeof mA !== "number")
            throw new TypeError("maxAge must be a non-negative number");
          this[MAX_AGE] = mA;
          trim(this);
        }
        get maxAge() {
          return this[MAX_AGE];
        }
        set lengthCalculator(lC) {
          if (typeof lC !== "function")
            lC = naiveLength;
          if (lC !== this[LENGTH_CALCULATOR]) {
            this[LENGTH_CALCULATOR] = lC;
            this[LENGTH] = 0;
            this[LRU_LIST].forEach((hit) => {
              hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
              this[LENGTH] += hit.length;
            });
          }
          trim(this);
        }
        get lengthCalculator() {
          return this[LENGTH_CALCULATOR];
        }
        get length() {
          return this[LENGTH];
        }
        get itemCount() {
          return this[LRU_LIST].length;
        }
        rforEach(fn, thisp) {
          thisp = thisp || this;
          for (let walker = this[LRU_LIST].tail; walker !== null; ) {
            const prev = walker.prev;
            forEachStep(this, fn, walker, thisp);
            walker = prev;
          }
        }
        forEach(fn, thisp) {
          thisp = thisp || this;
          for (let walker = this[LRU_LIST].head; walker !== null; ) {
            const next = walker.next;
            forEachStep(this, fn, walker, thisp);
            walker = next;
          }
        }
        keys() {
          return this[LRU_LIST].toArray().map((k) => k.key);
        }
        values() {
          return this[LRU_LIST].toArray().map((k) => k.value);
        }
        reset() {
          if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
            this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
          }
          this[CACHE] = /* @__PURE__ */ new Map();
          this[LRU_LIST] = new Yallist();
          this[LENGTH] = 0;
        }
        dump() {
          return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
            k: hit.key,
            v: hit.value,
            e: hit.now + (hit.maxAge || 0)
          }).toArray().filter((h) => h);
        }
        dumpLru() {
          return this[LRU_LIST];
        }
        set(key, value, maxAge) {
          maxAge = maxAge || this[MAX_AGE];
          if (maxAge && typeof maxAge !== "number")
            throw new TypeError("maxAge must be a number");
          const now = maxAge ? Date.now() : 0;
          const len = this[LENGTH_CALCULATOR](value, key);
          if (this[CACHE].has(key)) {
            if (len > this[MAX2]) {
              del(this, this[CACHE].get(key));
              return false;
            }
            const node = this[CACHE].get(key);
            const item = node.value;
            if (this[DISPOSE]) {
              if (!this[NO_DISPOSE_ON_SET])
                this[DISPOSE](key, item.value);
            }
            item.now = now;
            item.maxAge = maxAge;
            item.value = value;
            this[LENGTH] += len - item.length;
            item.length = len;
            this.get(key);
            trim(this);
            return true;
          }
          const hit = new Entry(key, value, len, now, maxAge);
          if (hit.length > this[MAX2]) {
            if (this[DISPOSE])
              this[DISPOSE](key, value);
            return false;
          }
          this[LENGTH] += hit.length;
          this[LRU_LIST].unshift(hit);
          this[CACHE].set(key, this[LRU_LIST].head);
          trim(this);
          return true;
        }
        has(key) {
          if (!this[CACHE].has(key))
            return false;
          const hit = this[CACHE].get(key).value;
          return !isStale(this, hit);
        }
        get(key) {
          return get2(this, key, true);
        }
        peek(key) {
          return get2(this, key, false);
        }
        pop() {
          const node = this[LRU_LIST].tail;
          if (!node)
            return null;
          del(this, node);
          return node.value;
        }
        del(key) {
          del(this, this[CACHE].get(key));
        }
        load(arr) {
          this.reset();
          const now = Date.now();
          for (let l = arr.length - 1; l >= 0; l--) {
            const hit = arr[l];
            const expiresAt = hit.e || 0;
            if (expiresAt === 0)
              this.set(hit.k, hit.v);
            else {
              const maxAge = expiresAt - now;
              if (maxAge > 0) {
                this.set(hit.k, hit.v, maxAge);
              }
            }
          }
        }
        prune() {
          this[CACHE].forEach((value, key) => get2(this, key, false));
        }
      };
      var get2 = (self2, key, doUse) => {
        const node = self2[CACHE].get(key);
        if (node) {
          const hit = node.value;
          if (isStale(self2, hit)) {
            del(self2, node);
            if (!self2[ALLOW_STALE])
              return void 0;
          } else {
            if (doUse) {
              if (self2[UPDATE_AGE_ON_GET])
                node.value.now = Date.now();
              self2[LRU_LIST].unshiftNode(node);
            }
          }
          return hit.value;
        }
      };
      var isStale = (self2, hit) => {
        if (!hit || !hit.maxAge && !self2[MAX_AGE])
          return false;
        const diff = Date.now() - hit.now;
        return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];
      };
      var trim = (self2) => {
        if (self2[LENGTH] > self2[MAX2]) {
          for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX2] && walker !== null; ) {
            const prev = walker.prev;
            del(self2, walker);
            walker = prev;
          }
        }
      };
      var del = (self2, node) => {
        if (node) {
          const hit = node.value;
          if (self2[DISPOSE])
            self2[DISPOSE](hit.key, hit.value);
          self2[LENGTH] -= hit.length;
          self2[CACHE].delete(hit.key);
          self2[LRU_LIST].removeNode(node);
        }
      };
      var Entry = class {
        constructor(key, value, length, now, maxAge) {
          this.key = key;
          this.value = value;
          this.length = length;
          this.now = now;
          this.maxAge = maxAge || 0;
        }
      };
      var forEachStep = (self2, fn, node, thisp) => {
        let hit = node.value;
        if (isStale(self2, hit)) {
          del(self2, node);
          if (!self2[ALLOW_STALE])
            hit = void 0;
        }
        if (hit)
          fn.call(thisp, hit.value, hit.key, self2);
      };
      module2.exports = LRUCache;
    }
  });

  // node_modules/superagent/node_modules/semver/classes/range.js
  var require_range = __commonJS({
    "node_modules/superagent/node_modules/semver/classes/range.js"(exports2, module2) {
      var Range = class {
        constructor(range, options) {
          options = parseOptions(options);
          if (range instanceof Range) {
            if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
              return range;
            } else {
              return new Range(range.raw, options);
            }
          }
          if (range instanceof Comparator) {
            this.raw = range.value;
            this.set = [[range]];
            this.format();
            return this;
          }
          this.options = options;
          this.loose = !!options.loose;
          this.includePrerelease = !!options.includePrerelease;
          this.raw = range;
          this.set = range.split(/\s*\|\|\s*/).map((range2) => this.parseRange(range2.trim())).filter((c) => c.length);
          if (!this.set.length) {
            throw new TypeError(`Invalid SemVer Range: ${range}`);
          }
          if (this.set.length > 1) {
            const first = this.set[0];
            this.set = this.set.filter((c) => !isNullSet(c[0]));
            if (this.set.length === 0)
              this.set = [first];
            else if (this.set.length > 1) {
              for (const c of this.set) {
                if (c.length === 1 && isAny(c[0])) {
                  this.set = [c];
                  break;
                }
              }
            }
          }
          this.format();
        }
        format() {
          this.range = this.set.map((comps) => {
            return comps.join(" ").trim();
          }).join("||").trim();
          return this.range;
        }
        toString() {
          return this.range;
        }
        parseRange(range) {
          range = range.trim();
          const memoOpts = Object.keys(this.options).join(",");
          const memoKey = `parseRange:${memoOpts}:${range}`;
          const cached = cache.get(memoKey);
          if (cached)
            return cached;
          const loose = this.options.loose;
          const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
          range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
          debug("hyphen replace", range);
          range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
          debug("comparator trim", range, re[t.COMPARATORTRIM]);
          range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
          range = range.replace(re[t.CARETTRIM], caretTrimReplace);
          range = range.split(/\s+/).join(" ");
          const compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
          const rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options)).filter(this.options.loose ? (comp) => !!comp.match(compRe) : () => true).map((comp) => new Comparator(comp, this.options));
          const l = rangeList.length;
          const rangeMap = /* @__PURE__ */ new Map();
          for (const comp of rangeList) {
            if (isNullSet(comp))
              return [comp];
            rangeMap.set(comp.value, comp);
          }
          if (rangeMap.size > 1 && rangeMap.has(""))
            rangeMap.delete("");
          const result = [...rangeMap.values()];
          cache.set(memoKey, result);
          return result;
        }
        intersects(range, options) {
          if (!(range instanceof Range)) {
            throw new TypeError("a Range is required");
          }
          return this.set.some((thisComparators) => {
            return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
              return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
                return rangeComparators.every((rangeComparator) => {
                  return thisComparator.intersects(rangeComparator, options);
                });
              });
            });
          });
        }
        test(version) {
          if (!version) {
            return false;
          }
          if (typeof version === "string") {
            try {
              version = new SemVer(version, this.options);
            } catch (er) {
              return false;
            }
          }
          for (let i = 0; i < this.set.length; i++) {
            if (testSet(this.set[i], version, this.options)) {
              return true;
            }
          }
          return false;
        }
      };
      module2.exports = Range;
      var LRU = require_lru_cache();
      var cache = new LRU({ max: 1e3 });
      var parseOptions = require_parse_options();
      var Comparator = require_comparator();
      var debug = require_debug();
      var SemVer = require_semver();
      var {
        re,
        t,
        comparatorTrimReplace,
        tildeTrimReplace,
        caretTrimReplace
      } = require_re();
      var isNullSet = (c) => c.value === "<0.0.0-0";
      var isAny = (c) => c.value === "";
      var isSatisfiable = (comparators, options) => {
        let result = true;
        const remainingComparators = comparators.slice();
        let testComparator = remainingComparators.pop();
        while (result && remainingComparators.length) {
          result = remainingComparators.every((otherComparator) => {
            return testComparator.intersects(otherComparator, options);
          });
          testComparator = remainingComparators.pop();
        }
        return result;
      };
      var parseComparator = (comp, options) => {
        debug("comp", comp, options);
        comp = replaceCarets(comp, options);
        debug("caret", comp);
        comp = replaceTildes(comp, options);
        debug("tildes", comp);
        comp = replaceXRanges(comp, options);
        debug("xrange", comp);
        comp = replaceStars(comp, options);
        debug("stars", comp);
        return comp;
      };
      var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
      var replaceTildes = (comp, options) => comp.trim().split(/\s+/).map((comp2) => {
        return replaceTilde(comp2, options);
      }).join(" ");
      var replaceTilde = (comp, options) => {
        const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
        return comp.replace(r, (_, M, m, p, pr) => {
          debug("tilde", comp, _, M, m, p, pr);
          let ret;
          if (isX(M)) {
            ret = "";
          } else if (isX(m)) {
            ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
          } else if (isX(p)) {
            ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
          } else if (pr) {
            debug("replaceTilde pr", pr);
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
          }
          debug("tilde return", ret);
          return ret;
        });
      };
      var replaceCarets = (comp, options) => comp.trim().split(/\s+/).map((comp2) => {
        return replaceCaret(comp2, options);
      }).join(" ");
      var replaceCaret = (comp, options) => {
        debug("caret", comp, options);
        const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
        const z = options.includePrerelease ? "-0" : "";
        return comp.replace(r, (_, M, m, p, pr) => {
          debug("caret", comp, _, M, m, p, pr);
          let ret;
          if (isX(M)) {
            ret = "";
          } else if (isX(m)) {
            ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
          } else if (isX(p)) {
            if (M === "0") {
              ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
            } else {
              ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
            }
          } else if (pr) {
            debug("replaceCaret pr", pr);
            if (M === "0") {
              if (m === "0") {
                ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
              } else {
                ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
              }
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
            }
          } else {
            debug("no pr");
            if (M === "0") {
              if (m === "0") {
                ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
              } else {
                ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
              }
            } else {
              ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
            }
          }
          debug("caret return", ret);
          return ret;
        });
      };
      var replaceXRanges = (comp, options) => {
        debug("replaceXRanges", comp, options);
        return comp.split(/\s+/).map((comp2) => {
          return replaceXRange(comp2, options);
        }).join(" ");
      };
      var replaceXRange = (comp, options) => {
        comp = comp.trim();
        const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
        return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
          debug("xRange", comp, ret, gtlt, M, m, p, pr);
          const xM = isX(M);
          const xm = xM || isX(m);
          const xp = xm || isX(p);
          const anyX = xp;
          if (gtlt === "=" && anyX) {
            gtlt = "";
          }
          pr = options.includePrerelease ? "-0" : "";
          if (xM) {
            if (gtlt === ">" || gtlt === "<") {
              ret = "<0.0.0-0";
            } else {
              ret = "*";
            }
          } else if (gtlt && anyX) {
            if (xm) {
              m = 0;
            }
            p = 0;
            if (gtlt === ">") {
              gtlt = ">=";
              if (xm) {
                M = +M + 1;
                m = 0;
                p = 0;
              } else {
                m = +m + 1;
                p = 0;
              }
            } else if (gtlt === "<=") {
              gtlt = "<";
              if (xm) {
                M = +M + 1;
              } else {
                m = +m + 1;
              }
            }
            if (gtlt === "<")
              pr = "-0";
            ret = `${gtlt + M}.${m}.${p}${pr}`;
          } else if (xm) {
            ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
          } else if (xp) {
            ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
          }
          debug("xRange return", ret);
          return ret;
        });
      };
      var replaceStars = (comp, options) => {
        debug("replaceStars", comp, options);
        return comp.trim().replace(re[t.STAR], "");
      };
      var replaceGTE0 = (comp, options) => {
        debug("replaceGTE0", comp, options);
        return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
      };
      var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
        if (isX(fM)) {
          from = "";
        } else if (isX(fm)) {
          from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
        } else if (isX(fp)) {
          from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
        } else if (fpr) {
          from = `>=${from}`;
        } else {
          from = `>=${from}${incPr ? "-0" : ""}`;
        }
        if (isX(tM)) {
          to = "";
        } else if (isX(tm)) {
          to = `<${+tM + 1}.0.0-0`;
        } else if (isX(tp)) {
          to = `<${tM}.${+tm + 1}.0-0`;
        } else if (tpr) {
          to = `<=${tM}.${tm}.${tp}-${tpr}`;
        } else if (incPr) {
          to = `<${tM}.${tm}.${+tp + 1}-0`;
        } else {
          to = `<=${to}`;
        }
        return `${from} ${to}`.trim();
      };
      var testSet = (set, version, options) => {
        for (let i = 0; i < set.length; i++) {
          if (!set[i].test(version)) {
            return false;
          }
        }
        if (version.prerelease.length && !options.includePrerelease) {
          for (let i = 0; i < set.length; i++) {
            debug(set[i].semver);
            if (set[i].semver === Comparator.ANY) {
              continue;
            }
            if (set[i].semver.prerelease.length > 0) {
              const allowed = set[i].semver;
              if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
                return true;
              }
            }
          }
          return false;
        }
        return true;
      };
    }
  });

  // node_modules/superagent/node_modules/semver/classes/comparator.js
  var require_comparator = __commonJS({
    "node_modules/superagent/node_modules/semver/classes/comparator.js"(exports2, module2) {
      var ANY = Symbol("SemVer ANY");
      var Comparator = class {
        static get ANY() {
          return ANY;
        }
        constructor(comp, options) {
          options = parseOptions(options);
          if (comp instanceof Comparator) {
            if (comp.loose === !!options.loose) {
              return comp;
            } else {
              comp = comp.value;
            }
          }
          debug("comparator", comp, options);
          this.options = options;
          this.loose = !!options.loose;
          this.parse(comp);
          if (this.semver === ANY) {
            this.value = "";
          } else {
            this.value = this.operator + this.semver.version;
          }
          debug("comp", this);
        }
        parse(comp) {
          const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
          const m = comp.match(r);
          if (!m) {
            throw new TypeError(`Invalid comparator: ${comp}`);
          }
          this.operator = m[1] !== void 0 ? m[1] : "";
          if (this.operator === "=") {
            this.operator = "";
          }
          if (!m[2]) {
            this.semver = ANY;
          } else {
            this.semver = new SemVer(m[2], this.options.loose);
          }
        }
        toString() {
          return this.value;
        }
        test(version) {
          debug("Comparator.test", version, this.options.loose);
          if (this.semver === ANY || version === ANY) {
            return true;
          }
          if (typeof version === "string") {
            try {
              version = new SemVer(version, this.options);
            } catch (er) {
              return false;
            }
          }
          return cmp(version, this.operator, this.semver, this.options);
        }
        intersects(comp, options) {
          if (!(comp instanceof Comparator)) {
            throw new TypeError("a Comparator is required");
          }
          if (!options || typeof options !== "object") {
            options = {
              loose: !!options,
              includePrerelease: false
            };
          }
          if (this.operator === "") {
            if (this.value === "") {
              return true;
            }
            return new Range(comp.value, options).test(this.value);
          } else if (comp.operator === "") {
            if (comp.value === "") {
              return true;
            }
            return new Range(this.value, options).test(comp.semver);
          }
          const sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
          const sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
          const sameSemVer = this.semver.version === comp.semver.version;
          const differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
          const oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && (this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<");
          const oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && (this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">");
          return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
        }
      };
      module2.exports = Comparator;
      var parseOptions = require_parse_options();
      var { re, t } = require_re();
      var cmp = require_cmp();
      var debug = require_debug();
      var SemVer = require_semver();
      var Range = require_range();
    }
  });

  // node_modules/superagent/node_modules/semver/functions/satisfies.js
  var require_satisfies = __commonJS({
    "node_modules/superagent/node_modules/semver/functions/satisfies.js"(exports2, module2) {
      var Range = require_range();
      var satisfies = (version, range, options) => {
        try {
          range = new Range(range, options);
        } catch (er) {
          return false;
        }
        return range.test(version);
      };
      module2.exports = satisfies;
    }
  });

  // node_modules/superagent/node_modules/semver/ranges/to-comparators.js
  var require_to_comparators = __commonJS({
    "node_modules/superagent/node_modules/semver/ranges/to-comparators.js"(exports2, module2) {
      var Range = require_range();
      var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
      module2.exports = toComparators;
    }
  });

  // node_modules/superagent/node_modules/semver/ranges/max-satisfying.js
  var require_max_satisfying = __commonJS({
    "node_modules/superagent/node_modules/semver/ranges/max-satisfying.js"(exports2, module2) {
      var SemVer = require_semver();
      var Range = require_range();
      var maxSatisfying = (versions, range, options) => {
        let max = null;
        let maxSV = null;
        let rangeObj = null;
        try {
          rangeObj = new Range(range, options);
        } catch (er) {
          return null;
        }
        versions.forEach((v) => {
          if (rangeObj.test(v)) {
            if (!max || maxSV.compare(v) === -1) {
              max = v;
              maxSV = new SemVer(max, options);
            }
          }
        });
        return max;
      };
      module2.exports = maxSatisfying;
    }
  });

  // node_modules/superagent/node_modules/semver/ranges/min-satisfying.js
  var require_min_satisfying = __commonJS({
    "node_modules/superagent/node_modules/semver/ranges/min-satisfying.js"(exports2, module2) {
      var SemVer = require_semver();
      var Range = require_range();
      var minSatisfying = (versions, range, options) => {
        let min = null;
        let minSV = null;
        let rangeObj = null;
        try {
          rangeObj = new Range(range, options);
        } catch (er) {
          return null;
        }
        versions.forEach((v) => {
          if (rangeObj.test(v)) {
            if (!min || minSV.compare(v) === 1) {
              min = v;
              minSV = new SemVer(min, options);
            }
          }
        });
        return min;
      };
      module2.exports = minSatisfying;
    }
  });

  // node_modules/superagent/node_modules/semver/ranges/min-version.js
  var require_min_version = __commonJS({
    "node_modules/superagent/node_modules/semver/ranges/min-version.js"(exports2, module2) {
      var SemVer = require_semver();
      var Range = require_range();
      var gt = require_gt();
      var minVersion = (range, loose) => {
        range = new Range(range, loose);
        let minver = new SemVer("0.0.0");
        if (range.test(minver)) {
          return minver;
        }
        minver = new SemVer("0.0.0-0");
        if (range.test(minver)) {
          return minver;
        }
        minver = null;
        for (let i = 0; i < range.set.length; ++i) {
          const comparators = range.set[i];
          let setMin = null;
          comparators.forEach((comparator) => {
            const compver = new SemVer(comparator.semver.version);
            switch (comparator.operator) {
              case ">":
                if (compver.prerelease.length === 0) {
                  compver.patch++;
                } else {
                  compver.prerelease.push(0);
                }
                compver.raw = compver.format();
              case "":
              case ">=":
                if (!setMin || gt(compver, setMin)) {
                  setMin = compver;
                }
                break;
              case "<":
              case "<=":
                break;
              default:
                throw new Error(`Unexpected operation: ${comparator.operator}`);
            }
          });
          if (setMin && (!minver || gt(minver, setMin)))
            minver = setMin;
        }
        if (minver && range.test(minver)) {
          return minver;
        }
        return null;
      };
      module2.exports = minVersion;
    }
  });

  // node_modules/superagent/node_modules/semver/ranges/valid.js
  var require_valid2 = __commonJS({
    "node_modules/superagent/node_modules/semver/ranges/valid.js"(exports2, module2) {
      var Range = require_range();
      var validRange = (range, options) => {
        try {
          return new Range(range, options).range || "*";
        } catch (er) {
          return null;
        }
      };
      module2.exports = validRange;
    }
  });

  // node_modules/superagent/node_modules/semver/ranges/outside.js
  var require_outside = __commonJS({
    "node_modules/superagent/node_modules/semver/ranges/outside.js"(exports2, module2) {
      var SemVer = require_semver();
      var Comparator = require_comparator();
      var { ANY } = Comparator;
      var Range = require_range();
      var satisfies = require_satisfies();
      var gt = require_gt();
      var lt = require_lt();
      var lte = require_lte();
      var gte = require_gte();
      var outside = (version, range, hilo, options) => {
        version = new SemVer(version, options);
        range = new Range(range, options);
        let gtfn, ltefn, ltfn, comp, ecomp;
        switch (hilo) {
          case ">":
            gtfn = gt;
            ltefn = lte;
            ltfn = lt;
            comp = ">";
            ecomp = ">=";
            break;
          case "<":
            gtfn = lt;
            ltefn = gte;
            ltfn = gt;
            comp = "<";
            ecomp = "<=";
            break;
          default:
            throw new TypeError('Must provide a hilo val of "<" or ">"');
        }
        if (satisfies(version, range, options)) {
          return false;
        }
        for (let i = 0; i < range.set.length; ++i) {
          const comparators = range.set[i];
          let high = null;
          let low = null;
          comparators.forEach((comparator) => {
            if (comparator.semver === ANY) {
              comparator = new Comparator(">=0.0.0");
            }
            high = high || comparator;
            low = low || comparator;
            if (gtfn(comparator.semver, high.semver, options)) {
              high = comparator;
            } else if (ltfn(comparator.semver, low.semver, options)) {
              low = comparator;
            }
          });
          if (high.operator === comp || high.operator === ecomp) {
            return false;
          }
          if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
            return false;
          } else if (low.operator === ecomp && ltfn(version, low.semver)) {
            return false;
          }
        }
        return true;
      };
      module2.exports = outside;
    }
  });

  // node_modules/superagent/node_modules/semver/ranges/gtr.js
  var require_gtr = __commonJS({
    "node_modules/superagent/node_modules/semver/ranges/gtr.js"(exports2, module2) {
      var outside = require_outside();
      var gtr = (version, range, options) => outside(version, range, ">", options);
      module2.exports = gtr;
    }
  });

  // node_modules/superagent/node_modules/semver/ranges/ltr.js
  var require_ltr = __commonJS({
    "node_modules/superagent/node_modules/semver/ranges/ltr.js"(exports2, module2) {
      var outside = require_outside();
      var ltr = (version, range, options) => outside(version, range, "<", options);
      module2.exports = ltr;
    }
  });

  // node_modules/superagent/node_modules/semver/ranges/intersects.js
  var require_intersects = __commonJS({
    "node_modules/superagent/node_modules/semver/ranges/intersects.js"(exports2, module2) {
      var Range = require_range();
      var intersects = (r1, r2, options) => {
        r1 = new Range(r1, options);
        r2 = new Range(r2, options);
        return r1.intersects(r2);
      };
      module2.exports = intersects;
    }
  });

  // node_modules/superagent/node_modules/semver/ranges/simplify.js
  var require_simplify = __commonJS({
    "node_modules/superagent/node_modules/semver/ranges/simplify.js"(exports2, module2) {
      var satisfies = require_satisfies();
      var compare2 = require_compare();
      module2.exports = (versions, range, options) => {
        const set = [];
        let min = null;
        let prev = null;
        const v = versions.sort((a, b) => compare2(a, b, options));
        for (const version of v) {
          const included = satisfies(version, range, options);
          if (included) {
            prev = version;
            if (!min)
              min = version;
          } else {
            if (prev) {
              set.push([min, prev]);
            }
            prev = null;
            min = null;
          }
        }
        if (min)
          set.push([min, null]);
        const ranges = [];
        for (const [min2, max] of set) {
          if (min2 === max)
            ranges.push(min2);
          else if (!max && min2 === v[0])
            ranges.push("*");
          else if (!max)
            ranges.push(`>=${min2}`);
          else if (min2 === v[0])
            ranges.push(`<=${max}`);
          else
            ranges.push(`${min2} - ${max}`);
        }
        const simplified = ranges.join(" || ");
        const original = typeof range.raw === "string" ? range.raw : String(range);
        return simplified.length < original.length ? simplified : range;
      };
    }
  });

  // node_modules/superagent/node_modules/semver/ranges/subset.js
  var require_subset = __commonJS({
    "node_modules/superagent/node_modules/semver/ranges/subset.js"(exports2, module2) {
      var Range = require_range();
      var Comparator = require_comparator();
      var { ANY } = Comparator;
      var satisfies = require_satisfies();
      var compare2 = require_compare();
      var subset = (sub, dom, options = {}) => {
        if (sub === dom)
          return true;
        sub = new Range(sub, options);
        dom = new Range(dom, options);
        let sawNonNull = false;
        OUTER:
          for (const simpleSub of sub.set) {
            for (const simpleDom of dom.set) {
              const isSub = simpleSubset(simpleSub, simpleDom, options);
              sawNonNull = sawNonNull || isSub !== null;
              if (isSub)
                continue OUTER;
            }
            if (sawNonNull)
              return false;
          }
        return true;
      };
      var simpleSubset = (sub, dom, options) => {
        if (sub === dom)
          return true;
        if (sub.length === 1 && sub[0].semver === ANY) {
          if (dom.length === 1 && dom[0].semver === ANY)
            return true;
          else if (options.includePrerelease)
            sub = [new Comparator(">=0.0.0-0")];
          else
            sub = [new Comparator(">=0.0.0")];
        }
        if (dom.length === 1 && dom[0].semver === ANY) {
          if (options.includePrerelease)
            return true;
          else
            dom = [new Comparator(">=0.0.0")];
        }
        const eqSet = /* @__PURE__ */ new Set();
        let gt, lt;
        for (const c of sub) {
          if (c.operator === ">" || c.operator === ">=")
            gt = higherGT(gt, c, options);
          else if (c.operator === "<" || c.operator === "<=")
            lt = lowerLT(lt, c, options);
          else
            eqSet.add(c.semver);
        }
        if (eqSet.size > 1)
          return null;
        let gtltComp;
        if (gt && lt) {
          gtltComp = compare2(gt.semver, lt.semver, options);
          if (gtltComp > 0)
            return null;
          else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<="))
            return null;
        }
        for (const eq of eqSet) {
          if (gt && !satisfies(eq, String(gt), options))
            return null;
          if (lt && !satisfies(eq, String(lt), options))
            return null;
          for (const c of dom) {
            if (!satisfies(eq, String(c), options))
              return false;
          }
          return true;
        }
        let higher, lower;
        let hasDomLT, hasDomGT;
        let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
        let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
        if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
          needDomLTPre = false;
        }
        for (const c of dom) {
          hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
          hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
          if (gt) {
            if (needDomGTPre) {
              if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
                needDomGTPre = false;
              }
            }
            if (c.operator === ">" || c.operator === ">=") {
              higher = higherGT(gt, c, options);
              if (higher === c && higher !== gt)
                return false;
            } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options))
              return false;
          }
          if (lt) {
            if (needDomLTPre) {
              if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
                needDomLTPre = false;
              }
            }
            if (c.operator === "<" || c.operator === "<=") {
              lower = lowerLT(lt, c, options);
              if (lower === c && lower !== lt)
                return false;
            } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options))
              return false;
          }
          if (!c.operator && (lt || gt) && gtltComp !== 0)
            return false;
        }
        if (gt && hasDomLT && !lt && gtltComp !== 0)
          return false;
        if (lt && hasDomGT && !gt && gtltComp !== 0)
          return false;
        if (needDomGTPre || needDomLTPre)
          return false;
        return true;
      };
      var higherGT = (a, b, options) => {
        if (!a)
          return b;
        const comp = compare2(a.semver, b.semver, options);
        return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
      };
      var lowerLT = (a, b, options) => {
        if (!a)
          return b;
        const comp = compare2(a.semver, b.semver, options);
        return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
      };
      module2.exports = subset;
    }
  });

  // node_modules/superagent/node_modules/semver/index.js
  var require_semver2 = __commonJS({
    "node_modules/superagent/node_modules/semver/index.js"(exports2, module2) {
      var internalRe = require_re();
      module2.exports = {
        re: internalRe.re,
        src: internalRe.src,
        tokens: internalRe.t,
        SEMVER_SPEC_VERSION: require_constants().SEMVER_SPEC_VERSION,
        SemVer: require_semver(),
        compareIdentifiers: require_identifiers().compareIdentifiers,
        rcompareIdentifiers: require_identifiers().rcompareIdentifiers,
        parse: require_parse3(),
        valid: require_valid(),
        clean: require_clean(),
        inc: require_inc(),
        diff: require_diff(),
        major: require_major(),
        minor: require_minor(),
        patch: require_patch(),
        prerelease: require_prerelease(),
        compare: require_compare(),
        rcompare: require_rcompare(),
        compareLoose: require_compare_loose(),
        compareBuild: require_compare_build(),
        sort: require_sort(),
        rsort: require_rsort(),
        gt: require_gt(),
        lt: require_lt(),
        eq: require_eq(),
        neq: require_neq(),
        gte: require_gte(),
        lte: require_lte(),
        cmp: require_cmp(),
        coerce: require_coerce(),
        Comparator: require_comparator(),
        Range: require_range(),
        satisfies: require_satisfies(),
        toComparators: require_to_comparators(),
        maxSatisfying: require_max_satisfying(),
        minSatisfying: require_min_satisfying(),
        minVersion: require_min_version(),
        validRange: require_valid2(),
        outside: require_outside(),
        gtr: require_gtr(),
        ltr: require_ltr(),
        intersects: require_intersects(),
        simplifyRange: require_simplify(),
        subset: require_subset()
      };
    }
  });

  // node_modules/fast-safe-stringify/index.js
  var require_fast_safe_stringify = __commonJS({
    "node_modules/fast-safe-stringify/index.js"(exports2, module2) {
      module2.exports = stringify;
      stringify.default = stringify;
      stringify.stable = deterministicStringify;
      stringify.stableStringify = deterministicStringify;
      var LIMIT_REPLACE_NODE = "[...]";
      var CIRCULAR_REPLACE_NODE = "[Circular]";
      var arr = [];
      var replacerStack = [];
      function defaultOptions() {
        return {
          depthLimit: Number.MAX_SAFE_INTEGER,
          edgesLimit: Number.MAX_SAFE_INTEGER
        };
      }
      function stringify(obj, replacer, spacer, options) {
        if (typeof options === "undefined") {
          options = defaultOptions();
        }
        decirc(obj, "", 0, [], void 0, 0, options);
        var res;
        try {
          if (replacerStack.length === 0) {
            res = JSON.stringify(obj, replacer, spacer);
          } else {
            res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);
          }
        } catch (_) {
          return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
        } finally {
          while (arr.length !== 0) {
            var part = arr.pop();
            if (part.length === 4) {
              Object.defineProperty(part[0], part[1], part[3]);
            } else {
              part[0][part[1]] = part[2];
            }
          }
        }
        return res;
      }
      function setReplace(replace, val, k, parent) {
        var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);
        if (propertyDescriptor.get !== void 0) {
          if (propertyDescriptor.configurable) {
            Object.defineProperty(parent, k, { value: replace });
            arr.push([parent, k, val, propertyDescriptor]);
          } else {
            replacerStack.push([val, k, replace]);
          }
        } else {
          parent[k] = replace;
          arr.push([parent, k, val]);
        }
      }
      function decirc(val, k, edgeIndex, stack, parent, depth, options) {
        depth += 1;
        var i;
        if (typeof val === "object" && val !== null) {
          for (i = 0; i < stack.length; i++) {
            if (stack[i] === val) {
              setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
              return;
            }
          }
          if (typeof options.depthLimit !== "undefined" && depth > options.depthLimit) {
            setReplace(LIMIT_REPLACE_NODE, val, k, parent);
            return;
          }
          if (typeof options.edgesLimit !== "undefined" && edgeIndex + 1 > options.edgesLimit) {
            setReplace(LIMIT_REPLACE_NODE, val, k, parent);
            return;
          }
          stack.push(val);
          if (Array.isArray(val)) {
            for (i = 0; i < val.length; i++) {
              decirc(val[i], i, i, stack, val, depth, options);
            }
          } else {
            var keys = Object.keys(val);
            for (i = 0; i < keys.length; i++) {
              var key = keys[i];
              decirc(val[key], key, i, stack, val, depth, options);
            }
          }
          stack.pop();
        }
      }
      function compareFunction(a, b) {
        if (a < b) {
          return -1;
        }
        if (a > b) {
          return 1;
        }
        return 0;
      }
      function deterministicStringify(obj, replacer, spacer, options) {
        if (typeof options === "undefined") {
          options = defaultOptions();
        }
        var tmp = deterministicDecirc(obj, "", 0, [], void 0, 0, options) || obj;
        var res;
        try {
          if (replacerStack.length === 0) {
            res = JSON.stringify(tmp, replacer, spacer);
          } else {
            res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);
          }
        } catch (_) {
          return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
        } finally {
          while (arr.length !== 0) {
            var part = arr.pop();
            if (part.length === 4) {
              Object.defineProperty(part[0], part[1], part[3]);
            } else {
              part[0][part[1]] = part[2];
            }
          }
        }
        return res;
      }
      function deterministicDecirc(val, k, edgeIndex, stack, parent, depth, options) {
        depth += 1;
        var i;
        if (typeof val === "object" && val !== null) {
          for (i = 0; i < stack.length; i++) {
            if (stack[i] === val) {
              setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
              return;
            }
          }
          try {
            if (typeof val.toJSON === "function") {
              return;
            }
          } catch (_) {
            return;
          }
          if (typeof options.depthLimit !== "undefined" && depth > options.depthLimit) {
            setReplace(LIMIT_REPLACE_NODE, val, k, parent);
            return;
          }
          if (typeof options.edgesLimit !== "undefined" && edgeIndex + 1 > options.edgesLimit) {
            setReplace(LIMIT_REPLACE_NODE, val, k, parent);
            return;
          }
          stack.push(val);
          if (Array.isArray(val)) {
            for (i = 0; i < val.length; i++) {
              deterministicDecirc(val[i], i, i, stack, val, depth, options);
            }
          } else {
            var tmp = {};
            var keys = Object.keys(val).sort(compareFunction);
            for (i = 0; i < keys.length; i++) {
              var key = keys[i];
              deterministicDecirc(val[key], key, i, stack, val, depth, options);
              tmp[key] = val[key];
            }
            if (typeof parent !== "undefined") {
              arr.push([parent, k, val]);
              parent[k] = tmp;
            } else {
              return tmp;
            }
          }
          stack.pop();
        }
      }
      function replaceGetterValues(replacer) {
        replacer = typeof replacer !== "undefined" ? replacer : function(k, v) {
          return v;
        };
        return function(key, val) {
          if (replacerStack.length > 0) {
            for (var i = 0; i < replacerStack.length; i++) {
              var part = replacerStack[i];
              if (part[1] === key && part[0] === val) {
                val = part[2];
                replacerStack.splice(i, 1);
                break;
              }
            }
          }
          return replacer.call(this, key, val);
        };
      }
    }
  });

  // node_modules/superagent/lib/utils.js
  var require_utils2 = __commonJS({
    "node_modules/superagent/lib/utils.js"(exports2) {
      "use strict";
      function _createForOfIteratorHelper(o, allowArrayLike) {
        var it;
        if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
          if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it)
              o = it;
            var i = 0;
            var F = function F2() {
            };
            return { s: F, n: function n() {
              if (i >= o.length)
                return { done: true };
              return { done: false, value: o[i++] };
            }, e: function e(_e) {
              throw _e;
            }, f: F };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var normalCompletion = true, didErr = false, err;
        return { s: function s() {
          it = o[Symbol.iterator]();
        }, n: function n() {
          var step = it.next();
          normalCompletion = step.done;
          return step;
        }, e: function e(_e2) {
          didErr = true;
          err = _e2;
        }, f: function f() {
          try {
            if (!normalCompletion && it.return != null)
              it.return();
          } finally {
            if (didErr)
              throw err;
          }
        } };
      }
      function _unsupportedIterableToArray(o, minLen) {
        if (!o)
          return;
        if (typeof o === "string")
          return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor)
          n = o.constructor.name;
        if (n === "Map" || n === "Set")
          return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _arrayLikeToArray(o, minLen);
      }
      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length)
          len = arr.length;
        for (var i = 0, arr2 = new Array(len); i < len; i++) {
          arr2[i] = arr[i];
        }
        return arr2;
      }
      exports2.type = function(str) {
        return str.split(/ *; */).shift();
      };
      exports2.params = function(val) {
        var obj = {};
        var _iterator = _createForOfIteratorHelper(val.split(/ *; */)), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var str = _step.value;
            var parts = str.split(/ *= */);
            var key = parts.shift();
            var _val = parts.shift();
            if (key && _val)
              obj[key] = _val;
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        return obj;
      };
      exports2.parseLinks = function(val) {
        var obj = {};
        var _iterator2 = _createForOfIteratorHelper(val.split(/ *, */)), _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            var str = _step2.value;
            var parts = str.split(/ *; */);
            var url = parts[0].slice(1, -1);
            var rel = parts[1].split(/ *= */)[1].slice(1, -1);
            obj[rel] = url;
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
        return obj;
      };
      exports2.cleanHeader = function(header, changesOrigin) {
        delete header["content-type"];
        delete header["content-length"];
        delete header["transfer-encoding"];
        delete header.host;
        if (changesOrigin) {
          delete header.authorization;
          delete header.cookie;
        }
        return header;
      };
    }
  });

  // node_modules/superagent/lib/is-object.js
  var require_is_object = __commonJS({
    "node_modules/superagent/lib/is-object.js"(exports2, module2) {
      "use strict";
      function _typeof(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof2(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof = function _typeof2(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof(obj);
      }
      function isObject(obj) {
        return obj !== null && _typeof(obj) === "object";
      }
      module2.exports = isObject;
    }
  });

  // node_modules/superagent/lib/request-base.js
  var require_request_base = __commonJS({
    "node_modules/superagent/lib/request-base.js"(exports2, module2) {
      "use strict";
      function _typeof(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof2(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof = function _typeof2(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof(obj);
      }
      var isObject = require_is_object();
      module2.exports = RequestBase;
      function RequestBase(object) {
        if (object)
          return mixin(object);
      }
      function mixin(object) {
        for (var key in RequestBase.prototype) {
          if (Object.prototype.hasOwnProperty.call(RequestBase.prototype, key))
            object[key] = RequestBase.prototype[key];
        }
        return object;
      }
      RequestBase.prototype.clearTimeout = function() {
        clearTimeout(this._timer);
        clearTimeout(this._responseTimeoutTimer);
        clearTimeout(this._uploadTimeoutTimer);
        delete this._timer;
        delete this._responseTimeoutTimer;
        delete this._uploadTimeoutTimer;
        return this;
      };
      RequestBase.prototype.parse = function(fn) {
        this._parser = fn;
        return this;
      };
      RequestBase.prototype.responseType = function(value) {
        this._responseType = value;
        return this;
      };
      RequestBase.prototype.serialize = function(fn) {
        this._serializer = fn;
        return this;
      };
      RequestBase.prototype.timeout = function(options) {
        if (!options || _typeof(options) !== "object") {
          this._timeout = options;
          this._responseTimeout = 0;
          this._uploadTimeout = 0;
          return this;
        }
        for (var option in options) {
          if (Object.prototype.hasOwnProperty.call(options, option)) {
            switch (option) {
              case "deadline":
                this._timeout = options.deadline;
                break;
              case "response":
                this._responseTimeout = options.response;
                break;
              case "upload":
                this._uploadTimeout = options.upload;
                break;
              default:
                console.warn("Unknown timeout option", option);
            }
          }
        }
        return this;
      };
      RequestBase.prototype.retry = function(count, fn) {
        if (arguments.length === 0 || count === true)
          count = 1;
        if (count <= 0)
          count = 0;
        this._maxRetries = count;
        this._retries = 0;
        this._retryCallback = fn;
        return this;
      };
      var ERROR_CODES = /* @__PURE__ */ new Set(["ETIMEDOUT", "ECONNRESET", "EADDRINUSE", "ECONNREFUSED", "EPIPE", "ENOTFOUND", "ENETUNREACH", "EAI_AGAIN"]);
      var STATUS_CODES = /* @__PURE__ */ new Set([408, 413, 429, 500, 502, 503, 504, 521, 522, 524]);
      RequestBase.prototype._shouldRetry = function(err, res) {
        if (!this._maxRetries || this._retries++ >= this._maxRetries) {
          return false;
        }
        if (this._retryCallback) {
          try {
            var override = this._retryCallback(err, res);
            if (override === true)
              return true;
            if (override === false)
              return false;
          } catch (err_) {
            console.error(err_);
          }
        }
        if (res && res.status && STATUS_CODES.has(res.status))
          return true;
        if (err) {
          if (err.code && ERROR_CODES.has(err.code))
            return true;
          if (err.timeout && err.code === "ECONNABORTED")
            return true;
          if (err.crossDomain)
            return true;
        }
        return false;
      };
      RequestBase.prototype._retry = function() {
        this.clearTimeout();
        if (this.req) {
          this.req = null;
          this.req = this.request();
        }
        this._aborted = false;
        this.timedout = false;
        this.timedoutError = null;
        return this._end();
      };
      RequestBase.prototype.then = function(resolve, reject) {
        var _this = this;
        if (!this._fullfilledPromise) {
          var self2 = this;
          if (this._endCalled) {
            console.warn("Warning: superagent request was sent twice, because both .end() and .then() were called. Never call .end() if you use promises");
          }
          this._fullfilledPromise = new Promise(function(resolve2, reject2) {
            self2.on("abort", function() {
              if (_this._maxRetries && _this._maxRetries > _this._retries) {
                return;
              }
              if (_this.timedout && _this.timedoutError) {
                reject2(_this.timedoutError);
                return;
              }
              var err = new Error("Aborted");
              err.code = "ABORTED";
              err.status = _this.status;
              err.method = _this.method;
              err.url = _this.url;
              reject2(err);
            });
            self2.end(function(err, res) {
              if (err)
                reject2(err);
              else
                resolve2(res);
            });
          });
        }
        return this._fullfilledPromise.then(resolve, reject);
      };
      RequestBase.prototype.catch = function(cb) {
        return this.then(void 0, cb);
      };
      RequestBase.prototype.use = function(fn) {
        fn(this);
        return this;
      };
      RequestBase.prototype.ok = function(cb) {
        if (typeof cb !== "function")
          throw new Error("Callback required");
        this._okCallback = cb;
        return this;
      };
      RequestBase.prototype._isResponseOK = function(res) {
        if (!res) {
          return false;
        }
        if (this._okCallback) {
          return this._okCallback(res);
        }
        return res.status >= 200 && res.status < 300;
      };
      RequestBase.prototype.get = function(field) {
        return this._header[field.toLowerCase()];
      };
      RequestBase.prototype.getHeader = RequestBase.prototype.get;
      RequestBase.prototype.set = function(field, value) {
        if (isObject(field)) {
          for (var key in field) {
            if (Object.prototype.hasOwnProperty.call(field, key))
              this.set(key, field[key]);
          }
          return this;
        }
        this._header[field.toLowerCase()] = value;
        this.header[field] = value;
        return this;
      };
      RequestBase.prototype.unset = function(field) {
        delete this._header[field.toLowerCase()];
        delete this.header[field];
        return this;
      };
      RequestBase.prototype.field = function(name, value) {
        if (name === null || name === void 0) {
          throw new Error(".field(name, val) name can not be empty");
        }
        if (this._data) {
          throw new Error(".field() can't be used if .send() is used. Please use only .send() or only .field() & .attach()");
        }
        if (isObject(name)) {
          for (var key in name) {
            if (Object.prototype.hasOwnProperty.call(name, key))
              this.field(key, name[key]);
          }
          return this;
        }
        if (Array.isArray(value)) {
          for (var i in value) {
            if (Object.prototype.hasOwnProperty.call(value, i))
              this.field(name, value[i]);
          }
          return this;
        }
        if (value === null || value === void 0) {
          throw new Error(".field(name, val) val can not be empty");
        }
        if (typeof value === "boolean") {
          value = String(value);
        }
        this._getFormData().append(name, value);
        return this;
      };
      RequestBase.prototype.abort = function() {
        if (this._aborted) {
          return this;
        }
        this._aborted = true;
        if (this.xhr)
          this.xhr.abort();
        if (this.req)
          this.req.abort();
        this.clearTimeout();
        this.emit("abort");
        return this;
      };
      RequestBase.prototype._auth = function(user, pass, options, base64Encoder) {
        switch (options.type) {
          case "basic":
            this.set("Authorization", "Basic ".concat(base64Encoder("".concat(user, ":").concat(pass))));
            break;
          case "auto":
            this.username = user;
            this.password = pass;
            break;
          case "bearer":
            this.set("Authorization", "Bearer ".concat(user));
            break;
          default:
            break;
        }
        return this;
      };
      RequestBase.prototype.withCredentials = function(on) {
        if (on === void 0)
          on = true;
        this._withCredentials = on;
        return this;
      };
      RequestBase.prototype.redirects = function(n) {
        this._maxRedirects = n;
        return this;
      };
      RequestBase.prototype.maxResponseSize = function(n) {
        if (typeof n !== "number") {
          throw new TypeError("Invalid argument");
        }
        this._maxResponseSize = n;
        return this;
      };
      RequestBase.prototype.toJSON = function() {
        return {
          method: this.method,
          url: this.url,
          data: this._data,
          headers: this._header
        };
      };
      RequestBase.prototype.send = function(data) {
        var isObject_ = isObject(data);
        var type = this._header["content-type"];
        if (this._formData) {
          throw new Error(".send() can't be used if .attach() or .field() is used. Please use only .send() or only .field() & .attach()");
        }
        if (isObject_ && !this._data) {
          if (Array.isArray(data)) {
            this._data = [];
          } else if (!this._isHost(data)) {
            this._data = {};
          }
        } else if (data && this._data && this._isHost(this._data)) {
          throw new Error("Can't merge these send calls");
        }
        if (isObject_ && isObject(this._data)) {
          for (var key in data) {
            if (Object.prototype.hasOwnProperty.call(data, key))
              this._data[key] = data[key];
          }
        } else if (typeof data === "string") {
          if (!type)
            this.type("form");
          type = this._header["content-type"];
          if (type)
            type = type.toLowerCase().trim();
          if (type === "application/x-www-form-urlencoded") {
            this._data = this._data ? "".concat(this._data, "&").concat(data) : data;
          } else {
            this._data = (this._data || "") + data;
          }
        } else {
          this._data = data;
        }
        if (!isObject_ || this._isHost(data)) {
          return this;
        }
        if (!type)
          this.type("json");
        return this;
      };
      RequestBase.prototype.sortQuery = function(sort) {
        this._sort = typeof sort === "undefined" ? true : sort;
        return this;
      };
      RequestBase.prototype._finalizeQueryString = function() {
        var query = this._query.join("&");
        if (query) {
          this.url += (this.url.includes("?") ? "&" : "?") + query;
        }
        this._query.length = 0;
        if (this._sort) {
          var index = this.url.indexOf("?");
          if (index >= 0) {
            var queryArray = this.url.slice(index + 1).split("&");
            if (typeof this._sort === "function") {
              queryArray.sort(this._sort);
            } else {
              queryArray.sort();
            }
            this.url = this.url.slice(0, index) + "?" + queryArray.join("&");
          }
        }
      };
      RequestBase.prototype._appendQueryString = function() {
        console.warn("Unsupported");
      };
      RequestBase.prototype._timeoutError = function(reason, timeout, errno) {
        if (this._aborted) {
          return;
        }
        var err = new Error("".concat(reason + timeout, "ms exceeded"));
        err.timeout = timeout;
        err.code = "ECONNABORTED";
        err.errno = errno;
        this.timedout = true;
        this.timedoutError = err;
        this.abort();
        this.callback(err);
      };
      RequestBase.prototype._setTimeouts = function() {
        var self2 = this;
        if (this._timeout && !this._timer) {
          this._timer = setTimeout(function() {
            self2._timeoutError("Timeout of ", self2._timeout, "ETIME");
          }, this._timeout);
        }
        if (this._responseTimeout && !this._responseTimeoutTimer) {
          this._responseTimeoutTimer = setTimeout(function() {
            self2._timeoutError("Response timeout of ", self2._responseTimeout, "ETIMEDOUT");
          }, this._responseTimeout);
        }
      };
    }
  });

  // node_modules/superagent/lib/node/unzip.js
  var require_unzip = __commonJS({
    "node_modules/superagent/lib/node/unzip.js"(exports2) {
      "use strict";
      var _require = __require("string_decoder");
      var StringDecoder = _require.StringDecoder;
      var Stream = __require("stream");
      var zlib = __require("zlib");
      exports2.unzip = function(req, res) {
        var unzip = zlib.createUnzip();
        var stream = new Stream();
        var decoder;
        stream.req = req;
        unzip.on("error", function(err) {
          if (err && err.code === "Z_BUF_ERROR") {
            stream.emit("end");
            return;
          }
          stream.emit("error", err);
        });
        res.pipe(unzip);
        res.setEncoding = function(type) {
          decoder = new StringDecoder(type);
        };
        unzip.on("data", function(buf) {
          if (decoder) {
            var str = decoder.write(buf);
            if (str.length > 0)
              stream.emit("data", str);
          } else {
            stream.emit("data", buf);
          }
        });
        unzip.on("end", function() {
          stream.emit("end");
        });
        var _on = res.on;
        res.on = function(type, fn) {
          if (type === "data" || type === "end") {
            stream.on(type, fn.bind(res));
          } else if (type === "error") {
            stream.on(type, fn.bind(res));
            _on.call(res, type, fn);
          } else {
            _on.call(res, type, fn);
          }
          return this;
        };
      };
    }
  });

  // node_modules/superagent/lib/response-base.js
  var require_response_base = __commonJS({
    "node_modules/superagent/lib/response-base.js"(exports2, module2) {
      "use strict";
      var utils = require_utils2();
      module2.exports = ResponseBase;
      function ResponseBase(obj) {
        if (obj)
          return mixin(obj);
      }
      function mixin(obj) {
        for (var key in ResponseBase.prototype) {
          if (Object.prototype.hasOwnProperty.call(ResponseBase.prototype, key))
            obj[key] = ResponseBase.prototype[key];
        }
        return obj;
      }
      ResponseBase.prototype.get = function(field) {
        return this.header[field.toLowerCase()];
      };
      ResponseBase.prototype._setHeaderProperties = function(header) {
        var ct = header["content-type"] || "";
        this.type = utils.type(ct);
        var params = utils.params(ct);
        for (var key in params) {
          if (Object.prototype.hasOwnProperty.call(params, key))
            this[key] = params[key];
        }
        this.links = {};
        try {
          if (header.link) {
            this.links = utils.parseLinks(header.link);
          }
        } catch (_unused) {
        }
      };
      ResponseBase.prototype._setStatusProperties = function(status) {
        var type = status / 100 | 0;
        this.statusCode = status;
        this.status = this.statusCode;
        this.statusType = type;
        this.info = type === 1;
        this.ok = type === 2;
        this.redirect = type === 3;
        this.clientError = type === 4;
        this.serverError = type === 5;
        this.error = type === 4 || type === 5 ? this.toError() : false;
        this.created = status === 201;
        this.accepted = status === 202;
        this.noContent = status === 204;
        this.badRequest = status === 400;
        this.unauthorized = status === 401;
        this.notAcceptable = status === 406;
        this.forbidden = status === 403;
        this.notFound = status === 404;
        this.unprocessableEntity = status === 422;
      };
    }
  });

  // node_modules/superagent/lib/node/response.js
  var require_response = __commonJS({
    "node_modules/superagent/lib/node/response.js"(exports2, module2) {
      "use strict";
      var util = __require("util");
      var Stream = __require("stream");
      var ResponseBase = require_response_base();
      module2.exports = Response;
      function Response(req) {
        Stream.call(this);
        this.res = req.res;
        var res = this.res;
        this.request = req;
        this.req = req.req;
        this.text = res.text;
        this.body = res.body === void 0 ? {} : res.body;
        this.files = res.files || {};
        this.buffered = req._resBuffered;
        this.headers = res.headers;
        this.header = this.headers;
        this._setStatusProperties(res.statusCode);
        this._setHeaderProperties(this.header);
        this.setEncoding = res.setEncoding.bind(res);
        res.on("data", this.emit.bind(this, "data"));
        res.on("end", this.emit.bind(this, "end"));
        res.on("close", this.emit.bind(this, "close"));
        res.on("error", this.emit.bind(this, "error"));
      }
      util.inherits(Response, Stream);
      ResponseBase(Response.prototype);
      Response.prototype.destroy = function(err) {
        this.res.destroy(err);
      };
      Response.prototype.pause = function() {
        this.res.pause();
      };
      Response.prototype.resume = function() {
        this.res.resume();
      };
      Response.prototype.toError = function() {
        var req = this.req;
        var method2 = req.method;
        var path2 = req.path;
        var msg = "cannot ".concat(method2, " ").concat(path2, " (").concat(this.status, ")");
        var err = new Error(msg);
        err.status = this.status;
        err.text = this.text;
        err.method = method2;
        err.path = path2;
        return err;
      };
      Response.prototype.setStatusProperties = function(status) {
        console.warn("In superagent 2.x setStatusProperties is a private method");
        return this._setStatusProperties(status);
      };
      Response.prototype.toJSON = function() {
        return {
          req: this.request.toJSON(),
          header: this.header,
          status: this.status,
          text: this.text
        };
      };
    }
  });

  // node_modules/superagent/lib/node/http2wrapper.js
  var require_http2wrapper = __commonJS({
    "node_modules/superagent/lib/node/http2wrapper.js"(exports2) {
      "use strict";
      function ownKeys(object, enumerableOnly) {
        var keys = Object.keys(object);
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object);
          if (enumerableOnly)
            symbols = symbols.filter(function(sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
          keys.push.apply(keys, symbols);
        }
        return keys;
      }
      function _objectSpread(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i] != null ? arguments[i] : {};
          if (i % 2) {
            ownKeys(Object(source), true).forEach(function(key) {
              _defineProperty(target, key, source[key]);
            });
          } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
          } else {
            ownKeys(Object(source)).forEach(function(key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
        }
        return target;
      }
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      var Stream = __require("stream");
      var util = __require("util");
      var net = __require("net");
      var tls = __require("tls");
      var _require = __require("url");
      var parse = _require.parse;
      var semver = require_semver2();
      var http2;
      if (semver.gte(process.version, "v10.10.0"))
        http2 = __require("http2");
      else
        throw new Error("superagent: this version of Node.js does not support http2");
      var _http2$constants = http2.constants;
      var HTTP2_HEADER_PATH = _http2$constants.HTTP2_HEADER_PATH;
      var HTTP2_HEADER_STATUS = _http2$constants.HTTP2_HEADER_STATUS;
      var HTTP2_HEADER_METHOD = _http2$constants.HTTP2_HEADER_METHOD;
      var HTTP2_HEADER_AUTHORITY = _http2$constants.HTTP2_HEADER_AUTHORITY;
      var HTTP2_HEADER_HOST = _http2$constants.HTTP2_HEADER_HOST;
      var HTTP2_HEADER_SET_COOKIE = _http2$constants.HTTP2_HEADER_SET_COOKIE;
      var NGHTTP2_CANCEL = _http2$constants.NGHTTP2_CANCEL;
      function setProtocol(protocol) {
        return {
          request: function request2(options) {
            return new Request(protocol, options);
          }
        };
      }
      function Request(protocol, options) {
        var _this = this;
        Stream.call(this);
        var defaultPort = protocol === "https:" ? 443 : 80;
        var defaultHost = "localhost";
        var port = options.port || defaultPort;
        var host = options.host || defaultHost;
        delete options.port;
        delete options.host;
        this.method = options.method;
        this.path = options.path;
        this.protocol = protocol;
        this.host = host;
        delete options.method;
        delete options.path;
        var sessionOptions = _objectSpread({}, options);
        if (options.socketPath) {
          sessionOptions.socketPath = options.socketPath;
          sessionOptions.createConnection = this.createUnixConnection.bind(this);
        }
        this._headers = {};
        var session = http2.connect("".concat(protocol, "//").concat(host, ":").concat(port), sessionOptions);
        this.setHeader("host", "".concat(host, ":").concat(port));
        session.on("error", function(err) {
          return _this.emit("error", err);
        });
        this.session = session;
      }
      util.inherits(Request, Stream);
      Request.prototype.createUnixConnection = function(authority, options) {
        switch (this.protocol) {
          case "http:":
            return net.connect(options.socketPath);
          case "https:":
            options.ALPNProtocols = ["h2"];
            options.servername = this.host;
            options.allowHalfOpen = true;
            return tls.connect(options.socketPath, options);
          default:
            throw new Error("Unsupported protocol", this.protocol);
        }
      };
      Request.prototype.setNoDelay = function(bool) {
      };
      Request.prototype.getFrame = function() {
        var _method, _this2 = this;
        if (this.frame) {
          return this.frame;
        }
        var method2 = (_method = {}, _defineProperty(_method, HTTP2_HEADER_PATH, this.path), _defineProperty(_method, HTTP2_HEADER_METHOD, this.method), _method);
        var headers = this.mapToHttp2Header(this._headers);
        headers = Object.assign(headers, method2);
        var frame = this.session.request(headers);
        frame.once("response", function(headers2, flags) {
          headers2 = _this2.mapToHttpHeader(headers2);
          frame.headers = headers2;
          frame.statusCode = headers2[HTTP2_HEADER_STATUS];
          frame.status = frame.statusCode;
          _this2.emit("response", frame);
        });
        this._headerSent = true;
        frame.once("drain", function() {
          return _this2.emit("drain");
        });
        frame.on("error", function(err) {
          return _this2.emit("error", err);
        });
        frame.on("close", function() {
          return _this2.session.close();
        });
        this.frame = frame;
        return frame;
      };
      Request.prototype.mapToHttpHeader = function(headers) {
        var keys = Object.keys(headers);
        var http2Headers = {};
        for (var _i = 0, _keys = keys; _i < _keys.length; _i++) {
          var key = _keys[_i];
          var value = headers[key];
          key = key.toLowerCase();
          switch (key) {
            case HTTP2_HEADER_SET_COOKIE:
              value = Array.isArray(value) ? value : [value];
              break;
            default:
              break;
          }
          http2Headers[key] = value;
        }
        return http2Headers;
      };
      Request.prototype.mapToHttp2Header = function(headers) {
        var keys = Object.keys(headers);
        var http2Headers = {};
        for (var _i2 = 0, _keys2 = keys; _i2 < _keys2.length; _i2++) {
          var key = _keys2[_i2];
          var value = headers[key];
          key = key.toLowerCase();
          switch (key) {
            case HTTP2_HEADER_HOST:
              key = HTTP2_HEADER_AUTHORITY;
              value = /^http:\/\/|^https:\/\//.test(value) ? parse(value).host : value;
              break;
            default:
              break;
          }
          http2Headers[key] = value;
        }
        return http2Headers;
      };
      Request.prototype.setHeader = function(name, value) {
        this._headers[name.toLowerCase()] = value;
      };
      Request.prototype.getHeader = function(name) {
        return this._headers[name.toLowerCase()];
      };
      Request.prototype.write = function(data, encoding) {
        var frame = this.getFrame();
        return frame.write(data, encoding);
      };
      Request.prototype.pipe = function(stream, options) {
        var frame = this.getFrame();
        return frame.pipe(stream, options);
      };
      Request.prototype.end = function(data) {
        var frame = this.getFrame();
        frame.end(data);
      };
      Request.prototype.abort = function(data) {
        var frame = this.getFrame();
        frame.close(NGHTTP2_CANCEL);
        this.session.destroy();
      };
      exports2.setProtocol = setProtocol;
    }
  });

  // node_modules/superagent/lib/agent-base.js
  var require_agent_base = __commonJS({
    "node_modules/superagent/lib/agent-base.js"(exports2, module2) {
      "use strict";
      function _toConsumableArray(arr) {
        return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
      }
      function _nonIterableSpread() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function _unsupportedIterableToArray(o, minLen) {
        if (!o)
          return;
        if (typeof o === "string")
          return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor)
          n = o.constructor.name;
        if (n === "Map" || n === "Set")
          return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _arrayLikeToArray(o, minLen);
      }
      function _iterableToArray(iter) {
        if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
          return Array.from(iter);
      }
      function _arrayWithoutHoles(arr) {
        if (Array.isArray(arr))
          return _arrayLikeToArray(arr);
      }
      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length)
          len = arr.length;
        for (var i = 0, arr2 = new Array(len); i < len; i++) {
          arr2[i] = arr[i];
        }
        return arr2;
      }
      function Agent() {
        this._defaults = [];
      }
      ["use", "on", "once", "set", "query", "type", "accept", "auth", "withCredentials", "sortQuery", "retry", "ok", "redirects", "timeout", "buffer", "serialize", "parse", "ca", "key", "pfx", "cert", "disableTLSCerts"].forEach(function(fn) {
        Agent.prototype[fn] = function() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          this._defaults.push({
            fn,
            args
          });
          return this;
        };
      });
      Agent.prototype._setDefaults = function(req) {
        this._defaults.forEach(function(def) {
          req[def.fn].apply(req, _toConsumableArray(def.args));
        });
      };
      module2.exports = Agent;
    }
  });

  // node_modules/superagent/lib/node/agent.js
  var require_agent = __commonJS({
    "node_modules/superagent/lib/node/agent.js"(exports2, module2) {
      "use strict";
      var _require = __require("url");
      var parse = _require.parse;
      var _require2 = require_cookiejar();
      var CookieJar = _require2.CookieJar;
      var _require3 = require_cookiejar();
      var CookieAccessInfo = _require3.CookieAccessInfo;
      var methods = require_methods();
      var request2 = require_node2();
      var AgentBase = require_agent_base();
      module2.exports = Agent;
      function Agent(options) {
        if (!(this instanceof Agent)) {
          return new Agent(options);
        }
        AgentBase.call(this);
        this.jar = new CookieJar();
        if (options) {
          if (options.ca) {
            this.ca(options.ca);
          }
          if (options.key) {
            this.key(options.key);
          }
          if (options.pfx) {
            this.pfx(options.pfx);
          }
          if (options.cert) {
            this.cert(options.cert);
          }
          if (options.rejectUnauthorized === false) {
            this.disableTLSCerts();
          }
        }
      }
      Agent.prototype = Object.create(AgentBase.prototype);
      Agent.prototype._saveCookies = function(res) {
        var cookies = res.headers["set-cookie"];
        if (cookies)
          this.jar.setCookies(cookies);
      };
      Agent.prototype._attachCookies = function(req) {
        var url = parse(req.url);
        var access = new CookieAccessInfo(url.hostname, url.pathname, url.protocol === "https:");
        var cookies = this.jar.getCookies(access).toValueString();
        req.cookies = cookies;
      };
      methods.forEach(function(name) {
        var method2 = name.toUpperCase();
        Agent.prototype[name] = function(url, fn) {
          var req = new request2.Request(method2, url);
          req.on("response", this._saveCookies.bind(this));
          req.on("redirect", this._saveCookies.bind(this));
          req.on("redirect", this._attachCookies.bind(this, req));
          this._setDefaults(req);
          this._attachCookies(req);
          if (fn) {
            req.end(fn);
          }
          return req;
        };
      });
      Agent.prototype.del = Agent.prototype.delete;
    }
  });

  // node_modules/superagent/lib/node/parsers/urlencoded.js
  var require_urlencoded = __commonJS({
    "node_modules/superagent/lib/node/parsers/urlencoded.js"(exports2, module2) {
      "use strict";
      var qs = require_lib();
      module2.exports = function(res, fn) {
        res.text = "";
        res.setEncoding("ascii");
        res.on("data", function(chunk) {
          res.text += chunk;
        });
        res.on("end", function() {
          try {
            fn(null, qs.parse(res.text));
          } catch (err) {
            fn(err);
          }
        });
      };
    }
  });

  // node_modules/superagent/lib/node/parsers/json.js
  var require_json = __commonJS({
    "node_modules/superagent/lib/node/parsers/json.js"(exports2, module2) {
      "use strict";
      module2.exports = function(res, fn) {
        res.text = "";
        res.setEncoding("utf8");
        res.on("data", function(chunk) {
          res.text += chunk;
        });
        res.on("end", function() {
          var body;
          var err;
          try {
            body = res.text && JSON.parse(res.text);
          } catch (err_) {
            err = err_;
            err.rawResponse = res.text || null;
            err.statusCode = res.statusCode;
          } finally {
            fn(err, body);
          }
        });
      };
    }
  });

  // node_modules/superagent/lib/node/parsers/text.js
  var require_text = __commonJS({
    "node_modules/superagent/lib/node/parsers/text.js"(exports2, module2) {
      "use strict";
      module2.exports = function(res, fn) {
        res.text = "";
        res.setEncoding("utf8");
        res.on("data", function(chunk) {
          res.text += chunk;
        });
        res.on("end", fn);
      };
    }
  });

  // node_modules/superagent/lib/node/parsers/image.js
  var require_image = __commonJS({
    "node_modules/superagent/lib/node/parsers/image.js"(exports2, module2) {
      "use strict";
      module2.exports = function(res, fn) {
        var data = [];
        res.on("data", function(chunk) {
          data.push(chunk);
        });
        res.on("end", function() {
          fn(null, Buffer.concat(data));
        });
      };
    }
  });

  // node_modules/superagent/lib/node/parsers/index.js
  var require_parsers = __commonJS({
    "node_modules/superagent/lib/node/parsers/index.js"(exports2) {
      "use strict";
      exports2["application/x-www-form-urlencoded"] = require_urlencoded();
      exports2["application/json"] = require_json();
      exports2.text = require_text();
      var binary = require_image();
      exports2["application/octet-stream"] = binary;
      exports2["application/pdf"] = binary;
      exports2.image = binary;
    }
  });

  // node_modules/superagent/lib/node/index.js
  var require_node2 = __commonJS({
    "node_modules/superagent/lib/node/index.js"(exports2, module2) {
      "use strict";
      function _typeof(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof2(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof = function _typeof2(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof(obj);
      }
      var _require = __require("url");
      var parse = _require.parse;
      var format = _require.format;
      var resolve = _require.resolve;
      var Stream = __require("stream");
      var https = __require("https");
      var http = __require("http");
      var fs = __require("fs");
      var zlib = __require("zlib");
      var util = __require("util");
      var qs = require_lib();
      var mime = require_mime();
      var methods = require_methods();
      var FormData = require_form_data();
      var formidable = require_lib2();
      var debug = require_src2()("superagent");
      var CookieJar = require_cookiejar();
      var semver = require_semver2();
      var safeStringify = require_fast_safe_stringify();
      var utils = require_utils2();
      var RequestBase = require_request_base();
      var _require2 = require_unzip();
      var unzip = _require2.unzip;
      var Response = require_response();
      var http2;
      if (semver.gte(process.version, "v10.10.0"))
        http2 = require_http2wrapper();
      function request2(method2, url) {
        if (typeof url === "function") {
          return new exports2.Request("GET", method2).end(url);
        }
        if (arguments.length === 1) {
          return new exports2.Request("GET", method2);
        }
        return new exports2.Request(method2, url);
      }
      module2.exports = request2;
      exports2 = module2.exports;
      exports2.Request = Request;
      exports2.agent = require_agent();
      function noop() {
      }
      exports2.Response = Response;
      mime.define({
        "application/x-www-form-urlencoded": ["form", "urlencoded", "form-data"]
      }, true);
      exports2.protocols = {
        "http:": http,
        "https:": https,
        "http2:": http2
      };
      exports2.serialize = {
        "application/x-www-form-urlencoded": qs.stringify,
        "application/json": safeStringify
      };
      exports2.parse = require_parsers();
      exports2.buffer = {};
      function _initHeaders(req) {
        req._header = {};
        req.header = {};
      }
      function Request(method2, url) {
        Stream.call(this);
        if (typeof url !== "string")
          url = format(url);
        this._enableHttp2 = Boolean(process.env.HTTP2_TEST);
        this._agent = false;
        this._formData = null;
        this.method = method2;
        this.url = url;
        _initHeaders(this);
        this.writable = true;
        this._redirects = 0;
        this.redirects(method2 === "HEAD" ? 0 : 5);
        this.cookies = "";
        this.qs = {};
        this._query = [];
        this.qsRaw = this._query;
        this._redirectList = [];
        this._streamRequest = false;
        this.once("end", this.clearTimeout.bind(this));
      }
      util.inherits(Request, Stream);
      RequestBase(Request.prototype);
      Request.prototype.http2 = function(bool) {
        if (exports2.protocols["http2:"] === void 0) {
          throw new Error("superagent: this version of Node.js does not support http2");
        }
        this._enableHttp2 = bool === void 0 ? true : bool;
        return this;
      };
      Request.prototype.attach = function(field, file, options) {
        if (file) {
          if (this._data) {
            throw new Error("superagent can't mix .send() and .attach()");
          }
          var o = options || {};
          if (typeof options === "string") {
            o = {
              filename: options
            };
          }
          if (typeof file === "string") {
            if (!o.filename)
              o.filename = file;
            debug("creating `fs.ReadStream` instance for file: %s", file);
            file = fs.createReadStream(file);
          } else if (!o.filename && file.path) {
            o.filename = file.path;
          }
          this._getFormData().append(field, file, o);
        }
        return this;
      };
      Request.prototype._getFormData = function() {
        var _this = this;
        if (!this._formData) {
          this._formData = new FormData();
          this._formData.on("error", function(err) {
            debug("FormData error", err);
            if (_this.called) {
              return;
            }
            _this.callback(err);
            _this.abort();
          });
        }
        return this._formData;
      };
      Request.prototype.agent = function(agent) {
        if (arguments.length === 0)
          return this._agent;
        this._agent = agent;
        return this;
      };
      Request.prototype.type = function(type) {
        return this.set("Content-Type", type.includes("/") ? type : mime.getType(type));
      };
      Request.prototype.accept = function(type) {
        return this.set("Accept", type.includes("/") ? type : mime.getType(type));
      };
      Request.prototype.query = function(val) {
        if (typeof val === "string") {
          this._query.push(val);
        } else {
          Object.assign(this.qs, val);
        }
        return this;
      };
      Request.prototype.write = function(data, encoding) {
        var req = this.request();
        if (!this._streamRequest) {
          this._streamRequest = true;
        }
        return req.write(data, encoding);
      };
      Request.prototype.pipe = function(stream, options) {
        this.piped = true;
        this.buffer(false);
        this.end();
        return this._pipeContinue(stream, options);
      };
      Request.prototype._pipeContinue = function(stream, options) {
        var _this2 = this;
        this.req.once("response", function(res) {
          if (isRedirect(res.statusCode) && _this2._redirects++ !== _this2._maxRedirects) {
            return _this2._redirect(res) === _this2 ? _this2._pipeContinue(stream, options) : void 0;
          }
          _this2.res = res;
          _this2._emitResponse();
          if (_this2._aborted)
            return;
          if (_this2._shouldUnzip(res)) {
            var unzipObj = zlib.createUnzip();
            unzipObj.on("error", function(err) {
              if (err && err.code === "Z_BUF_ERROR") {
                stream.emit("end");
                return;
              }
              stream.emit("error", err);
            });
            res.pipe(unzipObj).pipe(stream, options);
          } else {
            res.pipe(stream, options);
          }
          res.once("end", function() {
            _this2.emit("end");
          });
        });
        return stream;
      };
      Request.prototype.buffer = function(val) {
        this._buffer = val !== false;
        return this;
      };
      Request.prototype._redirect = function(res) {
        var url = res.headers.location;
        if (!url) {
          return this.callback(new Error("No location header for redirect"), res);
        }
        debug("redirect %s -> %s", this.url, url);
        url = resolve(this.url, url);
        res.resume();
        var headers = this.req.getHeaders ? this.req.getHeaders() : this.req._headers;
        var changesOrigin = parse(url).host !== parse(this.url).host;
        if (res.statusCode === 301 || res.statusCode === 302) {
          headers = utils.cleanHeader(headers, changesOrigin);
          this.method = this.method === "HEAD" ? "HEAD" : "GET";
          this._data = null;
        }
        if (res.statusCode === 303) {
          headers = utils.cleanHeader(headers, changesOrigin);
          this.method = "GET";
          this._data = null;
        }
        delete headers.host;
        delete this.req;
        delete this._formData;
        _initHeaders(this);
        this._endCalled = false;
        this.url = url;
        this.qs = {};
        this._query.length = 0;
        this.set(headers);
        this.emit("redirect", res);
        this._redirectList.push(this.url);
        this.end(this._callback);
        return this;
      };
      Request.prototype.auth = function(user, pass, options) {
        if (arguments.length === 1)
          pass = "";
        if (_typeof(pass) === "object" && pass !== null) {
          options = pass;
          pass = "";
        }
        if (!options) {
          options = {
            type: "basic"
          };
        }
        var encoder = function encoder2(string) {
          return Buffer.from(string).toString("base64");
        };
        return this._auth(user, pass, options, encoder);
      };
      Request.prototype.ca = function(cert) {
        this._ca = cert;
        return this;
      };
      Request.prototype.key = function(cert) {
        this._key = cert;
        return this;
      };
      Request.prototype.pfx = function(cert) {
        if (_typeof(cert) === "object" && !Buffer.isBuffer(cert)) {
          this._pfx = cert.pfx;
          this._passphrase = cert.passphrase;
        } else {
          this._pfx = cert;
        }
        return this;
      };
      Request.prototype.cert = function(cert) {
        this._cert = cert;
        return this;
      };
      Request.prototype.disableTLSCerts = function() {
        this._disableTLSCerts = true;
        return this;
      };
      Request.prototype.request = function() {
        var _this3 = this;
        if (this.req)
          return this.req;
        var options = {};
        try {
          var query = qs.stringify(this.qs, {
            indices: false,
            strictNullHandling: true
          });
          if (query) {
            this.qs = {};
            this._query.push(query);
          }
          this._finalizeQueryString();
        } catch (err) {
          return this.emit("error", err);
        }
        var url = this.url;
        var retries = this._retries;
        var queryStringBackticks;
        if (url.includes("`")) {
          var queryStartIndex = url.indexOf("?");
          if (queryStartIndex !== -1) {
            var queryString = url.slice(queryStartIndex + 1);
            queryStringBackticks = queryString.match(/`|%60/g);
          }
        }
        if (url.indexOf("http") !== 0)
          url = "http://".concat(url);
        url = parse(url);
        if (queryStringBackticks) {
          var i = 0;
          url.query = url.query.replace(/%60/g, function() {
            return queryStringBackticks[i++];
          });
          url.search = "?".concat(url.query);
          url.path = url.pathname + url.search;
        }
        if (/^https?\+unix:/.test(url.protocol) === true) {
          url.protocol = "".concat(url.protocol.split("+")[0], ":");
          var unixParts = url.path.match(/^([^/]+)(.+)$/);
          options.socketPath = unixParts[1].replace(/%2F/g, "/");
          url.path = unixParts[2];
        }
        if (this._connectOverride) {
          var _url = url, hostname = _url.hostname;
          var match = hostname in this._connectOverride ? this._connectOverride[hostname] : this._connectOverride["*"];
          if (match) {
            if (!this._header.host) {
              this.set("host", url.host);
            }
            var newHost;
            var newPort;
            if (_typeof(match) === "object") {
              newHost = match.host;
              newPort = match.port;
            } else {
              newHost = match;
              newPort = url.port;
            }
            url.host = /:/.test(newHost) ? "[".concat(newHost, "]") : newHost;
            if (newPort) {
              url.host += ":".concat(newPort);
              url.port = newPort;
            }
            url.hostname = newHost;
          }
        }
        options.method = this.method;
        options.port = url.port;
        options.path = url.path;
        options.host = url.hostname;
        options.ca = this._ca;
        options.key = this._key;
        options.pfx = this._pfx;
        options.cert = this._cert;
        options.passphrase = this._passphrase;
        options.agent = this._agent;
        options.rejectUnauthorized = typeof this._disableTLSCerts === "boolean" ? !this._disableTLSCerts : process.env.NODE_TLS_REJECT_UNAUTHORIZED !== "0";
        if (this._header.host) {
          options.servername = this._header.host.replace(/:\d+$/, "");
        }
        if (this._trustLocalhost && /^(?:localhost|127\.0\.0\.\d+|(0*:)+:0*1)$/.test(url.hostname)) {
          options.rejectUnauthorized = false;
        }
        var mod = this._enableHttp2 ? exports2.protocols["http2:"].setProtocol(url.protocol) : exports2.protocols[url.protocol];
        this.req = mod.request(options);
        var req = this.req;
        req.setNoDelay(true);
        if (options.method !== "HEAD") {
          req.setHeader("Accept-Encoding", "gzip, deflate");
        }
        this.protocol = url.protocol;
        this.host = url.host;
        req.once("drain", function() {
          _this3.emit("drain");
        });
        req.on("error", function(err) {
          if (_this3._aborted)
            return;
          if (_this3._retries !== retries)
            return;
          if (_this3.response)
            return;
          _this3.callback(err);
        });
        if (url.auth) {
          var auth = url.auth.split(":");
          this.auth(auth[0], auth[1]);
        }
        if (this.username && this.password) {
          this.auth(this.username, this.password);
        }
        for (var key in this.header) {
          if (Object.prototype.hasOwnProperty.call(this.header, key))
            req.setHeader(key, this.header[key]);
        }
        if (this.cookies) {
          if (Object.prototype.hasOwnProperty.call(this._header, "cookie")) {
            var tmpJar = new CookieJar.CookieJar();
            tmpJar.setCookies(this._header.cookie.split(";"));
            tmpJar.setCookies(this.cookies.split(";"));
            req.setHeader("Cookie", tmpJar.getCookies(CookieJar.CookieAccessInfo.All).toValueString());
          } else {
            req.setHeader("Cookie", this.cookies);
          }
        }
        return req;
      };
      Request.prototype.callback = function(err, res) {
        if (this._shouldRetry(err, res)) {
          return this._retry();
        }
        var fn = this._callback || noop;
        this.clearTimeout();
        if (this.called)
          return console.warn("superagent: double callback bug");
        this.called = true;
        if (!err) {
          try {
            if (!this._isResponseOK(res)) {
              var msg = "Unsuccessful HTTP response";
              if (res) {
                msg = http.STATUS_CODES[res.status] || msg;
              }
              err = new Error(msg);
              err.status = res ? res.status : void 0;
            }
          } catch (err_) {
            err = err_;
          }
        }
        if (!err) {
          return fn(null, res);
        }
        err.response = res;
        if (this._maxRetries)
          err.retries = this._retries - 1;
        if (err && this.listeners("error").length > 0) {
          this.emit("error", err);
        }
        fn(err, res);
      };
      Request.prototype._isHost = function(obj) {
        return Buffer.isBuffer(obj) || obj instanceof Stream || obj instanceof FormData;
      };
      Request.prototype._emitResponse = function(body, files) {
        var response = new Response(this);
        this.response = response;
        response.redirects = this._redirectList;
        if (body !== void 0) {
          response.body = body;
        }
        response.files = files;
        if (this._endCalled) {
          response.pipe = function() {
            throw new Error("end() has already been called, so it's too late to start piping");
          };
        }
        this.emit("response", response);
        return response;
      };
      Request.prototype.end = function(fn) {
        this.request();
        debug("%s %s", this.method, this.url);
        if (this._endCalled) {
          throw new Error(".end() was called twice. This is not supported in superagent");
        }
        this._endCalled = true;
        this._callback = fn || noop;
        this._end();
      };
      Request.prototype._end = function() {
        var _this4 = this;
        if (this._aborted)
          return this.callback(new Error("The request has been aborted even before .end() was called"));
        var data = this._data;
        var req = this.req;
        var method2 = this.method;
        this._setTimeouts();
        if (method2 !== "HEAD" && !req._headerSent) {
          if (typeof data !== "string") {
            var contentType = req.getHeader("Content-Type");
            if (contentType)
              contentType = contentType.split(";")[0];
            var serialize = this._serializer || exports2.serialize[contentType];
            if (!serialize && isJSON(contentType)) {
              serialize = exports2.serialize["application/json"];
            }
            if (serialize)
              data = serialize(data);
          }
          if (data && !req.getHeader("Content-Length")) {
            req.setHeader("Content-Length", Buffer.isBuffer(data) ? data.length : Buffer.byteLength(data));
          }
        }
        req.once("response", function(res) {
          debug("%s %s -> %s", _this4.method, _this4.url, res.statusCode);
          if (_this4._responseTimeoutTimer) {
            clearTimeout(_this4._responseTimeoutTimer);
          }
          if (_this4.piped) {
            return;
          }
          var max = _this4._maxRedirects;
          var mime2 = utils.type(res.headers["content-type"] || "") || "text/plain";
          var type = mime2.split("/")[0];
          if (type)
            type = type.toLowerCase().trim();
          var multipart = type === "multipart";
          var redirect = isRedirect(res.statusCode);
          var responseType = _this4._responseType;
          _this4.res = res;
          if (redirect && _this4._redirects++ !== max) {
            return _this4._redirect(res);
          }
          if (_this4.method === "HEAD") {
            _this4.emit("end");
            _this4.callback(null, _this4._emitResponse());
            return;
          }
          if (_this4._shouldUnzip(res)) {
            unzip(req, res);
          }
          var buffer = _this4._buffer;
          if (buffer === void 0 && mime2 in exports2.buffer) {
            buffer = Boolean(exports2.buffer[mime2]);
          }
          var parser = _this4._parser;
          if (buffer === void 0) {
            if (parser) {
              console.warn("A custom superagent parser has been set, but buffering strategy for the parser hasn't been configured. Call `req.buffer(true or false)` or set `superagent.buffer[mime] = true or false`");
              buffer = true;
            }
          }
          if (!parser) {
            if (responseType) {
              parser = exports2.parse.image;
              buffer = true;
            } else if (multipart) {
              var form = new formidable.IncomingForm();
              parser = form.parse.bind(form);
              buffer = true;
            } else if (isImageOrVideo(mime2)) {
              parser = exports2.parse.image;
              buffer = true;
            } else if (exports2.parse[mime2]) {
              parser = exports2.parse[mime2];
            } else if (type === "text") {
              parser = exports2.parse.text;
              buffer = buffer !== false;
            } else if (isJSON(mime2)) {
              parser = exports2.parse["application/json"];
              buffer = buffer !== false;
            } else if (buffer) {
              parser = exports2.parse.text;
            } else if (buffer === void 0) {
              parser = exports2.parse.image;
              buffer = true;
            }
          }
          if (buffer === void 0 && isText(mime2) || isJSON(mime2)) {
            buffer = true;
          }
          _this4._resBuffered = buffer;
          var parserHandlesEnd = false;
          if (buffer) {
            var responseBytesLeft = _this4._maxResponseSize || 2e8;
            res.on("data", function(buf) {
              responseBytesLeft -= buf.byteLength || buf.length;
              if (responseBytesLeft < 0) {
                var err = new Error("Maximum response size reached");
                err.code = "ETOOLARGE";
                parserHandlesEnd = false;
                res.destroy(err);
              }
            });
          }
          if (parser) {
            try {
              parserHandlesEnd = buffer;
              parser(res, function(err, obj, files) {
                if (_this4.timedout) {
                  return;
                }
                if (err && !_this4._aborted) {
                  return _this4.callback(err);
                }
                if (parserHandlesEnd) {
                  _this4.emit("end");
                  _this4.callback(null, _this4._emitResponse(obj, files));
                }
              });
            } catch (err) {
              _this4.callback(err);
              return;
            }
          }
          _this4.res = res;
          if (!buffer) {
            debug("unbuffered %s %s", _this4.method, _this4.url);
            _this4.callback(null, _this4._emitResponse());
            if (multipart)
              return;
            res.once("end", function() {
              debug("end %s %s", _this4.method, _this4.url);
              _this4.emit("end");
            });
            return;
          }
          res.once("error", function(err) {
            parserHandlesEnd = false;
            _this4.callback(err, null);
          });
          if (!parserHandlesEnd)
            res.once("end", function() {
              debug("end %s %s", _this4.method, _this4.url);
              _this4.emit("end");
              _this4.callback(null, _this4._emitResponse());
            });
        });
        this.emit("request", this);
        var getProgressMonitor = function getProgressMonitor2() {
          var lengthComputable = true;
          var total = req.getHeader("Content-Length");
          var loaded = 0;
          var progress = new Stream.Transform();
          progress._transform = function(chunk, encoding, cb) {
            loaded += chunk.length;
            _this4.emit("progress", {
              direction: "upload",
              lengthComputable,
              loaded,
              total
            });
            cb(null, chunk);
          };
          return progress;
        };
        var bufferToChunks = function bufferToChunks2(buffer) {
          var chunkSize = 16 * 1024;
          var chunking = new Stream.Readable();
          var totalLength = buffer.length;
          var remainder = totalLength % chunkSize;
          var cutoff = totalLength - remainder;
          for (var i2 = 0; i2 < cutoff; i2 += chunkSize) {
            var chunk = buffer.slice(i2, i2 + chunkSize);
            chunking.push(chunk);
          }
          if (remainder > 0) {
            var remainderBuffer = buffer.slice(-remainder);
            chunking.push(remainderBuffer);
          }
          chunking.push(null);
          return chunking;
        };
        var formData = this._formData;
        if (formData) {
          var headers = formData.getHeaders();
          for (var i in headers) {
            if (Object.prototype.hasOwnProperty.call(headers, i)) {
              debug('setting FormData header: "%s: %s"', i, headers[i]);
              req.setHeader(i, headers[i]);
            }
          }
          formData.getLength(function(err, length) {
            if (err)
              debug("formData.getLength had error", err, length);
            debug("got FormData Content-Length: %s", length);
            if (typeof length === "number") {
              req.setHeader("Content-Length", length);
            }
            formData.pipe(getProgressMonitor()).pipe(req);
          });
        } else if (Buffer.isBuffer(data)) {
          bufferToChunks(data).pipe(getProgressMonitor()).pipe(req);
        } else {
          req.end(data);
        }
      };
      Request.prototype._shouldUnzip = function(res) {
        if (res.statusCode === 204 || res.statusCode === 304) {
          return false;
        }
        if (res.headers["content-length"] === "0") {
          return false;
        }
        return /^\s*(?:deflate|gzip)\s*$/.test(res.headers["content-encoding"]);
      };
      Request.prototype.connect = function(connectOverride) {
        if (typeof connectOverride === "string") {
          this._connectOverride = {
            "*": connectOverride
          };
        } else if (_typeof(connectOverride) === "object") {
          this._connectOverride = connectOverride;
        } else {
          this._connectOverride = void 0;
        }
        return this;
      };
      Request.prototype.trustLocalhost = function(toggle) {
        this._trustLocalhost = toggle === void 0 ? true : toggle;
        return this;
      };
      if (!methods.includes("del")) {
        methods = methods.slice(0);
        methods.push("del");
      }
      methods.forEach(function(method2) {
        var name = method2;
        method2 = method2 === "del" ? "delete" : method2;
        method2 = method2.toUpperCase();
        request2[name] = function(url, data, fn) {
          var req = request2(method2, url);
          if (typeof data === "function") {
            fn = data;
            data = null;
          }
          if (data) {
            if (method2 === "GET" || method2 === "HEAD") {
              req.query(data);
            } else {
              req.send(data);
            }
          }
          if (fn)
            req.end(fn);
          return req;
        };
      });
      function isText(mime2) {
        var parts = mime2.split("/");
        var type = parts[0];
        if (type)
          type = type.toLowerCase().trim();
        var subtype = parts[1];
        if (subtype)
          subtype = subtype.toLowerCase().trim();
        return type === "text" || subtype === "x-www-form-urlencoded";
      }
      function isImageOrVideo(mime2) {
        var type = mime2.split("/")[0];
        if (type)
          type = type.toLowerCase().trim();
        return type === "image" || type === "video";
      }
      function isJSON(mime2) {
        return /[/+]json($|[^-\w])/i.test(mime2);
      }
      function isRedirect(code) {
        return [301, 302, 303, 305, 307, 308].includes(code);
      }
    }
  });

  // node_modules/algosdk/dist/esm/src/client/urlTokenBaseHTTPClient.js
  var import_url_parse, import_path, request, URLTokenBaseHTTPClient;
  var init_urlTokenBaseHTTPClient = __esm({
    "node_modules/algosdk/dist/esm/src/client/urlTokenBaseHTTPClient.js"() {
      import_url_parse = __toESM(require_url_parse());
      import_path = __toESM(__require("path"));
      request = __toESM(require_node2());
      URLTokenBaseHTTPClient = class {
        constructor(tokenHeader, baseServer, port, defaultHeaders = {}) {
          this.defaultHeaders = defaultHeaders;
          const baseServerURL = new import_url_parse.default(baseServer, {});
          if (typeof port !== "undefined") {
            baseServerURL.set("port", port.toString());
          }
          if (baseServerURL.protocol.length === 0) {
            throw new Error("Invalid base server URL, protocol must be defined.");
          }
          this.baseURL = baseServerURL;
          this.tokenHeader = tokenHeader;
        }
        addressWithPath(relativePath) {
          const address = new import_url_parse.default(import_path.default.posix.join(this.baseURL.pathname, relativePath), this.baseURL);
          return address.toString();
        }
        static superagentToHTTPClientResponse(res) {
          if (res.body instanceof ArrayBuffer) {
            res.body = new Uint8Array(res.body);
          }
          return res;
        }
        static formatSuperagentError(err) {
          if (err.response) {
            try {
              const decoded = JSON.parse(Buffer.from(err.response.body).toString());
              err.message = `Network request error. Received status ${err.response.status}: ${decoded.message}`;
            } catch (err2) {
            }
          }
          return err;
        }
        async get(relativePath, query, requestHeaders = {}) {
          const r = request.get(this.addressWithPath(relativePath)).set(this.tokenHeader).set(this.defaultHeaders).set(requestHeaders).responseType("arraybuffer").query(query);
          try {
            const res = await r;
            return URLTokenBaseHTTPClient.superagentToHTTPClientResponse(res);
          } catch (err) {
            throw URLTokenBaseHTTPClient.formatSuperagentError(err);
          }
        }
        async post(relativePath, data, query, requestHeaders = {}) {
          const r = request.post(this.addressWithPath(relativePath)).set(this.tokenHeader).set(this.defaultHeaders).set(requestHeaders).query(query).serialize((o) => o).responseType("arraybuffer").send(Buffer.from(data));
          try {
            const res = await r;
            return URLTokenBaseHTTPClient.superagentToHTTPClientResponse(res);
          } catch (err) {
            throw URLTokenBaseHTTPClient.formatSuperagentError(err);
          }
        }
        async delete(relativePath, data, query, requestHeaders = {}) {
          const r = request.delete(this.addressWithPath(relativePath)).set(this.tokenHeader).set(this.defaultHeaders).set(requestHeaders).query(query).serialize((o) => o).responseType("arraybuffer").send(Buffer.from(data));
          try {
            const res = await r;
            return URLTokenBaseHTTPClient.superagentToHTTPClientResponse(res);
          } catch (err) {
            throw URLTokenBaseHTTPClient.formatSuperagentError(err);
          }
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/src/client/client.js
  var client_exports = {};
  __export(client_exports, {
    default: () => HTTPClient
  });
  function removeFalsyOrEmpty(obj) {
    for (const key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        if (!obj[key] || obj[key].length === 0)
          delete obj[key];
      }
    }
    return obj;
  }
  function tolowerCaseKeys(o) {
    return Object.keys(o).reduce((c, k) => (c[k.toLowerCase()] = o[k], c), {});
  }
  function getAcceptFormat(query) {
    if (query !== void 0 && Object.prototype.hasOwnProperty.call(query, "format")) {
      switch (query.format) {
        case "msgpack":
          return "application/msgpack";
        case "json":
        default:
          return "application/json";
      }
    } else
      return "application/json";
  }
  function isResponseJSON(res) {
    let contentType = tolowerCaseKeys(res.headers)["content-type"];
    if (contentType) {
      contentType = contentType.split(";")[0];
    }
    return /[/+]json($|[^-\w])/i.test(contentType);
  }
  function isResponseText(res) {
    const contentType = tolowerCaseKeys(res.headers)["content-type"] || "text/plain";
    return /^\w*text\//i.test(contentType);
  }
  var HTTPClient;
  var init_client = __esm({
    "node_modules/algosdk/dist/esm/src/client/client.js"() {
      init_utils();
      init_urlTokenBaseHTTPClient();
      HTTPClient = class {
        constructor(bcOrTokenHeader, baseServer, port, defaultHeaders = {}) {
          if (baseServer !== void 0) {
            this.bc = new URLTokenBaseHTTPClient(bcOrTokenHeader, baseServer, port, defaultHeaders);
          } else {
            this.bc = bcOrTokenHeader;
          }
        }
        static parseJSON(text, status, jsonOptions = {}) {
          try {
            if (Object.keys(jsonOptions).length === 0) {
              return text && JSON.parse(text);
            }
            return text && parseJSON(text, jsonOptions);
          } catch (err_) {
            const err = err_;
            err.rawResponse = text || null;
            err.statusCode = status;
            throw err;
          }
        }
        static serializeData(data, requestHeaders) {
          if (!data) {
            return new Uint8Array(0);
          }
          if (requestHeaders["content-type"] === "application/json") {
            return new Uint8Array(Buffer.from(JSON.stringify(data)));
          }
          if (typeof data === "string") {
            return new Uint8Array(Buffer.from(data));
          }
          if (data instanceof Uint8Array) {
            return data;
          }
          throw new Error("provided data is neither a string nor a Uint8Array and content-type is not application/json");
        }
        static prepareResponse(res, jsonOptions = {}) {
          let { body } = res;
          let text;
          if (isResponseJSON(res)) {
            text = body && new TextDecoder().decode(body) || "";
            body = HTTPClient.parseJSON(text, res.status, jsonOptions);
          } else if (isResponseText(res)) {
            text = body && new TextDecoder().decode(body) || "";
          }
          return __spreadProps(__spreadValues({}, res), {
            body,
            text,
            ok: Math.trunc(res.status / 100) === 2
          });
        }
        static prepareResponseError(err) {
          if (err.response) {
            err.response = HTTPClient.prepareResponse(err.response);
            err.status = err.response.status;
          }
          return err;
        }
        async get(relativePath, query, requestHeaders = {}, jsonOptions = {}) {
          const format = getAcceptFormat(query);
          const fullHeaders = __spreadProps(__spreadValues({}, requestHeaders), { accept: format });
          try {
            const res = await this.bc.get(relativePath, removeFalsyOrEmpty(query), fullHeaders);
            return HTTPClient.prepareResponse(res, jsonOptions);
          } catch (err) {
            throw HTTPClient.prepareResponseError(err);
          }
        }
        async post(relativePath, data, requestHeaders = {}) {
          const fullHeaders = __spreadValues({
            "content-type": "application/json"
          }, tolowerCaseKeys(requestHeaders));
          try {
            const res = await this.bc.post(relativePath, HTTPClient.serializeData(data, fullHeaders), void 0, fullHeaders);
            return HTTPClient.prepareResponse(res);
          } catch (err) {
            throw HTTPClient.prepareResponseError(err);
          }
        }
        async delete(relativePath, data, requestHeaders = {}) {
          const fullHeaders = __spreadValues({
            "content-type": "application/json"
          }, tolowerCaseKeys(requestHeaders));
          const res = await this.bc.delete(relativePath, HTTPClient.serializeData(data, fullHeaders), void 0, fullHeaders);
          return HTTPClient.prepareResponse(res);
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/src/client/v2/jsonrequest.js
  var JSONRequest;
  var init_jsonrequest = __esm({
    "node_modules/algosdk/dist/esm/src/client/v2/jsonrequest.js"() {
      init_intDecoding();
      JSONRequest = class {
        constructor(client, intDecoding) {
          this.c = client;
          this.query = {};
          this.intDecoding = intDecoding || intDecoding_default.DEFAULT;
        }
        prepare(body) {
          return body;
        }
        async do(headers = {}) {
          const jsonOptions = {};
          if (this.intDecoding !== "default") {
            jsonOptions.intDecoding = this.intDecoding;
          }
          const res = await this.c.get(this.path(), this.query, headers, jsonOptions);
          return this.prepare(res.body);
        }
        setIntDecoding(method2) {
          if (method2 !== "default" && method2 !== "safe" && method2 !== "mixed" && method2 !== "bigint")
            throw new Error(`Invalid method for int decoding: ${method2}`);
          this.intDecoding = method2;
          return this;
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/src/client/v2/algod/sendRawTransaction.js
  var sendRawTransaction_exports = {};
  __export(sendRawTransaction_exports, {
    default: () => SendRawTransaction,
    setSendTransactionHeaders: () => setSendTransactionHeaders
  });
  function setSendTransactionHeaders(headers = {}) {
    let hdrs = headers;
    if (Object.keys(hdrs).every((key) => key.toLowerCase() !== "content-type")) {
      hdrs = __spreadValues({}, headers);
      hdrs["Content-Type"] = "application/x-binary";
    }
    return hdrs;
  }
  function isByteArray(array) {
    return array && array.byteLength !== void 0;
  }
  var SendRawTransaction;
  var init_sendRawTransaction = __esm({
    "node_modules/algosdk/dist/esm/src/client/v2/algod/sendRawTransaction.js"() {
      init_jsonrequest();
      init_utils();
      SendRawTransaction = class extends JSONRequest {
        constructor(c, stxOrStxs) {
          super(c);
          let forPosting = stxOrStxs;
          if (Array.isArray(stxOrStxs)) {
            if (!stxOrStxs.every(isByteArray)) {
              throw new TypeError("Array elements must be byte arrays");
            }
            forPosting = concatArrays(...stxOrStxs);
          } else if (!isByteArray(forPosting)) {
            throw new TypeError("Argument must be byte array");
          }
          this.txnBytesToPost = forPosting;
        }
        path() {
          return "/v2/transactions";
        }
        async do(headers = {}) {
          const txHeaders = setSendTransactionHeaders(headers);
          const res = await this.c.post(this.path(), Buffer.from(this.txnBytesToPost), txHeaders);
          return res.body;
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/src/client/algod.js
  var require_algod = __commonJS({
    "node_modules/algosdk/dist/esm/src/client/algod.js"(exports2, module2) {
      var { default: HTTPClient2 } = (init_client(), __toCommonJS(client_exports));
      var { setSendTransactionHeaders: setSendTransactionHeaders2 } = (init_sendRawTransaction(), __toCommonJS(sendRawTransaction_exports));
      function Algod(token = "", baseServer = "http://r2.algorand.network", port = 4180, headers = {}) {
        let tokenHeader = token;
        if (typeof tokenHeader === "string") {
          tokenHeader = { "X-Algo-API-Token": tokenHeader };
        }
        const c = new HTTPClient2(tokenHeader, baseServer, port, headers);
        function noteb64ToNote(o) {
          if (!(o.noteb64 === void 0 || o.noteb64 === null)) {
            o.note = Buffer.from(o.noteb64, "base64");
          }
          return o;
        }
        this.status = async (headerObj = {}) => {
          const res = await c.get("/v1/status", {}, headerObj);
          return res.body;
        };
        this.healthCheck = async (headerObj = {}) => {
          const res = await c.get("/health", {}, headerObj);
          if (!res.ok) {
            throw new Error(`Health response: ${res.status}`);
          }
          return {};
        };
        this.statusAfterBlock = async (roundNumber, headerObj = {}) => {
          if (!Number.isInteger(roundNumber))
            throw Error("roundNumber should be an integer");
          const res = await c.get(`/v1/status/wait-for-block-after/${roundNumber}`, {}, headerObj);
          return res.body;
        };
        this.pendingTransactions = async (maxTxns, headerObj = {}) => {
          if (!Number.isInteger(maxTxns))
            throw Error("maxTxns should be an integer");
          const res = await c.get("/v1/transactions/pending", { max: maxTxns }, headerObj);
          if (res.statusCode === 200 && res.body.truncatedTxns.transactions !== void 0) {
            for (let i = 0; i < res.body.truncatedTxns.transactions.length; i++) {
              res.body.truncatedTxns.transactions[i] = noteb64ToNote(res.body.truncatedTxns.transactions[i]);
            }
          }
          return res.body;
        };
        this.versions = async (headerObj = {}) => {
          const res = await c.get("/versions", {}, headerObj);
          return res.body;
        };
        this.ledgerSupply = async (headerObj = {}) => {
          const res = await c.get("/v1/ledger/supply", {}, headerObj);
          return res.body;
        };
        this.transactionByAddress = async (addr, first = null, last = null, maxTxns = null, headerObj = {}) => {
          if (first !== null && !Number.isInteger(first)) {
            throw Error("first round should be an integer");
          }
          if (last !== null && !Number.isInteger(last)) {
            throw Error("last round should be an integer");
          }
          const res = await c.get(`/v1/account/${addr}/transactions`, { firstRound: first, lastRound: last, max: maxTxns }, headerObj);
          if (res.statusCode === 200 && res.body.transactions !== void 0) {
            for (let i = 0; i < res.body.transactions.length; i++) {
              res.body.transactions[i] = noteb64ToNote(res.body.transactions[i]);
            }
          }
          return res.body;
        };
        this.transactionByAddressAndDate = async (addr, fromDate, toDate, maxTxns = null, headerObj = {}) => {
          const res = await c.get(`/v1/account/${addr}/transactions`, { fromDate, toDate, max: maxTxns }, headerObj);
          if (res.statusCode === 200 && res.body.transactions !== void 0) {
            for (let i = 0; i < res.body.transactions.length; i++) {
              res.body.transactions[i] = noteb64ToNote(res.body.transactions[i]);
            }
          }
          return res.body;
        };
        this.transactionById = async (txid, headerObj = {}) => {
          const res = await c.get(`/v1/transaction/${txid}`, {}, headerObj);
          if (res.statusCode === 200) {
            res.body = noteb64ToNote(res.body);
          }
          return res.body;
        };
        this.transactionInformation = async (addr, txid, headerObj = {}) => {
          const res = await c.get(`/v1/account/${addr}/transaction/${txid}`, {}, headerObj);
          if (res.statusCode === 200) {
            res.body = noteb64ToNote(res.body);
          }
          return res.body;
        };
        this.pendingTransactionInformation = async (txid, headerObj = {}) => {
          const res = await c.get(`/v1/transactions/pending/${txid}`, {}, headerObj);
          if (res.statusCode === 200) {
            res.body = noteb64ToNote(res.body);
          }
          return res.body;
        };
        this.accountInformation = async (addr, headerObj = {}) => {
          const res = await c.get(`/v1/account/${addr}`, {}, headerObj);
          return res.body;
        };
        this.assetInformation = async (index, headerObj = {}) => {
          const res = await c.get(`/v1/asset/${index}`, {}, headerObj);
          return res.body;
        };
        this.suggestedFee = async (headerObj = {}) => {
          const res = await c.get("/v1/transactions/fee", {}, headerObj);
          return res.body;
        };
        this.sendRawTransaction = async (txn, headerObj = {}) => {
          const txHeaders = setSendTransactionHeaders2(headerObj);
          const res = await c.post("/v1/transactions", Buffer.from(txn), txHeaders);
          return res.body;
        };
        this.sendRawTransactions = async (txns, headerObj = {}) => {
          const txHeaders = setSendTransactionHeaders2(headerObj);
          const merged = Array.prototype.concat(...txns.map((arr) => Array.from(arr)));
          const res = await c.post("/v1/transactions", Buffer.from(merged), txHeaders);
          return res.body;
        };
        this.getTransactionParams = async (headerObj = {}) => {
          const res = await c.get("/v1/transactions/params", {}, headerObj);
          return res.body;
        };
        this.suggestParams = async (headerObj = {}) => {
          const result = await this.getTransactionParams(headerObj);
          return {
            flatFee: false,
            fee: result.fee,
            firstRound: result.lastRound,
            lastRound: result.lastRound + 1e3,
            genesisID: result.genesisID,
            genesisHash: result.genesishashb64
          };
        };
        this.block = async (roundNumber, headerObj = {}) => {
          if (!Number.isInteger(roundNumber))
            throw Error("roundNumber should be an integer");
          const res = await c.get(`/v1/block/${roundNumber}`, {}, headerObj);
          if (res.statusCode === 200 && res.body.txns.transactions !== void 0) {
            for (let i = 0; i < res.body.txns.transactions.length; i++) {
              res.body.txns.transactions[i] = noteb64ToNote(res.body.txns.transactions[i]);
            }
          }
          return res.body;
        };
      }
      module2.exports = { Algod };
    }
  });

  // src/constants.js
  var require_constants2 = __commonJS({
    "src/constants.js"(exports2) {
      "use strict";
      exports2.__esModule = true;
      exports2.APP_ID = 628095415;
      exports2.REGISTRATION_PRICE = {
        CHAR_3_AMOUNT: 15e7,
        CHAR_4_AMOUNT: 5e7,
        CHAR_5_AMOUNT: 5e6
      };
      exports2.TRANSFER_FEE = 2e6;
      exports2.IPFS_LINK = "https://ipfs.infura.io/ipfs/";
      exports2.ASCII_CODES = {
        ASCII_A: 97,
        ASCII_Z: 122,
        ASCII_0: 48,
        ASCII_9: 57
      };
      exports2.ALLOWED_SOCIALS = [
        "github",
        "twitter",
        "telegram",
        "youtube",
        "reddit",
        "discord"
      ];
      exports2.ALLOWED_TLDS = ["algo"];
    }
  });

  // src/generateTeal.js
  var require_generateTeal = __commonJS({
    "src/generateTeal.js"(exports2) {
      "use strict";
      exports2.__esModule = true;
      function generateTeal2(name) {
        return '#pragma version 4\n    byte "' + name + '"\n    len\n    int 3\n    ==\n    bnz main_l22\n    byte "' + name + '"\n    len\n    int 4\n    ==\n    bnz main_l13\n    byte "' + name + '"\n    len\n    int 5\n    >=\n    bnz main_l4\n    err\n    main_l4:\n    gtxn 0 Amount\n    int 5000000\n    >=\n    assert\n    byte "' + name + '"\n    len\n    int 64\n    <=\n    assert\n    int 0\n    store 0\n    main_l5:\n    load 0\n    byte "' + name + '"\n    len\n    <\n    bnz main_l12\n    global GroupSize\n    int 2\n    ==\n    global GroupSize\n    int 4\n    ==\n    ||\n    assert\n    gtxn 0 Sender\n    gtxn 1 Sender\n    ==\n    assert\n    gtxn 0 Receiver\n    addr SYGCDTWGBXKV4ZL5YAWSYAVOUC25U2XDB6SMQHLRCTYVF566TQZ3EOABH4\n    ==\n    assert\n    global GroupSize\n    int 2\n    ==\n    bnz main_l11\n    global GroupSize\n    int 4\n    ==\n    bnz main_l10\n    int 0\n    return\n    main_l9:\n    int 1\n    assert\n    int 1\n    b main_l31\n    main_l10:\n    gtxn 1 Receiver\n    gtxn 2 Sender\n    ==\n    gtxn 2 ApplicationID\n    int 628095415\n    ==\n    &&\n    gtxn 2 OnCompletion\n    int OptIn\n    ==\n    &&\n    gtxn 3 ApplicationID\n    int 628095415\n    ==\n    &&\n    gtxn 3 Sender\n    gtxn 0 Sender\n    ==\n    &&\n    gtxna 3 ApplicationArgs 0\n    byte "register_name"\n    ==\n    &&\n    gtxna 3 ApplicationArgs 1\n    byte "' + name + '"\n    ==\n    &&\n    assert\n    b main_l9\n    main_l11:\n    gtxn 1 ApplicationID\n    int 628095415\n    ==\n    gtxna 1 ApplicationArgs 0\n    byte "register_name"\n    ==\n    &&\n    gtxna 1 ApplicationArgs 1\n    byte "' + name + '"\n    ==\n    &&\n    assert\n    b main_l9\n    main_l12:\n    byte "' + name + '"\n    load 0\n    getbyte\n    int 97\n    >=\n    byte "' + name + '"\n    load 0\n    getbyte\n    int 122\n    <=\n    &&\n    byte "' + name + '"\n    load 0\n    getbyte\n    int 48\n    >=\n    byte "' + name + '"\n    load 0\n    getbyte\n    int 57\n    <=\n    &&\n    ||\n    assert\n    load 0\n    int 1\n    +\n    store 0\n    b main_l5\n    main_l13:\n    gtxn 0 Amount\n    int 50000000\n    >=\n    assert\n    byte "' + name + '"\n    len\n    int 64\n    <=\n    assert\n    int 0\n    store 0\n    main_l14:\n    load 0\n    byte "' + name + '"\n    len\n    <\n    bnz main_l21\n    global GroupSize\n    int 2\n    ==\n    global GroupSize\n    int 4\n    ==\n    ||\n    assert\n    gtxn 0 Sender\n    gtxn 1 Sender\n    ==\n    assert\n    gtxn 0 Receiver\n    addr SYGCDTWGBXKV4ZL5YAWSYAVOUC25U2XDB6SMQHLRCTYVF566TQZ3EOABH4\n    ==\n    assert\n    global GroupSize\n    int 2\n    ==\n    bnz main_l20\n    global GroupSize\n    int 4\n    ==\n    bnz main_l19\n    int 0\n    return\n    main_l18:\n    int 1\n    assert\n    int 1\n    b main_l31\n    main_l19:\n    gtxn 1 Receiver\n    gtxn 2 Sender\n    ==\n    gtxn 2 ApplicationID\n    int 628095415\n    ==\n    &&\n    gtxn 2 OnCompletion\n    int OptIn\n    ==\n    &&\n    gtxn 3 ApplicationID\n    int 628095415\n    ==\n    &&\n    gtxn 3 Sender\n    gtxn 0 Sender\n    ==\n    &&\n    gtxna 3 ApplicationArgs 0\n    byte "register_name"\n    ==\n    &&\n    gtxna 3 ApplicationArgs 1\n    byte "' + name + '"\n    ==\n    &&\n    assert\n    b main_l18\n    main_l20:\n    gtxn 1 ApplicationID\n    int 628095415\n    ==\n    gtxna 1 ApplicationArgs 0\n    byte "register_name"\n    ==\n    &&\n    gtxna 1 ApplicationArgs 1\n    byte "' + name + '"\n    ==\n    &&\n    assert\n    b main_l18\n    main_l21:\n    byte "' + name + '"\n    load 0\n    getbyte\n    int 97\n    >=\n    byte "' + name + '"\n    load 0\n    getbyte\n    int 122\n    <=\n    &&\n    byte "' + name + '"\n    load 0\n    getbyte\n    int 48\n    >=\n    byte "' + name + '"\n    load 0\n    getbyte\n    int 57\n    <=\n    &&\n    ||\n    assert\n    load 0\n    int 1\n    +\n    store 0\n    b main_l14\n    main_l22:\n    gtxn 0 Amount\n    int 150000000\n    >=\n    assert\n    byte "' + name + '"\n    len\n    int 64\n    <=\n    assert\n    int 0\n    store 0\n    main_l23:\n    load 0\n    byte "' + name + '"\n    len\n    <\n    bnz main_l30\n    global GroupSize\n    int 2\n    ==\n    global GroupSize\n    int 4\n    ==\n    ||\n    assert\n    gtxn 0 Sender\n    gtxn 1 Sender\n    ==\n    assert\n    gtxn 0 Receiver\n    addr SYGCDTWGBXKV4ZL5YAWSYAVOUC25U2XDB6SMQHLRCTYVF566TQZ3EOABH4\n    ==\n    assert\n    global GroupSize\n    int 2\n    ==\n    bnz main_l29\n    global GroupSize\n    int 4\n    ==\n    bnz main_l28\n    int 0\n    return\n    main_l27:\n    int 1\n    assert\n    int 1\n    b main_l31\n    main_l28:\n    gtxn 1 Receiver\n    gtxn 2 Sender\n    ==\n    gtxn 2 ApplicationID\n    int 628095415\n    ==\n    &&\n    gtxn 2 OnCompletion\n    int OptIn\n    ==\n    &&\n    gtxn 3 ApplicationID\n    int 628095415\n    ==\n    &&\n    gtxn 3 Sender\n    gtxn 0 Sender\n    ==\n    &&\n    gtxna 3 ApplicationArgs 0\n    byte "register_name"\n    ==\n    &&\n    gtxna 3 ApplicationArgs 1\n    byte "' + name + '"\n    ==\n    &&\n    assert\n    b main_l27\n    main_l29:\n    gtxn 1 ApplicationID\n    int 628095415\n    ==\n    gtxna 1 ApplicationArgs 0\n    byte "register_name"\n    ==\n    &&\n    gtxna 1 ApplicationArgs 1\n    byte "' + name + '"\n    ==\n    &&\n    assert\n    b main_l27\n    main_l30:\n    byte "' + name + '"\n    load 0\n    getbyte\n    int 97\n    >=\n    byte "' + name + '"\n    load 0\n    getbyte\n    int 122\n    <=\n    &&\n    byte "' + name + '"\n    load 0\n    getbyte\n    int 48\n    >=\n    byte "' + name + '"\n    load 0\n    getbyte\n    int 57\n    <=\n    &&\n    ||\n    assert\n    load 0\n    int 1\n    +\n    store 0\n    b main_l23\n    main_l31:\n    return';
      }
      exports2.generateTeal = generateTeal2;
    }
  });

  // node_modules/algosdk/dist/esm/index.js
  var esm_exports = {};
  __export(esm_exports, {
    ABIAddressType: () => ABIAddressType,
    ABIArrayDynamicType: () => ABIArrayDynamicType,
    ABIArrayStaticType: () => ABIArrayStaticType,
    ABIBoolType: () => ABIBoolType,
    ABIByteType: () => ABIByteType,
    ABIContract: () => ABIContract,
    ABIInterface: () => ABIInterface,
    ABIMethod: () => ABIMethod,
    ABIReferenceType: () => ABIReferenceType,
    ABIStringType: () => ABIStringType,
    ABITransactionType: () => ABITransactionType,
    ABITupleType: () => ABITupleType,
    ABIType: () => ABIType,
    ABIUfixedType: () => ABIUfixedType,
    ABIUintType: () => ABIUintType,
    ADDR_BYTE_SIZE: () => ADDR_BYTE_SIZE,
    ALGORAND_MIN_TX_FEE: () => ALGORAND_MIN_TX_FEE,
    Algodv2: () => AlgodClient,
    AtomicTransactionComposer: () => AtomicTransactionComposer,
    AtomicTransactionComposerStatus: () => AtomicTransactionComposerStatus,
    ERROR_INVALID_MICROALGOS: () => ERROR_INVALID_MICROALGOS,
    ERROR_MULTISIG_BAD_SENDER: () => ERROR_MULTISIG_BAD_SENDER,
    INVALID_MICROALGOS_ERROR_MSG: () => INVALID_MICROALGOS_ERROR_MSG,
    Indexer: () => IndexerClient,
    IntDecoding: () => intDecoding_default,
    Kmd: () => Kmd,
    LENGTH_ENCODE_BYTE_SIZE: () => LENGTH_ENCODE_BYTE_SIZE,
    LogicSigAccount: () => LogicSigAccount,
    LogicTemplates: () => LogicTemplates,
    MAX_LEN: () => MAX_LEN,
    MULTISIG_BAD_SENDER_ERROR_MSG: () => MULTISIG_BAD_SENDER_ERROR_MSG,
    OnApplicationComplete: () => OnApplicationComplete,
    SINGLE_BOOL_SIZE: () => SINGLE_BOOL_SIZE,
    SINGLE_BYTE_SIZE: () => SINGLE_BYTE_SIZE,
    Transaction: () => Transaction,
    TransactionType: () => TransactionType,
    abiCheckTransactionType: () => abiCheckTransactionType,
    abiTypeIsReference: () => abiTypeIsReference,
    abiTypeIsTransaction: () => abiTypeIsTransaction,
    algosToMicroalgos: () => algosToMicroalgos,
    appendSignMultisigTransaction: () => appendSignMultisigTransaction,
    assignGroupID: () => assignGroupID,
    computeGroupID: () => computeGroupID,
    createDryrun: () => createDryrun,
    decodeAddress: () => decodeAddress,
    decodeObj: () => decodeObj,
    decodeSignedTransaction: () => decodeSignedTransaction,
    decodeUint64: () => decodeUint64,
    decodeUnsignedTransaction: () => decodeUnsignedTransaction,
    default: () => esm_default,
    encodeAddress: () => encodeAddress,
    encodeObj: () => encodeObj,
    encodeUint64: () => encodeUint64,
    encodeUnsignedTransaction: () => encodeUnsignedTransaction,
    generateAccount: () => generateAccount,
    getApplicationAddress: () => getApplicationAddress,
    instantiateTxnIfNeeded: () => instantiateTxnIfNeeded,
    isTransactionWithSigner: () => isTransactionWithSigner,
    isValidAddress: () => isValidAddress,
    logicSigFromByte: () => logicSigFromByte,
    makeApplicationCallTxnFromObject: () => makeApplicationCallTxnFromObject,
    makeApplicationClearStateTxn: () => makeApplicationClearStateTxn,
    makeApplicationClearStateTxnFromObject: () => makeApplicationClearStateTxnFromObject,
    makeApplicationCloseOutTxn: () => makeApplicationCloseOutTxn,
    makeApplicationCloseOutTxnFromObject: () => makeApplicationCloseOutTxnFromObject,
    makeApplicationCreateTxn: () => makeApplicationCreateTxn,
    makeApplicationCreateTxnFromObject: () => makeApplicationCreateTxnFromObject,
    makeApplicationDeleteTxn: () => makeApplicationDeleteTxn,
    makeApplicationDeleteTxnFromObject: () => makeApplicationDeleteTxnFromObject,
    makeApplicationNoOpTxn: () => makeApplicationNoOpTxn,
    makeApplicationNoOpTxnFromObject: () => makeApplicationNoOpTxnFromObject,
    makeApplicationOptInTxn: () => makeApplicationOptInTxn,
    makeApplicationOptInTxnFromObject: () => makeApplicationOptInTxnFromObject,
    makeApplicationUpdateTxn: () => makeApplicationUpdateTxn,
    makeApplicationUpdateTxnFromObject: () => makeApplicationUpdateTxnFromObject,
    makeAssetConfigTxn: () => makeAssetConfigTxn,
    makeAssetConfigTxnWithSuggestedParams: () => makeAssetConfigTxnWithSuggestedParams,
    makeAssetConfigTxnWithSuggestedParamsFromObject: () => makeAssetConfigTxnWithSuggestedParamsFromObject,
    makeAssetCreateTxn: () => makeAssetCreateTxn,
    makeAssetCreateTxnWithSuggestedParams: () => makeAssetCreateTxnWithSuggestedParams,
    makeAssetCreateTxnWithSuggestedParamsFromObject: () => makeAssetCreateTxnWithSuggestedParamsFromObject,
    makeAssetDestroyTxn: () => makeAssetDestroyTxn,
    makeAssetDestroyTxnWithSuggestedParams: () => makeAssetDestroyTxnWithSuggestedParams,
    makeAssetDestroyTxnWithSuggestedParamsFromObject: () => makeAssetDestroyTxnWithSuggestedParamsFromObject,
    makeAssetFreezeTxn: () => makeAssetFreezeTxn,
    makeAssetFreezeTxnWithSuggestedParams: () => makeAssetFreezeTxnWithSuggestedParams,
    makeAssetFreezeTxnWithSuggestedParamsFromObject: () => makeAssetFreezeTxnWithSuggestedParamsFromObject,
    makeAssetTransferTxn: () => makeAssetTransferTxn,
    makeAssetTransferTxnWithSuggestedParams: () => makeAssetTransferTxnWithSuggestedParams,
    makeAssetTransferTxnWithSuggestedParamsFromObject: () => makeAssetTransferTxnWithSuggestedParamsFromObject,
    makeBasicAccountTransactionSigner: () => makeBasicAccountTransactionSigner,
    makeKeyRegistrationTxn: () => makeKeyRegistrationTxn,
    makeKeyRegistrationTxnWithSuggestedParams: () => makeKeyRegistrationTxnWithSuggestedParams,
    makeKeyRegistrationTxnWithSuggestedParamsFromObject: () => makeKeyRegistrationTxnWithSuggestedParamsFromObject,
    makeLogicSig: () => makeLogicSig,
    makeLogicSigAccountTransactionSigner: () => makeLogicSigAccountTransactionSigner,
    makeMultiSigAccountTransactionSigner: () => makeMultiSigAccountTransactionSigner,
    makePaymentTxn: () => makePaymentTxn,
    makePaymentTxnWithSuggestedParams: () => makePaymentTxnWithSuggestedParams,
    makePaymentTxnWithSuggestedParamsFromObject: () => makePaymentTxnWithSuggestedParamsFromObject,
    masterDerivationKeyToMnemonic: () => masterDerivationKeyToMnemonic,
    mergeMultisigTransactions: () => mergeMultisigTransactions,
    microalgosToAlgos: () => microalgosToAlgos,
    mnemonicFromSeed: () => mnemonicFromSeed,
    mnemonicToMasterDerivationKey: () => mnemonicToMasterDerivationKey,
    mnemonicToSecretKey: () => mnemonicToSecretKey,
    modelsv2: () => types_exports,
    multisigAddress: () => multisigAddress,
    secretKeyToMnemonic: () => secretKeyToMnemonic,
    seedFromMnemonic: () => seedFromMnemonic,
    signBid: () => signBid,
    signBytes: () => signBytes,
    signLogicSigTransaction: () => signLogicSigTransaction,
    signLogicSigTransactionObject: () => signLogicSigTransactionObject,
    signMultisigTransaction: () => signMultisigTransaction,
    signTransaction: () => signTransaction,
    tealSign: () => tealSign,
    tealSignFromProgram: () => tealSignFromProgram,
    verifyBytes: () => verifyBytes,
    waitForConfirmation: () => waitForConfirmation
  });

  // node_modules/algosdk/dist/esm/src/main.js
  var main_exports = {};
  __export(main_exports, {
    ABIAddressType: () => ABIAddressType,
    ABIArrayDynamicType: () => ABIArrayDynamicType,
    ABIArrayStaticType: () => ABIArrayStaticType,
    ABIBoolType: () => ABIBoolType,
    ABIByteType: () => ABIByteType,
    ABIContract: () => ABIContract,
    ABIInterface: () => ABIInterface,
    ABIMethod: () => ABIMethod,
    ABIReferenceType: () => ABIReferenceType,
    ABIStringType: () => ABIStringType,
    ABITransactionType: () => ABITransactionType,
    ABITupleType: () => ABITupleType,
    ABIType: () => ABIType,
    ABIUfixedType: () => ABIUfixedType,
    ABIUintType: () => ABIUintType,
    ADDR_BYTE_SIZE: () => ADDR_BYTE_SIZE,
    ALGORAND_MIN_TX_FEE: () => ALGORAND_MIN_TX_FEE,
    Algodv2: () => AlgodClient,
    AtomicTransactionComposer: () => AtomicTransactionComposer,
    AtomicTransactionComposerStatus: () => AtomicTransactionComposerStatus,
    ERROR_INVALID_MICROALGOS: () => ERROR_INVALID_MICROALGOS,
    ERROR_MULTISIG_BAD_SENDER: () => ERROR_MULTISIG_BAD_SENDER,
    INVALID_MICROALGOS_ERROR_MSG: () => INVALID_MICROALGOS_ERROR_MSG,
    Indexer: () => IndexerClient,
    IntDecoding: () => intDecoding_default,
    Kmd: () => Kmd,
    LENGTH_ENCODE_BYTE_SIZE: () => LENGTH_ENCODE_BYTE_SIZE,
    LogicSigAccount: () => LogicSigAccount,
    LogicTemplates: () => LogicTemplates,
    MAX_LEN: () => MAX_LEN,
    MULTISIG_BAD_SENDER_ERROR_MSG: () => MULTISIG_BAD_SENDER_ERROR_MSG,
    OnApplicationComplete: () => OnApplicationComplete,
    SINGLE_BOOL_SIZE: () => SINGLE_BOOL_SIZE,
    SINGLE_BYTE_SIZE: () => SINGLE_BYTE_SIZE,
    Transaction: () => Transaction,
    TransactionType: () => TransactionType,
    abiCheckTransactionType: () => abiCheckTransactionType,
    abiTypeIsReference: () => abiTypeIsReference,
    abiTypeIsTransaction: () => abiTypeIsTransaction,
    algosToMicroalgos: () => algosToMicroalgos,
    appendSignMultisigTransaction: () => appendSignMultisigTransaction,
    assignGroupID: () => assignGroupID,
    computeGroupID: () => computeGroupID,
    createDryrun: () => createDryrun,
    decodeAddress: () => decodeAddress,
    decodeObj: () => decodeObj,
    decodeSignedTransaction: () => decodeSignedTransaction,
    decodeUint64: () => decodeUint64,
    decodeUnsignedTransaction: () => decodeUnsignedTransaction,
    encodeAddress: () => encodeAddress,
    encodeObj: () => encodeObj,
    encodeUint64: () => encodeUint64,
    encodeUnsignedTransaction: () => encodeUnsignedTransaction,
    generateAccount: () => generateAccount,
    getApplicationAddress: () => getApplicationAddress,
    instantiateTxnIfNeeded: () => instantiateTxnIfNeeded,
    isTransactionWithSigner: () => isTransactionWithSigner,
    isValidAddress: () => isValidAddress,
    logicSigFromByte: () => logicSigFromByte,
    makeApplicationCallTxnFromObject: () => makeApplicationCallTxnFromObject,
    makeApplicationClearStateTxn: () => makeApplicationClearStateTxn,
    makeApplicationClearStateTxnFromObject: () => makeApplicationClearStateTxnFromObject,
    makeApplicationCloseOutTxn: () => makeApplicationCloseOutTxn,
    makeApplicationCloseOutTxnFromObject: () => makeApplicationCloseOutTxnFromObject,
    makeApplicationCreateTxn: () => makeApplicationCreateTxn,
    makeApplicationCreateTxnFromObject: () => makeApplicationCreateTxnFromObject,
    makeApplicationDeleteTxn: () => makeApplicationDeleteTxn,
    makeApplicationDeleteTxnFromObject: () => makeApplicationDeleteTxnFromObject,
    makeApplicationNoOpTxn: () => makeApplicationNoOpTxn,
    makeApplicationNoOpTxnFromObject: () => makeApplicationNoOpTxnFromObject,
    makeApplicationOptInTxn: () => makeApplicationOptInTxn,
    makeApplicationOptInTxnFromObject: () => makeApplicationOptInTxnFromObject,
    makeApplicationUpdateTxn: () => makeApplicationUpdateTxn,
    makeApplicationUpdateTxnFromObject: () => makeApplicationUpdateTxnFromObject,
    makeAssetConfigTxn: () => makeAssetConfigTxn,
    makeAssetConfigTxnWithSuggestedParams: () => makeAssetConfigTxnWithSuggestedParams,
    makeAssetConfigTxnWithSuggestedParamsFromObject: () => makeAssetConfigTxnWithSuggestedParamsFromObject,
    makeAssetCreateTxn: () => makeAssetCreateTxn,
    makeAssetCreateTxnWithSuggestedParams: () => makeAssetCreateTxnWithSuggestedParams,
    makeAssetCreateTxnWithSuggestedParamsFromObject: () => makeAssetCreateTxnWithSuggestedParamsFromObject,
    makeAssetDestroyTxn: () => makeAssetDestroyTxn,
    makeAssetDestroyTxnWithSuggestedParams: () => makeAssetDestroyTxnWithSuggestedParams,
    makeAssetDestroyTxnWithSuggestedParamsFromObject: () => makeAssetDestroyTxnWithSuggestedParamsFromObject,
    makeAssetFreezeTxn: () => makeAssetFreezeTxn,
    makeAssetFreezeTxnWithSuggestedParams: () => makeAssetFreezeTxnWithSuggestedParams,
    makeAssetFreezeTxnWithSuggestedParamsFromObject: () => makeAssetFreezeTxnWithSuggestedParamsFromObject,
    makeAssetTransferTxn: () => makeAssetTransferTxn,
    makeAssetTransferTxnWithSuggestedParams: () => makeAssetTransferTxnWithSuggestedParams,
    makeAssetTransferTxnWithSuggestedParamsFromObject: () => makeAssetTransferTxnWithSuggestedParamsFromObject,
    makeBasicAccountTransactionSigner: () => makeBasicAccountTransactionSigner,
    makeKeyRegistrationTxn: () => makeKeyRegistrationTxn,
    makeKeyRegistrationTxnWithSuggestedParams: () => makeKeyRegistrationTxnWithSuggestedParams,
    makeKeyRegistrationTxnWithSuggestedParamsFromObject: () => makeKeyRegistrationTxnWithSuggestedParamsFromObject,
    makeLogicSig: () => makeLogicSig,
    makeLogicSigAccountTransactionSigner: () => makeLogicSigAccountTransactionSigner,
    makeMultiSigAccountTransactionSigner: () => makeMultiSigAccountTransactionSigner,
    makePaymentTxn: () => makePaymentTxn,
    makePaymentTxnWithSuggestedParams: () => makePaymentTxnWithSuggestedParams,
    makePaymentTxnWithSuggestedParamsFromObject: () => makePaymentTxnWithSuggestedParamsFromObject,
    masterDerivationKeyToMnemonic: () => masterDerivationKeyToMnemonic,
    mergeMultisigTransactions: () => mergeMultisigTransactions,
    microalgosToAlgos: () => microalgosToAlgos,
    mnemonicFromSeed: () => mnemonicFromSeed,
    mnemonicToMasterDerivationKey: () => mnemonicToMasterDerivationKey,
    mnemonicToSecretKey: () => mnemonicToSecretKey,
    modelsv2: () => types_exports,
    multisigAddress: () => multisigAddress,
    secretKeyToMnemonic: () => secretKeyToMnemonic,
    seedFromMnemonic: () => seedFromMnemonic,
    signBid: () => signBid,
    signBytes: () => signBytes,
    signLogicSigTransaction: () => signLogicSigTransaction,
    signLogicSigTransactionObject: () => signLogicSigTransactionObject,
    signMultisigTransaction: () => signMultisigTransaction,
    signTransaction: () => signTransaction,
    tealSign: () => tealSign,
    tealSignFromProgram: () => tealSignFromProgram,
    verifyBytes: () => verifyBytes,
    waitForConfirmation: () => waitForConfirmation
  });
  init_naclWrappers();
  init_address();
  init_encoding();
  init_transaction();
  var LogicTemplatesCommonJSExport = __toESM(require_logicTemplates());

  // node_modules/algosdk/dist/esm/src/bid.js
  init_address();
  init_encoding();
  init_naclWrappers();
  init_utils();
  var Bid = class {
    constructor({ bidderKey, bidAmount, bidID, auctionKey, auctionID, maxPrice }) {
      this.name = "Bid";
      this.tag = Buffer.from([97, 66]);
      const decodedBidderKey = decodeAddress(bidderKey);
      const decodedAuctionKey = decodeAddress(auctionKey);
      if (!Number.isSafeInteger(bidAmount) || bidAmount < 0)
        throw Error("Bid amount must be positive and 2^53-1");
      if (!Number.isSafeInteger(bidID) || bidID < 0)
        throw Error("BidID must be positive and 2^53-1");
      if (!Number.isSafeInteger(auctionID) || auctionID < 0)
        throw Error("auctionID must be positive");
      Object.assign(this, {
        bidderKey: decodedBidderKey,
        bidAmount,
        bidID,
        auctionKey: decodedAuctionKey,
        auctionID,
        maxPrice
      });
    }
    get_obj_for_encoding() {
      return {
        bidder: Buffer.from(this.bidderKey.publicKey),
        cur: this.bidAmount,
        price: this.maxPrice,
        id: this.bidID,
        auc: Buffer.from(this.auctionKey.publicKey),
        aid: this.auctionID
      };
    }
    signBid(sk) {
      const encodedMsg = encode2(this.get_obj_for_encoding());
      const toBeSigned = Buffer.from(concatArrays(this.tag, encodedMsg));
      const sig = sign(toBeSigned, sk);
      const sBid = {
        sig: Buffer.from(sig),
        bid: this.get_obj_for_encoding()
      };
      const note = {
        t: "b",
        b: sBid
      };
      return new Uint8Array(encode2(note));
    }
  };

  // node_modules/algosdk/dist/esm/src/convert.js
  var MICROALGOS_TO_ALGOS_RATIO = 1e6;
  var INVALID_MICROALGOS_ERROR_MSG = "Microalgos should be positive and less than 2^53 - 1.";
  function microalgosToAlgos(microalgos) {
    if (microalgos < 0 || !Number.isSafeInteger(microalgos)) {
      throw new Error(INVALID_MICROALGOS_ERROR_MSG);
    }
    return microalgos / MICROALGOS_TO_ALGOS_RATIO;
  }
  function algosToMicroalgos(algos) {
    const microalgos = algos * MICROALGOS_TO_ALGOS_RATIO;
    return Math.round(microalgos);
  }

  // node_modules/algosdk/dist/esm/src/main.js
  init_utils();
  __reExport(main_exports, __toESM(require_algod()));

  // node_modules/algosdk/dist/esm/src/client/v2/serviceClient.js
  init_client();
  init_intDecoding();
  function convertTokenStringToTokenHeader(token = "", headerIdentifier) {
    const tokenHeader = {};
    tokenHeader[headerIdentifier] = token;
    return tokenHeader;
  }
  function isBaseHTTPClient(tbc) {
    return typeof tbc.get === "function";
  }
  var ServiceClient = class {
    constructor(tokenHeaderIdentifier, tokenHeaderOrStrOrBaseClient, baseServer, port, defaultHeaders = {}) {
      if (isBaseHTTPClient(tokenHeaderOrStrOrBaseClient)) {
        this.c = new HTTPClient(tokenHeaderOrStrOrBaseClient);
      } else {
        let tokenHeader;
        if (typeof tokenHeaderOrStrOrBaseClient === "string") {
          tokenHeader = convertTokenStringToTokenHeader(tokenHeaderOrStrOrBaseClient, tokenHeaderIdentifier);
        } else {
          tokenHeader = tokenHeaderOrStrOrBaseClient;
        }
        this.c = new HTTPClient(tokenHeader, baseServer, port, defaultHeaders);
      }
      this.intDecoding = intDecoding_default.DEFAULT;
    }
    setIntEncoding(method2) {
      this.intDecoding = method2;
    }
    getIntEncoding() {
      return this.intDecoding;
    }
  };

  // node_modules/algosdk/dist/esm/src/client/v2/algod/accountInformation.js
  init_jsonrequest();
  var AccountInformation = class extends JSONRequest {
    constructor(c, intDecoding, account) {
      super(c, intDecoding);
      this.account = account;
      this.account = account;
    }
    path() {
      return `/v2/accounts/${this.account}`;
    }
  };

  // node_modules/algosdk/dist/esm/src/client/v2/algod/block.js
  init_encoding();
  init_jsonrequest();
  var Block = class extends JSONRequest {
    constructor(c, roundNumber) {
      super(c);
      if (!Number.isInteger(roundNumber))
        throw Error("roundNumber should be an integer");
      this.round = roundNumber;
      this.query = { format: "msgpack" };
    }
    path() {
      return `/v2/blocks/${this.round}`;
    }
    prepare(body) {
      if (body && body.byteLength > 0) {
        return decode2(body);
      }
      return void 0;
    }
  };

  // node_modules/algosdk/dist/esm/src/client/v2/algod/compile.js
  init_jsonrequest();
  function setHeaders(headers = {}) {
    let hdrs = headers;
    if (Object.keys(hdrs).every((key) => key.toLowerCase() !== "content-type")) {
      hdrs = __spreadValues({}, headers);
      hdrs["Content-Type"] = "text/plain";
    }
    return hdrs;
  }
  var Compile = class extends JSONRequest {
    constructor(c, source) {
      super(c);
      this.source = source;
      this.source = source;
    }
    path() {
      return `/v2/teal/compile`;
    }
    async do(headers = {}) {
      const txHeaders = setHeaders(headers);
      const res = await this.c.post(this.path(), Buffer.from(this.source), txHeaders);
      return res.body;
    }
  };

  // node_modules/algosdk/dist/esm/src/client/v2/algod/dryrun.js
  init_jsonrequest();
  init_encoding();
  var Dryrun = class extends JSONRequest {
    constructor(c, dr) {
      super(c);
      this.blob = encode2(dr.get_obj_for_encoding(true));
    }
    path() {
      return "/v2/teal/dryrun";
    }
    async do(headers = {}) {
      const txHeaders = setHeaders(headers);
      const res = await this.c.post(this.path(), Buffer.from(this.blob), txHeaders);
      return res.body;
    }
  };

  // node_modules/algosdk/dist/esm/src/client/v2/algod/getAssetByID.js
  init_jsonrequest();
  var GetAssetByID = class extends JSONRequest {
    constructor(c, intDecoding, index) {
      super(c, intDecoding);
      this.index = index;
      this.index = index;
    }
    path() {
      return `/v2/assets/${this.index}`;
    }
  };

  // node_modules/algosdk/dist/esm/src/client/v2/algod/getApplicationByID.js
  init_jsonrequest();
  var GetApplicationByID = class extends JSONRequest {
    constructor(c, intDecoding, index) {
      super(c, intDecoding);
      this.index = index;
      this.index = index;
    }
    path() {
      return `/v2/applications/${this.index}`;
    }
  };

  // node_modules/algosdk/dist/esm/src/client/v2/algod/healthCheck.js
  init_jsonrequest();
  var HealthCheck = class extends JSONRequest {
    path() {
      return "/health";
    }
    async do(headers = {}) {
      const res = await this.c.get(this.path(), {}, headers);
      if (!res.ok) {
        throw new Error(`Health response: ${res.status}`);
      }
      return {};
    }
  };

  // node_modules/algosdk/dist/esm/src/client/v2/algod/pendingTransactionInformation.js
  init_jsonrequest();
  init_encoding();
  var PendingTransactionInformation = class extends JSONRequest {
    constructor(c, txid) {
      super(c);
      this.txid = txid;
      this.txid = txid;
      this.query.format = "msgpack";
    }
    prepare(body) {
      if (body && body.byteLength > 0) {
        return decode2(body);
      }
      return void 0;
    }
    path() {
      return `/v2/transactions/pending/${this.txid}`;
    }
    max(max) {
      this.query.max = max;
      return this;
    }
  };

  // node_modules/algosdk/dist/esm/src/client/v2/algod/pendingTransactions.js
  init_jsonrequest();
  init_encoding();
  var PendingTransactions = class extends JSONRequest {
    constructor(c) {
      super(c);
      this.query.format = "msgpack";
    }
    path() {
      return "/v2/transactions/pending";
    }
    prepare(body) {
      if (body && body.byteLength > 0) {
        return decode2(body);
      }
      return void 0;
    }
    max(max) {
      this.query.max = max;
      return this;
    }
  };

  // node_modules/algosdk/dist/esm/src/client/v2/algod/pendingTransactionsByAddress.js
  init_jsonrequest();
  init_encoding();
  var PendingTransactionsByAddress = class extends JSONRequest {
    constructor(c, address) {
      super(c);
      this.address = address;
      this.address = address;
      this.query.format = "msgpack";
    }
    prepare(body) {
      if (body && body.byteLength > 0) {
        return decode2(body);
      }
      return void 0;
    }
    path() {
      return `/v2/accounts/${this.address}/transactions/pending`;
    }
    max(max) {
      this.query.max = max;
      return this;
    }
  };

  // node_modules/algosdk/dist/esm/src/client/v2/algod/algod.js
  init_sendRawTransaction();

  // node_modules/algosdk/dist/esm/src/client/v2/algod/status.js
  init_jsonrequest();
  var Status = class extends JSONRequest {
    path() {
      return "/v2/status";
    }
  };

  // node_modules/algosdk/dist/esm/src/client/v2/algod/statusAfterBlock.js
  init_jsonrequest();
  var StatusAfterBlock = class extends JSONRequest {
    constructor(c, intDecoding, round) {
      super(c, intDecoding);
      this.round = round;
      if (!Number.isInteger(round))
        throw Error("round should be an integer");
      this.round = round;
    }
    path() {
      return `/v2/status/wait-for-block-after/${this.round}`;
    }
  };

  // node_modules/algosdk/dist/esm/src/client/v2/algod/suggestedParams.js
  init_jsonrequest();
  var SuggestedParamsRequest = class extends JSONRequest {
    path() {
      return "/v2/transactions/params";
    }
    prepare(body) {
      return {
        flatFee: false,
        fee: body.fee,
        firstRound: body["last-round"],
        lastRound: body["last-round"] + 1e3,
        genesisID: body["genesis-id"],
        genesisHash: body["genesis-hash"]
      };
    }
  };

  // node_modules/algosdk/dist/esm/src/client/v2/algod/supply.js
  init_jsonrequest();
  var Supply = class extends JSONRequest {
    path() {
      return "/v2/ledger/supply";
    }
  };

  // node_modules/algosdk/dist/esm/src/client/v2/algod/versions.js
  init_jsonrequest();
  var Versions = class extends JSONRequest {
    path() {
      return "/versions";
    }
  };

  // node_modules/algosdk/dist/esm/src/client/v2/algod/genesis.js
  init_jsonrequest();
  var Genesis = class extends JSONRequest {
    path() {
      return "/genesis";
    }
  };

  // node_modules/algosdk/dist/esm/src/client/v2/algod/proof.js
  init_jsonrequest();
  var Proof = class extends JSONRequest {
    constructor(c, intDecoding, round, txID) {
      super(c, intDecoding);
      this.round = round;
      this.txID = txID;
      this.round = round;
      this.txID = txID;
    }
    path() {
      return `/v2/blocks/${this.round}/transactions/${this.txID}/proof`;
    }
  };

  // node_modules/algosdk/dist/esm/src/client/v2/algod/algod.js
  var AlgodClient = class extends ServiceClient {
    constructor(tokenOrBaseClient, baseServer = "http://r2.algorand.network", port = 4180, headers = {}) {
      super("X-Algo-API-Token", tokenOrBaseClient, baseServer, port, headers);
    }
    healthCheck() {
      return new HealthCheck(this.c);
    }
    versionsCheck() {
      return new Versions(this.c);
    }
    sendRawTransaction(stxOrStxs) {
      return new SendRawTransaction(this.c, stxOrStxs);
    }
    accountInformation(account) {
      return new AccountInformation(this.c, this.intDecoding, account);
    }
    block(roundNumber) {
      return new Block(this.c, roundNumber);
    }
    pendingTransactionInformation(txid) {
      return new PendingTransactionInformation(this.c, txid);
    }
    pendingTransactionsInformation() {
      return new PendingTransactions(this.c);
    }
    pendingTransactionByAddress(address) {
      return new PendingTransactionsByAddress(this.c, address);
    }
    status() {
      return new Status(this.c, this.intDecoding);
    }
    statusAfterBlock(round) {
      return new StatusAfterBlock(this.c, this.intDecoding, round);
    }
    getTransactionParams() {
      return new SuggestedParamsRequest(this.c);
    }
    supply() {
      return new Supply(this.c, this.intDecoding);
    }
    compile(source) {
      return new Compile(this.c, source);
    }
    dryrun(dr) {
      return new Dryrun(this.c, dr);
    }
    getAssetByID(index) {
      return new GetAssetByID(this.c, this.intDecoding, index);
    }
    getApplicationByID(index) {
      return new GetApplicationByID(this.c, this.intDecoding, index);
    }
    genesis() {
      return new Genesis(this.c, this.intDecoding);
    }
    getProof(round, txID) {
      return new Proof(this.c, this.intDecoding, round, txID);
    }
  };

  // node_modules/algosdk/dist/esm/src/client/kmd.js
  init_transaction();
  var Kmd = class extends ServiceClient {
    constructor(token, baseServer = "http://127.0.0.1", port = 7833, headers = {}) {
      super("X-KMD-API-Token", token, baseServer, port, headers);
    }
    async versions() {
      const res = await this.c.get("/versions");
      return res.body;
    }
    async listWallets() {
      const res = await this.c.get("/v1/wallets");
      return res.body;
    }
    async createWallet(walletName, walletPassword, walletMDK = "", walletDriverName = "sqlite") {
      const req = {
        wallet_name: walletName,
        wallet_driver_name: walletDriverName,
        wallet_password: walletPassword,
        master_derivation_key: Buffer.from(walletMDK).toString("base64")
      };
      const res = await this.c.post("/v1/wallet", req);
      return res.body;
    }
    async initWalletHandle(walletID, walletPassword) {
      const req = {
        wallet_id: walletID,
        wallet_password: walletPassword
      };
      const res = await this.c.post("/v1/wallet/init", req);
      return res.body;
    }
    async releaseWalletHandle(walletHandle) {
      const req = {
        wallet_handle_token: walletHandle
      };
      const res = await this.c.post("/v1/wallet/release", req);
      return res.body;
    }
    async renewWalletHandle(walletHandle) {
      const req = {
        wallet_handle_token: walletHandle
      };
      const res = await this.c.post("/v1/wallet/renew", req);
      return res.body;
    }
    async renameWallet(walletID, walletPassword, newWalletName) {
      const req = {
        wallet_id: walletID,
        wallet_password: walletPassword,
        wallet_name: newWalletName
      };
      const res = await this.c.post("/v1/wallet/rename", req);
      return res.body;
    }
    async getWallet(walletHandle) {
      const req = {
        wallet_handle_token: walletHandle
      };
      const res = await this.c.post("/v1/wallet/info", req);
      return res.body;
    }
    async exportMasterDerivationKey(walletHandle, walletPassword) {
      const req = {
        wallet_handle_token: walletHandle,
        wallet_password: walletPassword
      };
      const res = await this.c.post("/v1/master-key/export", req);
      return {
        master_derivation_key: Buffer.from(res.body.master_derivation_key, "base64")
      };
    }
    async importKey(walletHandle, secretKey) {
      const req = {
        wallet_handle_token: walletHandle,
        private_key: Buffer.from(secretKey).toString("base64")
      };
      const res = await this.c.post("/v1/key/import", req);
      return res.body;
    }
    async exportKey(walletHandle, walletPassword, addr) {
      const req = {
        wallet_handle_token: walletHandle,
        address: addr,
        wallet_password: walletPassword
      };
      const res = await this.c.post("/v1/key/export", req);
      return { private_key: Buffer.from(res.body.private_key, "base64") };
    }
    async generateKey(walletHandle) {
      const req = {
        wallet_handle_token: walletHandle,
        display_mnemonic: false
      };
      const res = await this.c.post("/v1/key", req);
      return res.body;
    }
    async deleteKey(walletHandle, walletPassword, addr) {
      const req = {
        wallet_handle_token: walletHandle,
        address: addr,
        wallet_password: walletPassword
      };
      const res = await this.c.delete("/v1/key", req);
      return res.body;
    }
    async listKeys(walletHandle) {
      const req = {
        wallet_handle_token: walletHandle
      };
      const res = await this.c.post("/v1/key/list", req);
      return res.body;
    }
    async signTransaction(walletHandle, walletPassword, transaction) {
      const tx = instantiateTxnIfNeeded(transaction);
      const req = {
        wallet_handle_token: walletHandle,
        wallet_password: walletPassword,
        transaction: Buffer.from(tx.toByte()).toString("base64")
      };
      const res = await this.c.post("/v1/transaction/sign", req);
      if (res.status === 200) {
        return Buffer.from(res.body.signed_transaction, "base64");
      }
      return res.body;
    }
    async signTransactionWithSpecificPublicKey(walletHandle, walletPassword, transaction, publicKey) {
      const tx = instantiateTxnIfNeeded(transaction);
      const req = {
        wallet_handle_token: walletHandle,
        wallet_password: walletPassword,
        transaction: Buffer.from(tx.toByte()).toString("base64"),
        public_key: Buffer.from(publicKey).toString("base64")
      };
      const res = await this.c.post("/v1/transaction/sign", req);
      if (res.status === 200) {
        return Buffer.from(res.body.signed_transaction, "base64");
      }
      return res.body;
    }
    async listMultisig(walletHandle) {
      const req = {
        wallet_handle_token: walletHandle
      };
      const res = await this.c.post("/v1/multisig/list", req);
      return res.body;
    }
    async importMultisig(walletHandle, version, threshold, pks) {
      const req = {
        wallet_handle_token: walletHandle,
        multisig_version: version,
        threshold,
        pks
      };
      const res = await this.c.post("/v1/multisig/import", req);
      return res.body;
    }
    async exportMultisig(walletHandle, addr) {
      const req = {
        wallet_handle_token: walletHandle,
        address: addr
      };
      const res = await this.c.post("/v1/multisig/export", req);
      return res.body;
    }
    async signMultisigTransaction(walletHandle, pw, transaction, pk, partial) {
      const tx = instantiateTxnIfNeeded(transaction);
      const req = {
        wallet_handle_token: walletHandle,
        transaction: Buffer.from(tx.toByte()).toString("base64"),
        public_key: Buffer.from(pk).toString("base64"),
        partial_multisig: partial,
        wallet_password: pw
      };
      const res = await this.c.post("/v1/multisig/sign", req);
      return res.body;
    }
    async deleteMultisig(walletHandle, walletPassword, addr) {
      const req = {
        wallet_handle_token: walletHandle,
        address: addr,
        wallet_password: walletPassword
      };
      const res = await this.c.delete("/v1/multisig", req);
      return res.body;
    }
  };

  // node_modules/algosdk/dist/esm/src/main.js
  init_intDecoding();

  // node_modules/algosdk/dist/esm/src/client/v2/indexer/makeHealthCheck.js
  init_jsonrequest();
  var MakeHealthCheck = class extends JSONRequest {
    path() {
      return "/health";
    }
  };

  // node_modules/algosdk/dist/esm/src/client/v2/indexer/lookupAssetBalances.js
  init_jsonrequest();
  var LookupAssetBalances = class extends JSONRequest {
    constructor(c, intDecoding, index) {
      super(c, intDecoding);
      this.index = index;
      this.index = index;
    }
    path() {
      return `/v2/assets/${this.index}/balances`;
    }
    limit(limit) {
      this.query.limit = limit;
      return this;
    }
    round(round) {
      this.query.round = round;
      return this;
    }
    currencyGreaterThan(greater) {
      this.query["currency-greater-than"] = greater;
      return this;
    }
    currencyLessThan(lesser) {
      this.query["currency-less-than"] = lesser;
      return this;
    }
    nextToken(nextToken) {
      this.query.next = nextToken;
      return this;
    }
    includeAll(value = true) {
      this.query["include-all"] = value;
      return this;
    }
  };

  // node_modules/algosdk/dist/esm/src/client/v2/indexer/lookupAssetTransactions.js
  init_jsonrequest();

  // node_modules/algosdk/dist/esm/src/client/v2/indexer/lookupAccountTransactions.js
  init_jsonrequest();
  function base64StringFunnel(data) {
    if (typeof data === "string") {
      return data;
    }
    return Buffer.from(data).toString("base64");
  }
  var LookupAccountTransactions = class extends JSONRequest {
    constructor(c, intDecoding, account) {
      super(c, intDecoding);
      this.account = account;
      this.account = account;
    }
    path() {
      return `/v2/accounts/${this.account}/transactions`;
    }
    notePrefix(prefix) {
      this.query["note-prefix"] = base64StringFunnel(prefix);
      return this;
    }
    txType(type) {
      this.query["tx-type"] = type;
      return this;
    }
    sigType(type) {
      this.query["sig-type"] = type;
      return this;
    }
    txid(txid) {
      this.query.txid = txid;
      return this;
    }
    round(round) {
      this.query.round = round;
      return this;
    }
    minRound(round) {
      this.query["min-round"] = round;
      return this;
    }
    maxRound(round) {
      this.query["max-round"] = round;
      return this;
    }
    assetID(id) {
      this.query["asset-id"] = id;
      return this;
    }
    limit(limit) {
      this.query.limit = limit;
      return this;
    }
    beforeTime(before) {
      this.query["before-time"] = before;
      return this;
    }
    afterTime(after) {
      this.query["after-time"] = after;
      return this;
    }
    currencyGreaterThan(greater) {
      this.query["currency-greater-than"] = greater;
      return this;
    }
    currencyLessThan(lesser) {
      this.query["currency-less-than"] = lesser;
      return this;
    }
    nextToken(nextToken) {
      this.query.next = nextToken;
      return this;
    }
    rekeyTo(rekeyTo) {
      this.query["rekey-to"] = rekeyTo;
      return this;
    }
  };

  // node_modules/algosdk/dist/esm/src/client/v2/indexer/lookupAssetTransactions.js
  var LookupAssetTransactions = class extends JSONRequest {
    constructor(c, intDecoding, index) {
      super(c, intDecoding);
      this.index = index;
      this.index = index;
    }
    path() {
      return `/v2/assets/${this.index}/transactions`;
    }
    notePrefix(prefix) {
      this.query["note-prefix"] = base64StringFunnel(prefix);
      return this;
    }
    txType(type) {
      this.query["tx-type"] = type;
      return this;
    }
    sigType(type) {
      this.query["sig-type"] = type;
      return this;
    }
    txid(txid) {
      this.query.txid = txid;
      return this;
    }
    round(round) {
      this.query.round = round;
      return this;
    }
    minRound(round) {
      this.query["min-round"] = round;
      return this;
    }
    maxRound(round) {
      this.query["max-round"] = round;
      return this;
    }
    assetID(id) {
      this.query["asset-id"] = id;
      return this;
    }
    limit(limit) {
      this.query.limit = limit;
      return this;
    }
    beforeTime(before) {
      this.query["before-time"] = before;
      return this;
    }
    afterTime(after) {
      this.query["after-time"] = after;
      return this;
    }
    currencyGreaterThan(greater) {
      this.query["currency-greater-than"] = greater;
      return this;
    }
    currencyLessThan(lesser) {
      this.query["currency-less-than"] = lesser;
      return this;
    }
    addressRole(role) {
      this.query["address-role"] = role;
      return this;
    }
    address(address) {
      this.query.address = address;
      return this;
    }
    excludeCloseTo(exclude) {
      this.query["exclude-close-to"] = exclude;
      return this;
    }
    nextToken(nextToken) {
      this.query.next = nextToken;
      return this;
    }
    rekeyTo(rekeyTo) {
      this.query["rekey-to"] = rekeyTo;
      return this;
    }
  };

  // node_modules/algosdk/dist/esm/src/client/v2/indexer/lookupBlock.js
  init_jsonrequest();
  var LookupBlock = class extends JSONRequest {
    constructor(c, intDecoding, round) {
      super(c, intDecoding);
      this.round = round;
      this.round = round;
    }
    path() {
      return `/v2/blocks/${this.round}`;
    }
  };

  // node_modules/algosdk/dist/esm/src/client/v2/indexer/lookupTransactionByID.js
  init_jsonrequest();
  var LookupTransactionByID = class extends JSONRequest {
    constructor(c, intDecoding, txID) {
      super(c, intDecoding);
      this.txID = txID;
      this.txID = txID;
    }
    path() {
      return `/v2/transactions/${this.txID}`;
    }
  };

  // node_modules/algosdk/dist/esm/src/client/v2/indexer/lookupAccountByID.js
  init_jsonrequest();
  var LookupAccountByID = class extends JSONRequest {
    constructor(c, intDecoding, account) {
      super(c, intDecoding);
      this.account = account;
      this.account = account;
    }
    path() {
      return `/v2/accounts/${this.account}`;
    }
    round(round) {
      this.query.round = round;
      return this;
    }
    includeAll(value = true) {
      this.query["include-all"] = value;
      return this;
    }
  };

  // node_modules/algosdk/dist/esm/src/client/v2/indexer/lookupAssetByID.js
  init_jsonrequest();
  var LookupAssetByID = class extends JSONRequest {
    constructor(c, intDecoding, index) {
      super(c, intDecoding);
      this.index = index;
      this.index = index;
    }
    path() {
      return `/v2/assets/${this.index}`;
    }
    includeAll(value = true) {
      this.query["include-all"] = value;
      return this;
    }
  };

  // node_modules/algosdk/dist/esm/src/client/v2/indexer/lookupApplications.js
  init_jsonrequest();
  var LookupApplications = class extends JSONRequest {
    constructor(c, intDecoding, index) {
      super(c, intDecoding);
      this.index = index;
      this.index = index;
    }
    path() {
      return `/v2/applications/${this.index}`;
    }
    includeAll(value = true) {
      this.query["include-all"] = value;
      return this;
    }
  };

  // node_modules/algosdk/dist/esm/src/client/v2/indexer/lookupApplicationLogs.js
  init_jsonrequest();
  var LookupApplicationLogs = class extends JSONRequest {
    constructor(c, intDecoding, appID) {
      super(c, intDecoding);
      this.appID = appID;
      this.appID = appID;
    }
    path() {
      return `/v2/applications/${this.appID}/logs`;
    }
    limit(limit) {
      this.query.limit = limit;
      return this;
    }
    minRound(round) {
      this.query["min-round"] = round;
      return this;
    }
    maxRound(round) {
      this.query["max-round"] = round;
      return this;
    }
    nextToken(nextToken) {
      this.query.next = nextToken;
      return this;
    }
    sender(senderAddress) {
      this.query["sender-address"] = senderAddress;
      return this;
    }
    txid(txid) {
      this.query.txid = txid;
      return this;
    }
  };

  // node_modules/algosdk/dist/esm/src/client/v2/indexer/searchAccounts.js
  init_jsonrequest();
  var SearchAccounts = class extends JSONRequest {
    path() {
      return "/v2/accounts";
    }
    currencyGreaterThan(greater) {
      this.query["currency-greater-than"] = greater;
      return this;
    }
    currencyLessThan(lesser) {
      this.query["currency-less-than"] = lesser;
      return this;
    }
    limit(limit) {
      this.query.limit = limit;
      return this;
    }
    assetID(id) {
      this.query["asset-id"] = id;
      return this;
    }
    nextToken(nextToken) {
      this.query.next = nextToken;
      return this;
    }
    round(round) {
      this.query.round = round;
      return this;
    }
    authAddr(authAddr) {
      this.query["auth-addr"] = authAddr;
      return this;
    }
    applicationID(applicationID) {
      this.query["application-id"] = applicationID;
      return this;
    }
    includeAll(value = true) {
      this.query["include-all"] = value;
      return this;
    }
  };

  // node_modules/algosdk/dist/esm/src/client/v2/indexer/searchForTransactions.js
  init_jsonrequest();
  var SearchForTransactions = class extends JSONRequest {
    path() {
      return "/v2/transactions";
    }
    notePrefix(prefix) {
      this.query["note-prefix"] = base64StringFunnel(prefix);
      return this;
    }
    txType(type) {
      this.query["tx-type"] = type;
      return this;
    }
    sigType(type) {
      this.query["sig-type"] = type;
      return this;
    }
    txid(txid) {
      this.query.txid = txid;
      return this;
    }
    round(round) {
      this.query.round = round;
      return this;
    }
    minRound(round) {
      this.query["min-round"] = round;
      return this;
    }
    maxRound(round) {
      this.query["max-round"] = round;
      return this;
    }
    assetID(id) {
      this.query["asset-id"] = id;
      return this;
    }
    limit(limit) {
      this.query.limit = limit;
      return this;
    }
    beforeTime(before) {
      this.query["before-time"] = before;
      return this;
    }
    afterTime(after) {
      this.query["after-time"] = after;
      return this;
    }
    currencyGreaterThan(greater) {
      this.query["currency-greater-than"] = greater;
      return this;
    }
    currencyLessThan(lesser) {
      this.query["currency-less-than"] = lesser;
      return this;
    }
    addressRole(role) {
      this.query["address-role"] = role;
      return this;
    }
    address(address) {
      this.query.address = address;
      return this;
    }
    excludeCloseTo(exclude) {
      this.query["exclude-close-to"] = exclude;
      return this;
    }
    nextToken(nextToken) {
      this.query.next = nextToken;
      return this;
    }
    rekeyTo(rekeyTo) {
      this.query["rekey-to"] = rekeyTo;
      return this;
    }
    applicationID(applicationID) {
      this.query["application-id"] = applicationID;
      return this;
    }
  };

  // node_modules/algosdk/dist/esm/src/client/v2/indexer/searchForAssets.js
  init_jsonrequest();
  var SearchForAssets = class extends JSONRequest {
    path() {
      return "/v2/assets";
    }
    limit(limit) {
      this.query.limit = limit;
      return this;
    }
    creator(creator) {
      this.query.creator = creator;
      return this;
    }
    name(name) {
      this.query.name = name;
      return this;
    }
    unit(unit) {
      this.query.unit = unit;
      return this;
    }
    index(index) {
      this.query["asset-id"] = index;
      return this;
    }
    nextToken(nextToken) {
      this.query.next = nextToken;
      return this;
    }
    includeAll(value = true) {
      this.query["include-all"] = value;
      return this;
    }
  };

  // node_modules/algosdk/dist/esm/src/client/v2/indexer/searchForApplications.js
  init_jsonrequest();
  var SearchForApplications = class extends JSONRequest {
    path() {
      return "/v2/applications";
    }
    index(index) {
      this.query["application-id"] = index;
      return this;
    }
    nextToken(next) {
      this.query.next = next;
      return this;
    }
    limit(limit) {
      this.query.limit = limit;
      return this;
    }
    includeAll(value = true) {
      this.query["include-all"] = value;
      return this;
    }
  };

  // node_modules/algosdk/dist/esm/src/client/v2/indexer/indexer.js
  var IndexerClient = class extends ServiceClient {
    constructor(tokenOrBaseClient, baseServer = "http://127.0.0.1", port = 8080, headers = {}) {
      super("X-Indexer-API-Token", tokenOrBaseClient, baseServer, port, headers);
    }
    makeHealthCheck() {
      return new MakeHealthCheck(this.c, this.intDecoding);
    }
    lookupAssetBalances(index) {
      return new LookupAssetBalances(this.c, this.intDecoding, index);
    }
    lookupAssetTransactions(index) {
      return new LookupAssetTransactions(this.c, this.intDecoding, index);
    }
    lookupAccountTransactions(account) {
      return new LookupAccountTransactions(this.c, this.intDecoding, account);
    }
    lookupBlock(round) {
      return new LookupBlock(this.c, this.intDecoding, round);
    }
    lookupTransactionByID(txID) {
      return new LookupTransactionByID(this.c, this.intDecoding, txID);
    }
    lookupAccountByID(account) {
      return new LookupAccountByID(this.c, this.intDecoding, account);
    }
    lookupAssetByID(index) {
      return new LookupAssetByID(this.c, this.intDecoding, index);
    }
    lookupApplications(index) {
      return new LookupApplications(this.c, this.intDecoding, index);
    }
    lookupApplicationLogs(appID) {
      return new LookupApplicationLogs(this.c, this.intDecoding, appID);
    }
    searchAccounts() {
      return new SearchAccounts(this.c, this.intDecoding);
    }
    searchForTransactions() {
      return new SearchForTransactions(this.c, this.intDecoding);
    }
    searchForAssets() {
      return new SearchForAssets(this.c, this.intDecoding);
    }
    searchForApplications() {
      return new SearchForApplications(this.c, this.intDecoding);
    }
  };

  // node_modules/algosdk/dist/esm/src/wait.js
  async function waitForConfirmation(client, txid, waitRounds) {
    const status = await client.status().do();
    if (typeof status === "undefined") {
      throw new Error("Unable to get node status");
    }
    const startRound = status["last-round"] + 1;
    let currentRound = startRound;
    while (currentRound < startRound + waitRounds) {
      let poolError = false;
      try {
        const pendingInfo = await client.pendingTransactionInformation(txid).do();
        if (pendingInfo["confirmed-round"]) {
          return pendingInfo;
        }
        if (pendingInfo["pool-error"]) {
          poolError = true;
          throw new Error(`Transaction Rejected: ${pendingInfo["pool-error"]}`);
        }
      } catch (err) {
        if (poolError) {
          throw err;
        }
      }
      await client.statusAfterBlock(currentRound).do();
      currentRound += 1;
    }
    throw new Error(`Transaction not confirmed after ${waitRounds} rounds`);
  }

  // node_modules/algosdk/dist/esm/src/main.js
  init_address();
  init_uint64();

  // node_modules/algosdk/dist/esm/src/account.js
  init_naclWrappers();
  init_address();
  function generateAccount() {
    const keys = keyPair();
    const encodedPk = encodeAddress(keys.publicKey);
    return { addr: encodedPk, sk: keys.secretKey };
  }

  // node_modules/algosdk/dist/esm/src/client/v2/algod/models/types.js
  var types_exports = {};
  __export(types_exports, {
    Account: () => Account,
    AccountParticipation: () => AccountParticipation,
    AccountStateDelta: () => AccountStateDelta,
    Application: () => Application,
    ApplicationLocalState: () => ApplicationLocalState,
    ApplicationParams: () => ApplicationParams,
    ApplicationStateSchema: () => ApplicationStateSchema,
    Asset: () => Asset,
    AssetHolding: () => AssetHolding,
    AssetParams: () => AssetParams,
    BlockResponse: () => BlockResponse,
    BuildVersion: () => BuildVersion,
    CatchpointAbortResponse: () => CatchpointAbortResponse,
    CatchpointStartResponse: () => CatchpointStartResponse,
    CompileResponse: () => CompileResponse,
    DryrunRequest: () => DryrunRequest,
    DryrunResponse: () => DryrunResponse,
    DryrunSource: () => DryrunSource,
    DryrunState: () => DryrunState,
    DryrunTxnResult: () => DryrunTxnResult,
    ErrorResponse: () => ErrorResponse,
    EvalDelta: () => EvalDelta,
    EvalDeltaKeyValue: () => EvalDeltaKeyValue,
    NodeStatusResponse: () => NodeStatusResponse,
    PendingTransactionResponse: () => PendingTransactionResponse,
    PendingTransactionsResponse: () => PendingTransactionsResponse,
    PostTransactionsResponse: () => PostTransactionsResponse,
    ProofResponse: () => ProofResponse,
    SupplyResponse: () => SupplyResponse,
    TealKeyValue: () => TealKeyValue,
    TealValue: () => TealValue,
    TransactionParametersResponse: () => TransactionParametersResponse,
    Version: () => Version
  });

  // node_modules/algosdk/dist/esm/src/client/v2/algod/models/base.js
  function _is_primitive(val) {
    return val === void 0 || val == null || typeof val !== "object" && typeof val !== "function";
  }
  function _get_obj_for_encoding(val, binary) {
    let targetPropValue;
    if (val instanceof Uint8Array) {
      targetPropValue = binary ? val : Buffer.from(val).toString("base64");
    } else if (typeof val.get_obj_for_encoding === "function") {
      targetPropValue = val.get_obj_for_encoding(binary);
    } else if (Array.isArray(val)) {
      targetPropValue = [];
      for (const elem of val) {
        targetPropValue.push(_get_obj_for_encoding(elem, binary));
      }
    } else if (typeof val === "object") {
      const obj = {};
      for (const prop of Object.keys(val)) {
        obj[prop] = _get_obj_for_encoding(val[prop], binary);
      }
      targetPropValue = obj;
    } else if (_is_primitive(val)) {
      targetPropValue = val;
    } else {
      throw new Error(`Unsupported value: ${String(val)}`);
    }
    return targetPropValue;
  }
  var BaseModel = class {
    get_obj_for_encoding(binary = false) {
      const obj = {};
      for (const prop of Object.keys(this.attribute_map)) {
        const name = this.attribute_map[prop];
        const value = this[prop];
        if (typeof value !== "undefined") {
          obj[name] = value === null ? null : _get_obj_for_encoding(value, binary);
        }
      }
      return obj;
    }
  };

  // node_modules/algosdk/dist/esm/src/client/v2/algod/models/types.js
  var Account = class extends BaseModel {
    constructor({ address, amount, amountWithoutPendingRewards, pendingRewards, rewards, round, status, appsLocalState, appsTotalExtraPages, appsTotalSchema, assets, authAddr, createdApps, createdAssets, participation, rewardBase, sigType }) {
      super();
      this.address = address;
      this.amount = amount;
      this.amountWithoutPendingRewards = amountWithoutPendingRewards;
      this.pendingRewards = pendingRewards;
      this.rewards = rewards;
      this.round = round;
      this.status = status;
      this.appsLocalState = appsLocalState;
      this.appsTotalExtraPages = appsTotalExtraPages;
      this.appsTotalSchema = appsTotalSchema;
      this.assets = assets;
      this.authAddr = authAddr;
      this.createdApps = createdApps;
      this.createdAssets = createdAssets;
      this.participation = participation;
      this.rewardBase = rewardBase;
      this.sigType = sigType;
      this.attribute_map = {
        address: "address",
        amount: "amount",
        amountWithoutPendingRewards: "amount-without-pending-rewards",
        pendingRewards: "pending-rewards",
        rewards: "rewards",
        round: "round",
        status: "status",
        appsLocalState: "apps-local-state",
        appsTotalExtraPages: "apps-total-extra-pages",
        appsTotalSchema: "apps-total-schema",
        assets: "assets",
        authAddr: "auth-addr",
        createdApps: "created-apps",
        createdAssets: "created-assets",
        participation: "participation",
        rewardBase: "reward-base",
        sigType: "sig-type"
      };
    }
  };
  var AccountParticipation = class extends BaseModel {
    constructor({ selectionParticipationKey, voteFirstValid, voteKeyDilution, voteLastValid, voteParticipationKey }) {
      super();
      this.selectionParticipationKey = typeof selectionParticipationKey === "string" ? new Uint8Array(Buffer.from(selectionParticipationKey, "base64")) : selectionParticipationKey;
      this.voteFirstValid = voteFirstValid;
      this.voteKeyDilution = voteKeyDilution;
      this.voteLastValid = voteLastValid;
      this.voteParticipationKey = typeof voteParticipationKey === "string" ? new Uint8Array(Buffer.from(voteParticipationKey, "base64")) : voteParticipationKey;
      this.attribute_map = {
        selectionParticipationKey: "selection-participation-key",
        voteFirstValid: "vote-first-valid",
        voteKeyDilution: "vote-key-dilution",
        voteLastValid: "vote-last-valid",
        voteParticipationKey: "vote-participation-key"
      };
    }
  };
  var AccountStateDelta = class extends BaseModel {
    constructor(address, delta) {
      super();
      this.address = address;
      this.delta = delta;
      this.attribute_map = {
        address: "address",
        delta: "delta"
      };
    }
  };
  var Application = class extends BaseModel {
    constructor(id, params) {
      super();
      this.id = id;
      this.params = params;
      this.attribute_map = {
        id: "id",
        params: "params"
      };
    }
  };
  var ApplicationLocalState = class extends BaseModel {
    constructor(id, schema, keyValue) {
      super();
      this.id = id;
      this.schema = schema;
      this.keyValue = keyValue;
      this.attribute_map = {
        id: "id",
        schema: "schema",
        keyValue: "key-value"
      };
    }
  };
  var ApplicationParams = class extends BaseModel {
    constructor({ approvalProgram, clearStateProgram, creator, extraProgramPages, globalState, globalStateSchema, localStateSchema }) {
      super();
      this.approvalProgram = typeof approvalProgram === "string" ? new Uint8Array(Buffer.from(approvalProgram, "base64")) : approvalProgram;
      this.clearStateProgram = typeof clearStateProgram === "string" ? new Uint8Array(Buffer.from(clearStateProgram, "base64")) : clearStateProgram;
      this.creator = creator;
      this.extraProgramPages = extraProgramPages;
      this.globalState = globalState;
      this.globalStateSchema = globalStateSchema;
      this.localStateSchema = localStateSchema;
      this.attribute_map = {
        approvalProgram: "approval-program",
        clearStateProgram: "clear-state-program",
        creator: "creator",
        extraProgramPages: "extra-program-pages",
        globalState: "global-state",
        globalStateSchema: "global-state-schema",
        localStateSchema: "local-state-schema"
      };
    }
  };
  var ApplicationStateSchema = class extends BaseModel {
    constructor(numUint, numByteSlice) {
      super();
      this.numUint = numUint;
      this.numByteSlice = numByteSlice;
      this.attribute_map = {
        numUint: "num-uint",
        numByteSlice: "num-byte-slice"
      };
    }
  };
  var Asset = class extends BaseModel {
    constructor(index, params) {
      super();
      this.index = index;
      this.params = params;
      this.attribute_map = {
        index: "index",
        params: "params"
      };
    }
  };
  var AssetHolding = class extends BaseModel {
    constructor(amount, assetId, creator, isFrozen) {
      super();
      this.amount = amount;
      this.assetId = assetId;
      this.creator = creator;
      this.isFrozen = isFrozen;
      this.attribute_map = {
        amount: "amount",
        assetId: "asset-id",
        creator: "creator",
        isFrozen: "is-frozen"
      };
    }
  };
  var AssetParams = class extends BaseModel {
    constructor({ creator, decimals, total, clawback, defaultFrozen, freeze, manager, metadataHash, name, nameB64, reserve, unitName, unitNameB64, url, urlB64 }) {
      super();
      this.creator = creator;
      this.decimals = decimals;
      this.total = total;
      this.clawback = clawback;
      this.defaultFrozen = defaultFrozen;
      this.freeze = freeze;
      this.manager = manager;
      this.metadataHash = typeof metadataHash === "string" ? new Uint8Array(Buffer.from(metadataHash, "base64")) : metadataHash;
      this.name = name;
      this.nameB64 = typeof nameB64 === "string" ? new Uint8Array(Buffer.from(nameB64, "base64")) : nameB64;
      this.reserve = reserve;
      this.unitName = unitName;
      this.unitNameB64 = typeof unitNameB64 === "string" ? new Uint8Array(Buffer.from(unitNameB64, "base64")) : unitNameB64;
      this.url = url;
      this.urlB64 = typeof urlB64 === "string" ? new Uint8Array(Buffer.from(urlB64, "base64")) : urlB64;
      this.attribute_map = {
        creator: "creator",
        decimals: "decimals",
        total: "total",
        clawback: "clawback",
        defaultFrozen: "default-frozen",
        freeze: "freeze",
        manager: "manager",
        metadataHash: "metadata-hash",
        name: "name",
        nameB64: "name-b64",
        reserve: "reserve",
        unitName: "unit-name",
        unitNameB64: "unit-name-b64",
        url: "url",
        urlB64: "url-b64"
      };
    }
  };
  var BlockResponse = class extends BaseModel {
    constructor(block, cert) {
      super();
      this.block = block;
      this.cert = cert;
      this.attribute_map = {
        block: "block",
        cert: "cert"
      };
    }
  };
  var BuildVersion = class extends BaseModel {
    constructor({ branch, buildNumber, channel, commitHash, major, minor }) {
      super();
      this.branch = branch;
      this.buildNumber = buildNumber;
      this.channel = channel;
      this.commitHash = commitHash;
      this.major = major;
      this.minor = minor;
      this.attribute_map = {
        branch: "branch",
        buildNumber: "build_number",
        channel: "channel",
        commitHash: "commit_hash",
        major: "major",
        minor: "minor"
      };
    }
  };
  var CatchpointAbortResponse = class extends BaseModel {
    constructor(catchupMessage) {
      super();
      this.catchupMessage = catchupMessage;
      this.attribute_map = {
        catchupMessage: "catchup-message"
      };
    }
  };
  var CatchpointStartResponse = class extends BaseModel {
    constructor(catchupMessage) {
      super();
      this.catchupMessage = catchupMessage;
      this.attribute_map = {
        catchupMessage: "catchup-message"
      };
    }
  };
  var CompileResponse = class extends BaseModel {
    constructor(hash, result) {
      super();
      this.hash = hash;
      this.result = result;
      this.attribute_map = {
        hash: "hash",
        result: "result"
      };
    }
  };
  var DryrunRequest = class extends BaseModel {
    constructor({ accounts, apps, latestTimestamp, protocolVersion, round, sources, txns }) {
      super();
      this.accounts = accounts;
      this.apps = apps;
      this.latestTimestamp = latestTimestamp;
      this.protocolVersion = protocolVersion;
      this.round = round;
      this.sources = sources;
      this.txns = txns;
      this.attribute_map = {
        accounts: "accounts",
        apps: "apps",
        latestTimestamp: "latest-timestamp",
        protocolVersion: "protocol-version",
        round: "round",
        sources: "sources",
        txns: "txns"
      };
    }
  };
  var DryrunResponse = class extends BaseModel {
    constructor(error, protocolVersion, txns) {
      super();
      this.error = error;
      this.protocolVersion = protocolVersion;
      this.txns = txns;
      this.attribute_map = {
        error: "error",
        protocolVersion: "protocol-version",
        txns: "txns"
      };
    }
  };
  var DryrunSource = class extends BaseModel {
    constructor(fieldName, source, txnIndex, appIndex) {
      super();
      this.fieldName = fieldName;
      this.source = source;
      this.txnIndex = txnIndex;
      this.appIndex = appIndex;
      this.attribute_map = {
        fieldName: "field-name",
        source: "source",
        txnIndex: "txn-index",
        appIndex: "app-index"
      };
    }
  };
  var DryrunState = class extends BaseModel {
    constructor({ line, pc, stack, error, scratch }) {
      super();
      this.line = line;
      this.pc = pc;
      this.stack = stack;
      this.error = error;
      this.scratch = scratch;
      this.attribute_map = {
        line: "line",
        pc: "pc",
        stack: "stack",
        error: "error",
        scratch: "scratch"
      };
    }
  };
  var DryrunTxnResult = class extends BaseModel {
    constructor({ disassembly, appCallMessages, appCallTrace, cost, globalDelta, localDeltas, logicSigMessages, logicSigTrace, logs }) {
      super();
      this.disassembly = disassembly;
      this.appCallMessages = appCallMessages;
      this.appCallTrace = appCallTrace;
      this.cost = cost;
      this.globalDelta = globalDelta;
      this.localDeltas = localDeltas;
      this.logicSigMessages = logicSigMessages;
      this.logicSigTrace = logicSigTrace;
      this.logs = logs;
      this.attribute_map = {
        disassembly: "disassembly",
        appCallMessages: "app-call-messages",
        appCallTrace: "app-call-trace",
        cost: "cost",
        globalDelta: "global-delta",
        localDeltas: "local-deltas",
        logicSigMessages: "logic-sig-messages",
        logicSigTrace: "logic-sig-trace",
        logs: "logs"
      };
    }
  };
  var ErrorResponse = class extends BaseModel {
    constructor(message, data) {
      super();
      this.message = message;
      this.data = data;
      this.attribute_map = {
        message: "message",
        data: "data"
      };
    }
  };
  var EvalDelta = class extends BaseModel {
    constructor(action, bytes, uint) {
      super();
      this.action = action;
      this.bytes = bytes;
      this.uint = uint;
      this.attribute_map = {
        action: "action",
        bytes: "bytes",
        uint: "uint"
      };
    }
  };
  var EvalDeltaKeyValue = class extends BaseModel {
    constructor(key, value) {
      super();
      this.key = key;
      this.value = value;
      this.attribute_map = {
        key: "key",
        value: "value"
      };
    }
  };
  var NodeStatusResponse = class extends BaseModel {
    constructor({ catchupTime, lastRound, lastVersion, nextVersion, nextVersionRound, nextVersionSupported, stoppedAtUnsupportedRound, timeSinceLastRound, catchpoint, catchpointAcquiredBlocks, catchpointProcessedAccounts, catchpointTotalAccounts, catchpointTotalBlocks, catchpointVerifiedAccounts, lastCatchpoint }) {
      super();
      this.catchupTime = catchupTime;
      this.lastRound = lastRound;
      this.lastVersion = lastVersion;
      this.nextVersion = nextVersion;
      this.nextVersionRound = nextVersionRound;
      this.nextVersionSupported = nextVersionSupported;
      this.stoppedAtUnsupportedRound = stoppedAtUnsupportedRound;
      this.timeSinceLastRound = timeSinceLastRound;
      this.catchpoint = catchpoint;
      this.catchpointAcquiredBlocks = catchpointAcquiredBlocks;
      this.catchpointProcessedAccounts = catchpointProcessedAccounts;
      this.catchpointTotalAccounts = catchpointTotalAccounts;
      this.catchpointTotalBlocks = catchpointTotalBlocks;
      this.catchpointVerifiedAccounts = catchpointVerifiedAccounts;
      this.lastCatchpoint = lastCatchpoint;
      this.attribute_map = {
        catchupTime: "catchup-time",
        lastRound: "last-round",
        lastVersion: "last-version",
        nextVersion: "next-version",
        nextVersionRound: "next-version-round",
        nextVersionSupported: "next-version-supported",
        stoppedAtUnsupportedRound: "stopped-at-unsupported-round",
        timeSinceLastRound: "time-since-last-round",
        catchpoint: "catchpoint",
        catchpointAcquiredBlocks: "catchpoint-acquired-blocks",
        catchpointProcessedAccounts: "catchpoint-processed-accounts",
        catchpointTotalAccounts: "catchpoint-total-accounts",
        catchpointTotalBlocks: "catchpoint-total-blocks",
        catchpointVerifiedAccounts: "catchpoint-verified-accounts",
        lastCatchpoint: "last-catchpoint"
      };
    }
  };
  var PendingTransactionResponse = class extends BaseModel {
    constructor({ poolError, txn, applicationIndex, assetClosingAmount, assetIndex, closeRewards, closingAmount, confirmedRound, globalStateDelta, innerTxns, localStateDelta, logs, receiverRewards, senderRewards }) {
      super();
      this.poolError = poolError;
      this.txn = txn;
      this.applicationIndex = applicationIndex;
      this.assetClosingAmount = assetClosingAmount;
      this.assetIndex = assetIndex;
      this.closeRewards = closeRewards;
      this.closingAmount = closingAmount;
      this.confirmedRound = confirmedRound;
      this.globalStateDelta = globalStateDelta;
      this.innerTxns = innerTxns;
      this.localStateDelta = localStateDelta;
      this.logs = logs;
      this.receiverRewards = receiverRewards;
      this.senderRewards = senderRewards;
      this.attribute_map = {
        poolError: "pool-error",
        txn: "txn",
        applicationIndex: "application-index",
        assetClosingAmount: "asset-closing-amount",
        assetIndex: "asset-index",
        closeRewards: "close-rewards",
        closingAmount: "closing-amount",
        confirmedRound: "confirmed-round",
        globalStateDelta: "global-state-delta",
        innerTxns: "inner-txns",
        localStateDelta: "local-state-delta",
        logs: "logs",
        receiverRewards: "receiver-rewards",
        senderRewards: "sender-rewards"
      };
    }
  };
  var PendingTransactionsResponse = class extends BaseModel {
    constructor(topTransactions, totalTransactions) {
      super();
      this.topTransactions = topTransactions;
      this.totalTransactions = totalTransactions;
      this.attribute_map = {
        topTransactions: "top-transactions",
        totalTransactions: "total-transactions"
      };
    }
  };
  var PostTransactionsResponse = class extends BaseModel {
    constructor(txid) {
      super();
      this.txid = txid;
      this.attribute_map = {
        txid: "txId"
      };
    }
  };
  var ProofResponse = class extends BaseModel {
    constructor(idx, proof, stibhash) {
      super();
      this.idx = idx;
      this.proof = typeof proof === "string" ? new Uint8Array(Buffer.from(proof, "base64")) : proof;
      this.stibhash = typeof stibhash === "string" ? new Uint8Array(Buffer.from(stibhash, "base64")) : stibhash;
      this.attribute_map = {
        idx: "idx",
        proof: "proof",
        stibhash: "stibhash"
      };
    }
  };
  var SupplyResponse = class extends BaseModel {
    constructor(currentRound, onlineMoney, totalMoney) {
      super();
      this.currentRound = currentRound;
      this.onlineMoney = onlineMoney;
      this.totalMoney = totalMoney;
      this.attribute_map = {
        currentRound: "current_round",
        onlineMoney: "online-money",
        totalMoney: "total-money"
      };
    }
  };
  var TealKeyValue = class extends BaseModel {
    constructor(key, value) {
      super();
      this.key = key;
      this.value = value;
      this.attribute_map = {
        key: "key",
        value: "value"
      };
    }
  };
  var TealValue = class extends BaseModel {
    constructor(type, bytes, uint) {
      super();
      this.type = type;
      this.bytes = bytes;
      this.uint = uint;
      this.attribute_map = {
        type: "type",
        bytes: "bytes",
        uint: "uint"
      };
    }
  };
  var TransactionParametersResponse = class extends BaseModel {
    constructor({ consensusVersion, fee, genesisHash, genesisId, lastRound, minFee }) {
      super();
      this.consensusVersion = consensusVersion;
      this.fee = fee;
      this.genesisHash = typeof genesisHash === "string" ? new Uint8Array(Buffer.from(genesisHash, "base64")) : genesisHash;
      this.genesisId = genesisId;
      this.lastRound = lastRound;
      this.minFee = minFee;
      this.attribute_map = {
        consensusVersion: "consensus-version",
        fee: "fee",
        genesisHash: "genesis-hash",
        genesisId: "genesis-id",
        lastRound: "last-round",
        minFee: "min-fee"
      };
    }
  };
  var Version = class extends BaseModel {
    constructor(build, genesisHashB64, genesisId, versions) {
      super();
      this.build = build;
      this.genesisHashB64 = typeof genesisHashB64 === "string" ? new Uint8Array(Buffer.from(genesisHashB64, "base64")) : genesisHashB64;
      this.genesisId = genesisId;
      this.versions = versions;
      this.attribute_map = {
        build: "build",
        genesisHashB64: "genesis_hash_b64",
        genesisId: "genesis_id",
        versions: "versions"
      };
    }
  };

  // node_modules/algosdk/dist/esm/src/mnemonic/wordlists/english.js
  var english = [
    "abandon",
    "ability",
    "able",
    "about",
    "above",
    "absent",
    "absorb",
    "abstract",
    "absurd",
    "abuse",
    "access",
    "accident",
    "account",
    "accuse",
    "achieve",
    "acid",
    "acoustic",
    "acquire",
    "across",
    "act",
    "action",
    "actor",
    "actress",
    "actual",
    "adapt",
    "add",
    "addict",
    "address",
    "adjust",
    "admit",
    "adult",
    "advance",
    "advice",
    "aerobic",
    "affair",
    "afford",
    "afraid",
    "again",
    "age",
    "agent",
    "agree",
    "ahead",
    "aim",
    "air",
    "airport",
    "aisle",
    "alarm",
    "album",
    "alcohol",
    "alert",
    "alien",
    "all",
    "alley",
    "allow",
    "almost",
    "alone",
    "alpha",
    "already",
    "also",
    "alter",
    "always",
    "amateur",
    "amazing",
    "among",
    "amount",
    "amused",
    "analyst",
    "anchor",
    "ancient",
    "anger",
    "angle",
    "angry",
    "animal",
    "ankle",
    "announce",
    "annual",
    "another",
    "answer",
    "antenna",
    "antique",
    "anxiety",
    "any",
    "apart",
    "apology",
    "appear",
    "apple",
    "approve",
    "april",
    "arch",
    "arctic",
    "area",
    "arena",
    "argue",
    "arm",
    "armed",
    "armor",
    "army",
    "around",
    "arrange",
    "arrest",
    "arrive",
    "arrow",
    "art",
    "artefact",
    "artist",
    "artwork",
    "ask",
    "aspect",
    "assault",
    "asset",
    "assist",
    "assume",
    "asthma",
    "athlete",
    "atom",
    "attack",
    "attend",
    "attitude",
    "attract",
    "auction",
    "audit",
    "august",
    "aunt",
    "author",
    "auto",
    "autumn",
    "average",
    "avocado",
    "avoid",
    "awake",
    "aware",
    "away",
    "awesome",
    "awful",
    "awkward",
    "axis",
    "baby",
    "bachelor",
    "bacon",
    "badge",
    "bag",
    "balance",
    "balcony",
    "ball",
    "bamboo",
    "banana",
    "banner",
    "bar",
    "barely",
    "bargain",
    "barrel",
    "base",
    "basic",
    "basket",
    "battle",
    "beach",
    "bean",
    "beauty",
    "because",
    "become",
    "beef",
    "before",
    "begin",
    "behave",
    "behind",
    "believe",
    "below",
    "belt",
    "bench",
    "benefit",
    "best",
    "betray",
    "better",
    "between",
    "beyond",
    "bicycle",
    "bid",
    "bike",
    "bind",
    "biology",
    "bird",
    "birth",
    "bitter",
    "black",
    "blade",
    "blame",
    "blanket",
    "blast",
    "bleak",
    "bless",
    "blind",
    "blood",
    "blossom",
    "blouse",
    "blue",
    "blur",
    "blush",
    "board",
    "boat",
    "body",
    "boil",
    "bomb",
    "bone",
    "bonus",
    "book",
    "boost",
    "border",
    "boring",
    "borrow",
    "boss",
    "bottom",
    "bounce",
    "box",
    "boy",
    "bracket",
    "brain",
    "brand",
    "brass",
    "brave",
    "bread",
    "breeze",
    "brick",
    "bridge",
    "brief",
    "bright",
    "bring",
    "brisk",
    "broccoli",
    "broken",
    "bronze",
    "broom",
    "brother",
    "brown",
    "brush",
    "bubble",
    "buddy",
    "budget",
    "buffalo",
    "build",
    "bulb",
    "bulk",
    "bullet",
    "bundle",
    "bunker",
    "burden",
    "burger",
    "burst",
    "bus",
    "business",
    "busy",
    "butter",
    "buyer",
    "buzz",
    "cabbage",
    "cabin",
    "cable",
    "cactus",
    "cage",
    "cake",
    "call",
    "calm",
    "camera",
    "camp",
    "can",
    "canal",
    "cancel",
    "candy",
    "cannon",
    "canoe",
    "canvas",
    "canyon",
    "capable",
    "capital",
    "captain",
    "car",
    "carbon",
    "card",
    "cargo",
    "carpet",
    "carry",
    "cart",
    "case",
    "cash",
    "casino",
    "castle",
    "casual",
    "cat",
    "catalog",
    "catch",
    "category",
    "cattle",
    "caught",
    "cause",
    "caution",
    "cave",
    "ceiling",
    "celery",
    "cement",
    "census",
    "century",
    "cereal",
    "certain",
    "chair",
    "chalk",
    "champion",
    "change",
    "chaos",
    "chapter",
    "charge",
    "chase",
    "chat",
    "cheap",
    "check",
    "cheese",
    "chef",
    "cherry",
    "chest",
    "chicken",
    "chief",
    "child",
    "chimney",
    "choice",
    "choose",
    "chronic",
    "chuckle",
    "chunk",
    "churn",
    "cigar",
    "cinnamon",
    "circle",
    "citizen",
    "city",
    "civil",
    "claim",
    "clap",
    "clarify",
    "claw",
    "clay",
    "clean",
    "clerk",
    "clever",
    "click",
    "client",
    "cliff",
    "climb",
    "clinic",
    "clip",
    "clock",
    "clog",
    "close",
    "cloth",
    "cloud",
    "clown",
    "club",
    "clump",
    "cluster",
    "clutch",
    "coach",
    "coast",
    "coconut",
    "code",
    "coffee",
    "coil",
    "coin",
    "collect",
    "color",
    "column",
    "combine",
    "come",
    "comfort",
    "comic",
    "common",
    "company",
    "concert",
    "conduct",
    "confirm",
    "congress",
    "connect",
    "consider",
    "control",
    "convince",
    "cook",
    "cool",
    "copper",
    "copy",
    "coral",
    "core",
    "corn",
    "correct",
    "cost",
    "cotton",
    "couch",
    "country",
    "couple",
    "course",
    "cousin",
    "cover",
    "coyote",
    "crack",
    "cradle",
    "craft",
    "cram",
    "crane",
    "crash",
    "crater",
    "crawl",
    "crazy",
    "cream",
    "credit",
    "creek",
    "crew",
    "cricket",
    "crime",
    "crisp",
    "critic",
    "crop",
    "cross",
    "crouch",
    "crowd",
    "crucial",
    "cruel",
    "cruise",
    "crumble",
    "crunch",
    "crush",
    "cry",
    "crystal",
    "cube",
    "culture",
    "cup",
    "cupboard",
    "curious",
    "current",
    "curtain",
    "curve",
    "cushion",
    "custom",
    "cute",
    "cycle",
    "dad",
    "damage",
    "damp",
    "dance",
    "danger",
    "daring",
    "dash",
    "daughter",
    "dawn",
    "day",
    "deal",
    "debate",
    "debris",
    "decade",
    "december",
    "decide",
    "decline",
    "decorate",
    "decrease",
    "deer",
    "defense",
    "define",
    "defy",
    "degree",
    "delay",
    "deliver",
    "demand",
    "demise",
    "denial",
    "dentist",
    "deny",
    "depart",
    "depend",
    "deposit",
    "depth",
    "deputy",
    "derive",
    "describe",
    "desert",
    "design",
    "desk",
    "despair",
    "destroy",
    "detail",
    "detect",
    "develop",
    "device",
    "devote",
    "diagram",
    "dial",
    "diamond",
    "diary",
    "dice",
    "diesel",
    "diet",
    "differ",
    "digital",
    "dignity",
    "dilemma",
    "dinner",
    "dinosaur",
    "direct",
    "dirt",
    "disagree",
    "discover",
    "disease",
    "dish",
    "dismiss",
    "disorder",
    "display",
    "distance",
    "divert",
    "divide",
    "divorce",
    "dizzy",
    "doctor",
    "document",
    "dog",
    "doll",
    "dolphin",
    "domain",
    "donate",
    "donkey",
    "donor",
    "door",
    "dose",
    "double",
    "dove",
    "draft",
    "dragon",
    "drama",
    "drastic",
    "draw",
    "dream",
    "dress",
    "drift",
    "drill",
    "drink",
    "drip",
    "drive",
    "drop",
    "drum",
    "dry",
    "duck",
    "dumb",
    "dune",
    "during",
    "dust",
    "dutch",
    "duty",
    "dwarf",
    "dynamic",
    "eager",
    "eagle",
    "early",
    "earn",
    "earth",
    "easily",
    "east",
    "easy",
    "echo",
    "ecology",
    "economy",
    "edge",
    "edit",
    "educate",
    "effort",
    "egg",
    "eight",
    "either",
    "elbow",
    "elder",
    "electric",
    "elegant",
    "element",
    "elephant",
    "elevator",
    "elite",
    "else",
    "embark",
    "embody",
    "embrace",
    "emerge",
    "emotion",
    "employ",
    "empower",
    "empty",
    "enable",
    "enact",
    "end",
    "endless",
    "endorse",
    "enemy",
    "energy",
    "enforce",
    "engage",
    "engine",
    "enhance",
    "enjoy",
    "enlist",
    "enough",
    "enrich",
    "enroll",
    "ensure",
    "enter",
    "entire",
    "entry",
    "envelope",
    "episode",
    "equal",
    "equip",
    "era",
    "erase",
    "erode",
    "erosion",
    "error",
    "erupt",
    "escape",
    "essay",
    "essence",
    "estate",
    "eternal",
    "ethics",
    "evidence",
    "evil",
    "evoke",
    "evolve",
    "exact",
    "example",
    "excess",
    "exchange",
    "excite",
    "exclude",
    "excuse",
    "execute",
    "exercise",
    "exhaust",
    "exhibit",
    "exile",
    "exist",
    "exit",
    "exotic",
    "expand",
    "expect",
    "expire",
    "explain",
    "expose",
    "express",
    "extend",
    "extra",
    "eye",
    "eyebrow",
    "fabric",
    "face",
    "faculty",
    "fade",
    "faint",
    "faith",
    "fall",
    "false",
    "fame",
    "family",
    "famous",
    "fan",
    "fancy",
    "fantasy",
    "farm",
    "fashion",
    "fat",
    "fatal",
    "father",
    "fatigue",
    "fault",
    "favorite",
    "feature",
    "february",
    "federal",
    "fee",
    "feed",
    "feel",
    "female",
    "fence",
    "festival",
    "fetch",
    "fever",
    "few",
    "fiber",
    "fiction",
    "field",
    "figure",
    "file",
    "film",
    "filter",
    "final",
    "find",
    "fine",
    "finger",
    "finish",
    "fire",
    "firm",
    "first",
    "fiscal",
    "fish",
    "fit",
    "fitness",
    "fix",
    "flag",
    "flame",
    "flash",
    "flat",
    "flavor",
    "flee",
    "flight",
    "flip",
    "float",
    "flock",
    "floor",
    "flower",
    "fluid",
    "flush",
    "fly",
    "foam",
    "focus",
    "fog",
    "foil",
    "fold",
    "follow",
    "food",
    "foot",
    "force",
    "forest",
    "forget",
    "fork",
    "fortune",
    "forum",
    "forward",
    "fossil",
    "foster",
    "found",
    "fox",
    "fragile",
    "frame",
    "frequent",
    "fresh",
    "friend",
    "fringe",
    "frog",
    "front",
    "frost",
    "frown",
    "frozen",
    "fruit",
    "fuel",
    "fun",
    "funny",
    "furnace",
    "fury",
    "future",
    "gadget",
    "gain",
    "galaxy",
    "gallery",
    "game",
    "gap",
    "garage",
    "garbage",
    "garden",
    "garlic",
    "garment",
    "gas",
    "gasp",
    "gate",
    "gather",
    "gauge",
    "gaze",
    "general",
    "genius",
    "genre",
    "gentle",
    "genuine",
    "gesture",
    "ghost",
    "giant",
    "gift",
    "giggle",
    "ginger",
    "giraffe",
    "girl",
    "give",
    "glad",
    "glance",
    "glare",
    "glass",
    "glide",
    "glimpse",
    "globe",
    "gloom",
    "glory",
    "glove",
    "glow",
    "glue",
    "goat",
    "goddess",
    "gold",
    "good",
    "goose",
    "gorilla",
    "gospel",
    "gossip",
    "govern",
    "gown",
    "grab",
    "grace",
    "grain",
    "grant",
    "grape",
    "grass",
    "gravity",
    "great",
    "green",
    "grid",
    "grief",
    "grit",
    "grocery",
    "group",
    "grow",
    "grunt",
    "guard",
    "guess",
    "guide",
    "guilt",
    "guitar",
    "gun",
    "gym",
    "habit",
    "hair",
    "half",
    "hammer",
    "hamster",
    "hand",
    "happy",
    "harbor",
    "hard",
    "harsh",
    "harvest",
    "hat",
    "have",
    "hawk",
    "hazard",
    "head",
    "health",
    "heart",
    "heavy",
    "hedgehog",
    "height",
    "hello",
    "helmet",
    "help",
    "hen",
    "hero",
    "hidden",
    "high",
    "hill",
    "hint",
    "hip",
    "hire",
    "history",
    "hobby",
    "hockey",
    "hold",
    "hole",
    "holiday",
    "hollow",
    "home",
    "honey",
    "hood",
    "hope",
    "horn",
    "horror",
    "horse",
    "hospital",
    "host",
    "hotel",
    "hour",
    "hover",
    "hub",
    "huge",
    "human",
    "humble",
    "humor",
    "hundred",
    "hungry",
    "hunt",
    "hurdle",
    "hurry",
    "hurt",
    "husband",
    "hybrid",
    "ice",
    "icon",
    "idea",
    "identify",
    "idle",
    "ignore",
    "ill",
    "illegal",
    "illness",
    "image",
    "imitate",
    "immense",
    "immune",
    "impact",
    "impose",
    "improve",
    "impulse",
    "inch",
    "include",
    "income",
    "increase",
    "index",
    "indicate",
    "indoor",
    "industry",
    "infant",
    "inflict",
    "inform",
    "inhale",
    "inherit",
    "initial",
    "inject",
    "injury",
    "inmate",
    "inner",
    "innocent",
    "input",
    "inquiry",
    "insane",
    "insect",
    "inside",
    "inspire",
    "install",
    "intact",
    "interest",
    "into",
    "invest",
    "invite",
    "involve",
    "iron",
    "island",
    "isolate",
    "issue",
    "item",
    "ivory",
    "jacket",
    "jaguar",
    "jar",
    "jazz",
    "jealous",
    "jeans",
    "jelly",
    "jewel",
    "job",
    "join",
    "joke",
    "journey",
    "joy",
    "judge",
    "juice",
    "jump",
    "jungle",
    "junior",
    "junk",
    "just",
    "kangaroo",
    "keen",
    "keep",
    "ketchup",
    "key",
    "kick",
    "kid",
    "kidney",
    "kind",
    "kingdom",
    "kiss",
    "kit",
    "kitchen",
    "kite",
    "kitten",
    "kiwi",
    "knee",
    "knife",
    "knock",
    "know",
    "lab",
    "label",
    "labor",
    "ladder",
    "lady",
    "lake",
    "lamp",
    "language",
    "laptop",
    "large",
    "later",
    "latin",
    "laugh",
    "laundry",
    "lava",
    "law",
    "lawn",
    "lawsuit",
    "layer",
    "lazy",
    "leader",
    "leaf",
    "learn",
    "leave",
    "lecture",
    "left",
    "leg",
    "legal",
    "legend",
    "leisure",
    "lemon",
    "lend",
    "length",
    "lens",
    "leopard",
    "lesson",
    "letter",
    "level",
    "liar",
    "liberty",
    "library",
    "license",
    "life",
    "lift",
    "light",
    "like",
    "limb",
    "limit",
    "link",
    "lion",
    "liquid",
    "list",
    "little",
    "live",
    "lizard",
    "load",
    "loan",
    "lobster",
    "local",
    "lock",
    "logic",
    "lonely",
    "long",
    "loop",
    "lottery",
    "loud",
    "lounge",
    "love",
    "loyal",
    "lucky",
    "luggage",
    "lumber",
    "lunar",
    "lunch",
    "luxury",
    "lyrics",
    "machine",
    "mad",
    "magic",
    "magnet",
    "maid",
    "mail",
    "main",
    "major",
    "make",
    "mammal",
    "man",
    "manage",
    "mandate",
    "mango",
    "mansion",
    "manual",
    "maple",
    "marble",
    "march",
    "margin",
    "marine",
    "market",
    "marriage",
    "mask",
    "mass",
    "master",
    "match",
    "material",
    "math",
    "matrix",
    "matter",
    "maximum",
    "maze",
    "meadow",
    "mean",
    "measure",
    "meat",
    "mechanic",
    "medal",
    "media",
    "melody",
    "melt",
    "member",
    "memory",
    "mention",
    "menu",
    "mercy",
    "merge",
    "merit",
    "merry",
    "mesh",
    "message",
    "metal",
    "method",
    "middle",
    "midnight",
    "milk",
    "million",
    "mimic",
    "mind",
    "minimum",
    "minor",
    "minute",
    "miracle",
    "mirror",
    "misery",
    "miss",
    "mistake",
    "mix",
    "mixed",
    "mixture",
    "mobile",
    "model",
    "modify",
    "mom",
    "moment",
    "monitor",
    "monkey",
    "monster",
    "month",
    "moon",
    "moral",
    "more",
    "morning",
    "mosquito",
    "mother",
    "motion",
    "motor",
    "mountain",
    "mouse",
    "move",
    "movie",
    "much",
    "muffin",
    "mule",
    "multiply",
    "muscle",
    "museum",
    "mushroom",
    "music",
    "must",
    "mutual",
    "myself",
    "mystery",
    "myth",
    "naive",
    "name",
    "napkin",
    "narrow",
    "nasty",
    "nation",
    "nature",
    "near",
    "neck",
    "need",
    "negative",
    "neglect",
    "neither",
    "nephew",
    "nerve",
    "nest",
    "net",
    "network",
    "neutral",
    "never",
    "news",
    "next",
    "nice",
    "night",
    "noble",
    "noise",
    "nominee",
    "noodle",
    "normal",
    "north",
    "nose",
    "notable",
    "note",
    "nothing",
    "notice",
    "novel",
    "now",
    "nuclear",
    "number",
    "nurse",
    "nut",
    "oak",
    "obey",
    "object",
    "oblige",
    "obscure",
    "observe",
    "obtain",
    "obvious",
    "occur",
    "ocean",
    "october",
    "odor",
    "off",
    "offer",
    "office",
    "often",
    "oil",
    "okay",
    "old",
    "olive",
    "olympic",
    "omit",
    "once",
    "one",
    "onion",
    "online",
    "only",
    "open",
    "opera",
    "opinion",
    "oppose",
    "option",
    "orange",
    "orbit",
    "orchard",
    "order",
    "ordinary",
    "organ",
    "orient",
    "original",
    "orphan",
    "ostrich",
    "other",
    "outdoor",
    "outer",
    "output",
    "outside",
    "oval",
    "oven",
    "over",
    "own",
    "owner",
    "oxygen",
    "oyster",
    "ozone",
    "pact",
    "paddle",
    "page",
    "pair",
    "palace",
    "palm",
    "panda",
    "panel",
    "panic",
    "panther",
    "paper",
    "parade",
    "parent",
    "park",
    "parrot",
    "party",
    "pass",
    "patch",
    "path",
    "patient",
    "patrol",
    "pattern",
    "pause",
    "pave",
    "payment",
    "peace",
    "peanut",
    "pear",
    "peasant",
    "pelican",
    "pen",
    "penalty",
    "pencil",
    "people",
    "pepper",
    "perfect",
    "permit",
    "person",
    "pet",
    "phone",
    "photo",
    "phrase",
    "physical",
    "piano",
    "picnic",
    "picture",
    "piece",
    "pig",
    "pigeon",
    "pill",
    "pilot",
    "pink",
    "pioneer",
    "pipe",
    "pistol",
    "pitch",
    "pizza",
    "place",
    "planet",
    "plastic",
    "plate",
    "play",
    "please",
    "pledge",
    "pluck",
    "plug",
    "plunge",
    "poem",
    "poet",
    "point",
    "polar",
    "pole",
    "police",
    "pond",
    "pony",
    "pool",
    "popular",
    "portion",
    "position",
    "possible",
    "post",
    "potato",
    "pottery",
    "poverty",
    "powder",
    "power",
    "practice",
    "praise",
    "predict",
    "prefer",
    "prepare",
    "present",
    "pretty",
    "prevent",
    "price",
    "pride",
    "primary",
    "print",
    "priority",
    "prison",
    "private",
    "prize",
    "problem",
    "process",
    "produce",
    "profit",
    "program",
    "project",
    "promote",
    "proof",
    "property",
    "prosper",
    "protect",
    "proud",
    "provide",
    "public",
    "pudding",
    "pull",
    "pulp",
    "pulse",
    "pumpkin",
    "punch",
    "pupil",
    "puppy",
    "purchase",
    "purity",
    "purpose",
    "purse",
    "push",
    "put",
    "puzzle",
    "pyramid",
    "quality",
    "quantum",
    "quarter",
    "question",
    "quick",
    "quit",
    "quiz",
    "quote",
    "rabbit",
    "raccoon",
    "race",
    "rack",
    "radar",
    "radio",
    "rail",
    "rain",
    "raise",
    "rally",
    "ramp",
    "ranch",
    "random",
    "range",
    "rapid",
    "rare",
    "rate",
    "rather",
    "raven",
    "raw",
    "razor",
    "ready",
    "real",
    "reason",
    "rebel",
    "rebuild",
    "recall",
    "receive",
    "recipe",
    "record",
    "recycle",
    "reduce",
    "reflect",
    "reform",
    "refuse",
    "region",
    "regret",
    "regular",
    "reject",
    "relax",
    "release",
    "relief",
    "rely",
    "remain",
    "remember",
    "remind",
    "remove",
    "render",
    "renew",
    "rent",
    "reopen",
    "repair",
    "repeat",
    "replace",
    "report",
    "require",
    "rescue",
    "resemble",
    "resist",
    "resource",
    "response",
    "result",
    "retire",
    "retreat",
    "return",
    "reunion",
    "reveal",
    "review",
    "reward",
    "rhythm",
    "rib",
    "ribbon",
    "rice",
    "rich",
    "ride",
    "ridge",
    "rifle",
    "right",
    "rigid",
    "ring",
    "riot",
    "ripple",
    "risk",
    "ritual",
    "rival",
    "river",
    "road",
    "roast",
    "robot",
    "robust",
    "rocket",
    "romance",
    "roof",
    "rookie",
    "room",
    "rose",
    "rotate",
    "rough",
    "round",
    "route",
    "royal",
    "rubber",
    "rude",
    "rug",
    "rule",
    "run",
    "runway",
    "rural",
    "sad",
    "saddle",
    "sadness",
    "safe",
    "sail",
    "salad",
    "salmon",
    "salon",
    "salt",
    "salute",
    "same",
    "sample",
    "sand",
    "satisfy",
    "satoshi",
    "sauce",
    "sausage",
    "save",
    "say",
    "scale",
    "scan",
    "scare",
    "scatter",
    "scene",
    "scheme",
    "school",
    "science",
    "scissors",
    "scorpion",
    "scout",
    "scrap",
    "screen",
    "script",
    "scrub",
    "sea",
    "search",
    "season",
    "seat",
    "second",
    "secret",
    "section",
    "security",
    "seed",
    "seek",
    "segment",
    "select",
    "sell",
    "seminar",
    "senior",
    "sense",
    "sentence",
    "series",
    "service",
    "session",
    "settle",
    "setup",
    "seven",
    "shadow",
    "shaft",
    "shallow",
    "share",
    "shed",
    "shell",
    "sheriff",
    "shield",
    "shift",
    "shine",
    "ship",
    "shiver",
    "shock",
    "shoe",
    "shoot",
    "shop",
    "short",
    "shoulder",
    "shove",
    "shrimp",
    "shrug",
    "shuffle",
    "shy",
    "sibling",
    "sick",
    "side",
    "siege",
    "sight",
    "sign",
    "silent",
    "silk",
    "silly",
    "silver",
    "similar",
    "simple",
    "since",
    "sing",
    "siren",
    "sister",
    "situate",
    "six",
    "size",
    "skate",
    "sketch",
    "ski",
    "skill",
    "skin",
    "skirt",
    "skull",
    "slab",
    "slam",
    "sleep",
    "slender",
    "slice",
    "slide",
    "slight",
    "slim",
    "slogan",
    "slot",
    "slow",
    "slush",
    "small",
    "smart",
    "smile",
    "smoke",
    "smooth",
    "snack",
    "snake",
    "snap",
    "sniff",
    "snow",
    "soap",
    "soccer",
    "social",
    "sock",
    "soda",
    "soft",
    "solar",
    "soldier",
    "solid",
    "solution",
    "solve",
    "someone",
    "song",
    "soon",
    "sorry",
    "sort",
    "soul",
    "sound",
    "soup",
    "source",
    "south",
    "space",
    "spare",
    "spatial",
    "spawn",
    "speak",
    "special",
    "speed",
    "spell",
    "spend",
    "sphere",
    "spice",
    "spider",
    "spike",
    "spin",
    "spirit",
    "split",
    "spoil",
    "sponsor",
    "spoon",
    "sport",
    "spot",
    "spray",
    "spread",
    "spring",
    "spy",
    "square",
    "squeeze",
    "squirrel",
    "stable",
    "stadium",
    "staff",
    "stage",
    "stairs",
    "stamp",
    "stand",
    "start",
    "state",
    "stay",
    "steak",
    "steel",
    "stem",
    "step",
    "stereo",
    "stick",
    "still",
    "sting",
    "stock",
    "stomach",
    "stone",
    "stool",
    "story",
    "stove",
    "strategy",
    "street",
    "strike",
    "strong",
    "struggle",
    "student",
    "stuff",
    "stumble",
    "style",
    "subject",
    "submit",
    "subway",
    "success",
    "such",
    "sudden",
    "suffer",
    "sugar",
    "suggest",
    "suit",
    "summer",
    "sun",
    "sunny",
    "sunset",
    "super",
    "supply",
    "supreme",
    "sure",
    "surface",
    "surge",
    "surprise",
    "surround",
    "survey",
    "suspect",
    "sustain",
    "swallow",
    "swamp",
    "swap",
    "swarm",
    "swear",
    "sweet",
    "swift",
    "swim",
    "swing",
    "switch",
    "sword",
    "symbol",
    "symptom",
    "syrup",
    "system",
    "table",
    "tackle",
    "tag",
    "tail",
    "talent",
    "talk",
    "tank",
    "tape",
    "target",
    "task",
    "taste",
    "tattoo",
    "taxi",
    "teach",
    "team",
    "tell",
    "ten",
    "tenant",
    "tennis",
    "tent",
    "term",
    "test",
    "text",
    "thank",
    "that",
    "theme",
    "then",
    "theory",
    "there",
    "they",
    "thing",
    "this",
    "thought",
    "three",
    "thrive",
    "throw",
    "thumb",
    "thunder",
    "ticket",
    "tide",
    "tiger",
    "tilt",
    "timber",
    "time",
    "tiny",
    "tip",
    "tired",
    "tissue",
    "title",
    "toast",
    "tobacco",
    "today",
    "toddler",
    "toe",
    "together",
    "toilet",
    "token",
    "tomato",
    "tomorrow",
    "tone",
    "tongue",
    "tonight",
    "tool",
    "tooth",
    "top",
    "topic",
    "topple",
    "torch",
    "tornado",
    "tortoise",
    "toss",
    "total",
    "tourist",
    "toward",
    "tower",
    "town",
    "toy",
    "track",
    "trade",
    "traffic",
    "tragic",
    "train",
    "transfer",
    "trap",
    "trash",
    "travel",
    "tray",
    "treat",
    "tree",
    "trend",
    "trial",
    "tribe",
    "trick",
    "trigger",
    "trim",
    "trip",
    "trophy",
    "trouble",
    "truck",
    "true",
    "truly",
    "trumpet",
    "trust",
    "truth",
    "try",
    "tube",
    "tuition",
    "tumble",
    "tuna",
    "tunnel",
    "turkey",
    "turn",
    "turtle",
    "twelve",
    "twenty",
    "twice",
    "twin",
    "twist",
    "two",
    "type",
    "typical",
    "ugly",
    "umbrella",
    "unable",
    "unaware",
    "uncle",
    "uncover",
    "under",
    "undo",
    "unfair",
    "unfold",
    "unhappy",
    "uniform",
    "unique",
    "unit",
    "universe",
    "unknown",
    "unlock",
    "until",
    "unusual",
    "unveil",
    "update",
    "upgrade",
    "uphold",
    "upon",
    "upper",
    "upset",
    "urban",
    "urge",
    "usage",
    "use",
    "used",
    "useful",
    "useless",
    "usual",
    "utility",
    "vacant",
    "vacuum",
    "vague",
    "valid",
    "valley",
    "valve",
    "van",
    "vanish",
    "vapor",
    "various",
    "vast",
    "vault",
    "vehicle",
    "velvet",
    "vendor",
    "venture",
    "venue",
    "verb",
    "verify",
    "version",
    "very",
    "vessel",
    "veteran",
    "viable",
    "vibrant",
    "vicious",
    "victory",
    "video",
    "view",
    "village",
    "vintage",
    "violin",
    "virtual",
    "virus",
    "visa",
    "visit",
    "visual",
    "vital",
    "vivid",
    "vocal",
    "voice",
    "void",
    "volcano",
    "volume",
    "vote",
    "voyage",
    "wage",
    "wagon",
    "wait",
    "walk",
    "wall",
    "walnut",
    "want",
    "warfare",
    "warm",
    "warrior",
    "wash",
    "wasp",
    "waste",
    "water",
    "wave",
    "way",
    "wealth",
    "weapon",
    "wear",
    "weasel",
    "weather",
    "web",
    "wedding",
    "weekend",
    "weird",
    "welcome",
    "west",
    "wet",
    "whale",
    "what",
    "wheat",
    "wheel",
    "when",
    "where",
    "whip",
    "whisper",
    "wide",
    "width",
    "wife",
    "wild",
    "will",
    "win",
    "window",
    "wine",
    "wing",
    "wink",
    "winner",
    "winter",
    "wire",
    "wisdom",
    "wise",
    "wish",
    "witness",
    "wolf",
    "woman",
    "wonder",
    "wood",
    "wool",
    "word",
    "work",
    "world",
    "worry",
    "worth",
    "wrap",
    "wreck",
    "wrestle",
    "wrist",
    "write",
    "wrong",
    "yard",
    "year",
    "yellow",
    "you",
    "young",
    "youth",
    "zebra",
    "zero",
    "zone",
    "zoo"
  ];
  var english_default = english;

  // node_modules/algosdk/dist/esm/src/mnemonic/mnemonic.js
  init_naclWrappers();
  init_address();
  var FAIL_TO_DECODE_MNEMONIC_ERROR_MSG = "failed to decode mnemonic";
  var NOT_IN_WORDS_LIST_ERROR_MSG = "the mnemonic contains a word that is not in the wordlist";
  function toUint11Array(buffer8) {
    const buffer11 = [];
    let acc = 0;
    let accBits = 0;
    function add(octet) {
      acc |= octet << accBits;
      accBits += 8;
      if (accBits >= 11) {
        buffer11.push(acc & 2047);
        acc >>= 11;
        accBits -= 11;
      }
    }
    function flush() {
      if (accBits) {
        buffer11.push(acc);
      }
    }
    buffer8.forEach(add);
    flush();
    return buffer11;
  }
  function applyWords(nums) {
    return nums.map((n) => english_default[n]);
  }
  function computeChecksum(seed) {
    const hashBuffer = genericHash(seed);
    const uint11Hash = toUint11Array(hashBuffer);
    const words = applyWords(uint11Hash);
    return words[0];
  }
  function mnemonicFromSeed(seed) {
    if (seed.length !== SEED_BTYES_LENGTH) {
      throw new RangeError(`Seed length must be ${SEED_BTYES_LENGTH}`);
    }
    const uint11Array = toUint11Array(seed);
    const words = applyWords(uint11Array);
    const checksumWord = computeChecksum(seed);
    return `${words.join(" ")} ${checksumWord}`;
  }
  function toUint8Array(buffer11) {
    const buffer8 = [];
    let acc = 0;
    let accBits = 0;
    function add(ui11) {
      acc |= ui11 << accBits;
      accBits += 11;
      while (accBits >= 8) {
        buffer8.push(acc & 255);
        acc >>= 8;
        accBits -= 8;
      }
    }
    function flush() {
      if (accBits) {
        buffer8.push(acc);
      }
    }
    buffer11.forEach(add);
    flush();
    return new Uint8Array(buffer8);
  }
  function seedFromMnemonic(mnemonic) {
    const words = mnemonic.split(" ");
    const key = words.slice(0, 24);
    for (const w of key) {
      if (english_default.indexOf(w) === -1)
        throw new Error(NOT_IN_WORDS_LIST_ERROR_MSG);
    }
    const checksum = words[words.length - 1];
    const uint11Array = key.map((word) => english_default.indexOf(word));
    let uint8Array = toUint8Array(uint11Array);
    if (uint8Array.length !== 33)
      throw new Error(FAIL_TO_DECODE_MNEMONIC_ERROR_MSG);
    if (uint8Array[uint8Array.length - 1] !== 0)
      throw new Error(FAIL_TO_DECODE_MNEMONIC_ERROR_MSG);
    uint8Array = uint8Array.slice(0, uint8Array.length - 1);
    const cs = computeChecksum(uint8Array);
    if (cs === checksum)
      return uint8Array;
    throw new Error(FAIL_TO_DECODE_MNEMONIC_ERROR_MSG);
  }
  function mnemonicToSecretKey(mn) {
    const seed = seedFromMnemonic(mn);
    const keys = keyPairFromSeed(seed);
    const encodedPk = encodeAddress(keys.publicKey);
    return { addr: encodedPk, sk: keys.secretKey };
  }
  function secretKeyToMnemonic(sk) {
    const seed = sk.slice(0, SEED_BTYES_LENGTH);
    return mnemonicFromSeed(seed);
  }
  function mnemonicToMasterDerivationKey(mn) {
    return seedFromMnemonic(mn);
  }
  function masterDerivationKeyToMnemonic(mdk) {
    return mnemonicFromSeed(mdk);
  }

  // node_modules/algosdk/dist/esm/src/main.js
  init_group();
  init_logicsig();
  init_multisig();

  // node_modules/algosdk/dist/esm/src/dryrun.js
  init_transactions();
  init_address();
  var defaultAppId = 1380011588;
  function decodePrograms(ap) {
    ap.params["approval-program"] = Buffer.from(ap.params["approval-program"].toString(), "base64");
    ap.params["clear-state-program"] = Buffer.from(ap.params["clear-state-program"].toString(), "base64");
    return ap;
  }
  async function createDryrun({ client, txns, protocolVersion, latestTimestamp, round, sources }) {
    const appInfos = [];
    const acctInfos = [];
    const apps = [];
    const assets = [];
    const accts = [];
    for (const t of txns) {
      if (t.txn.type === TransactionType.appl) {
        accts.push(encodeAddress(t.txn.from.publicKey));
        if (t.txn.appAccounts)
          accts.push(...t.txn.appAccounts.map((a) => encodeAddress(a.publicKey)));
        if (t.txn.appForeignApps)
          apps.push(...t.txn.appForeignApps);
        if (t.txn.appForeignAssets)
          assets.push(...t.txn.appForeignAssets);
        if (t.txn.appIndex === 0) {
          appInfos.push(new Application(defaultAppId, new ApplicationParams({
            creator: encodeAddress(t.txn.from.publicKey),
            approvalProgram: t.txn.appApprovalProgram,
            clearStateProgram: t.txn.appClearProgram,
            localStateSchema: new ApplicationStateSchema(t.txn.appLocalInts, t.txn.appLocalByteSlices),
            globalStateSchema: new ApplicationStateSchema(t.txn.appGlobalInts, t.txn.appGlobalByteSlices)
          })));
        } else {
          apps.push(t.txn.appIndex);
          accts.push(getApplicationAddress(t.txn.appIndex));
        }
      }
    }
    const assetPromises = [];
    for (const assetId of [...new Set(assets)]) {
      assetPromises.push(client.getAssetByID(assetId).do().then((assetInfo) => {
        accts.push(assetInfo.params.creator);
      }));
    }
    await Promise.all(assetPromises);
    const appPromises = [];
    for (const appId of [...new Set(apps)]) {
      appPromises.push(client.getApplicationByID(appId).do().then((appInfo) => {
        const ai = decodePrograms(appInfo);
        appInfos.push(ai);
        accts.push(ai.params.creator);
      }));
    }
    await Promise.all(appPromises);
    const acctPromises = [];
    for (const acct of [...new Set(accts)]) {
      acctPromises.push(client.accountInformation(acct).do().then((acctInfo) => {
        if ("created-apps" in acctInfo) {
          acctInfo["created-apps"] = acctInfo["created-apps"].map((app) => decodePrograms(app));
        }
        acctInfos.push(acctInfo);
      }));
    }
    await Promise.all(acctPromises);
    return new DryrunRequest({
      txns: txns.map((st) => __spreadProps(__spreadValues({}, st), { txn: st.txn.get_obj_for_encoding() })),
      accounts: acctInfos,
      apps: appInfos,
      latestTimestamp,
      round,
      protocolVersion,
      sources
    });
  }

  // node_modules/algosdk/dist/esm/src/main.js
  init_makeTxn();
  init_transaction();

  // node_modules/algosdk/dist/esm/src/signer.js
  init_logicsig();
  init_multisig();
  function makeBasicAccountTransactionSigner(account) {
    return (txnGroup, indexesToSign) => {
      const signed = [];
      for (const index of indexesToSign) {
        signed.push(txnGroup[index].signTxn(account.sk));
      }
      return Promise.resolve(signed);
    };
  }
  function makeLogicSigAccountTransactionSigner(account) {
    return (txnGroup, indexesToSign) => {
      const signed = [];
      for (const index of indexesToSign) {
        const { blob } = signLogicSigTransactionObject(txnGroup[index], account);
        signed.push(blob);
      }
      return Promise.resolve(signed);
    };
  }
  function makeMultiSigAccountTransactionSigner(msig, sks) {
    return (txnGroup, indexesToSign) => {
      const signed = [];
      for (const index of indexesToSign) {
        const txn = txnGroup[index];
        const partialSigs = [];
        for (const sk of sks) {
          const { blob } = signMultisigTransaction(txn, msig, sk);
          partialSigs.push(blob);
        }
        signed.push(mergeMultisigTransactions(partialSigs));
      }
      return Promise.resolve(signed);
    };
  }
  function isTransactionWithSigner(value) {
    return typeof value === "object" && Object.keys(value).length === 2 && typeof value.txn === "object" && typeof value.signer === "function";
  }

  // node_modules/algosdk/dist/esm/src/abi/abi_type.js
  init_address();

  // node_modules/algosdk/dist/esm/src/encoding/bigint.js
  function bigIntToBytes(bi, size) {
    let hex = bi.toString(16);
    if (hex.length !== size * 2) {
      hex = hex.padStart(size * 2, "0");
    }
    const byteArray = new Uint8Array(hex.length / 2);
    for (let i = 0, j = 0; i < hex.length / 2; i++, j += 2) {
      byteArray[i] = parseInt(hex.slice(j, j + 2), 16);
    }
    return byteArray;
  }
  function bytesToBigInt(bytes) {
    let res = BigInt(0);
    const buf = Buffer.from(bytes);
    for (let i = 0; i < bytes.length; i++) {
      res = BigInt(Number(buf.readUIntBE(i, 1))) + res * BigInt(256);
    }
    return res;
  }

  // node_modules/algosdk/dist/esm/src/abi/abi_type.js
  init_utils();
  var MAX_LEN = 2 ** 16 - 1;
  var ADDR_BYTE_SIZE = 32;
  var SINGLE_BYTE_SIZE = 1;
  var SINGLE_BOOL_SIZE = 1;
  var LENGTH_ENCODE_BYTE_SIZE = 2;
  var staticArrayRegexp = /^([a-z\d[\](),]+)\[([1-9][\d]*)]$/;
  var ufixedRegexp = /^ufixed([1-9][\d]*)x([1-9][\d]*)$/;
  var ABIType = class {
    static from(str) {
      if (str.endsWith("[]")) {
        const arrayArgType = ABIType.from(str.slice(0, str.length - 2));
        return new ABIArrayDynamicType(arrayArgType);
      }
      if (str.endsWith("]")) {
        const stringMatches = str.match(staticArrayRegexp);
        if (stringMatches.length !== 3) {
          throw new Error(`malformed static array string: ${str}`);
        }
        const arrayLengthStr = stringMatches[2];
        const arrayLength = parseInt(arrayLengthStr, 10);
        if (arrayLength > MAX_LEN) {
          throw new Error(`array length exceeds limit ${MAX_LEN}`);
        }
        const arrayType = ABIType.from(stringMatches[1]);
        return new ABIArrayStaticType(arrayType, arrayLength);
      }
      if (str.startsWith("uint")) {
        const digitsOnly = (string) => [...string].every((c) => "0123456789".includes(c));
        const typeSizeStr = str.slice(4, str.length);
        if (!digitsOnly(typeSizeStr)) {
          throw new Error(`malformed uint string: ${typeSizeStr}`);
        }
        const typeSize = parseInt(typeSizeStr, 10);
        if (typeSize > MAX_LEN) {
          throw new Error(`malformed uint string: ${typeSize}`);
        }
        return new ABIUintType(typeSize);
      }
      if (str === "byte") {
        return new ABIByteType();
      }
      if (str.startsWith("ufixed")) {
        const stringMatches = str.match(ufixedRegexp);
        if (stringMatches.length !== 3) {
          throw new Error(`malformed ufixed type: ${str}`);
        }
        const ufixedSize = parseInt(stringMatches[1], 10);
        const ufixedPrecision = parseInt(stringMatches[2], 10);
        return new ABIUfixedType(ufixedSize, ufixedPrecision);
      }
      if (str === "bool") {
        return new ABIBoolType();
      }
      if (str === "address") {
        return new ABIAddressType();
      }
      if (str === "string") {
        return new ABIStringType();
      }
      if (str.length >= 2 && str[0] === "(" && str[str.length - 1] === ")") {
        const tupleContent = ABITupleType.parseTupleContent(str.slice(1, str.length - 1));
        const tupleTypes = [];
        for (let i = 0; i < tupleContent.length; i++) {
          const ti = ABIType.from(tupleContent[i]);
          tupleTypes.push(ti);
        }
        return new ABITupleType(tupleTypes);
      }
      throw new Error(`cannot convert a string ${str} to an ABI type`);
    }
  };
  var ABIUintType = class extends ABIType {
    constructor(size) {
      super();
      if (size % 8 !== 0 || size < 8 || size > 512) {
        throw new Error(`unsupported uint type bitSize: ${size}`);
      }
      this.bitSize = size;
    }
    toString() {
      return `uint${this.bitSize}`;
    }
    equals(other) {
      return other instanceof ABIUintType && this.bitSize === other.bitSize;
    }
    isDynamic() {
      return false;
    }
    byteLen() {
      return this.bitSize / 8;
    }
    encode(value) {
      if (typeof value !== "bigint" && typeof value !== "number") {
        throw new Error(`Cannot encode value as uint${this.bitSize}: ${value}`);
      }
      if (value >= BigInt(2 ** this.bitSize) || value < BigInt(0)) {
        throw new Error(`${value} is not a non-negative int or too big to fit in size uint${this.bitSize}`);
      }
      if (typeof value === "number" && !Number.isSafeInteger(value)) {
        throw new Error(`${value} should be converted into a BigInt before it is encoded`);
      }
      return bigIntToBytes(value, this.bitSize / 8);
    }
    decode(byteString) {
      if (byteString.length !== this.bitSize / 8) {
        throw new Error(`byte string must correspond to a uint${this.bitSize}`);
      }
      return bytesToBigInt(byteString);
    }
  };
  var ABIUfixedType = class extends ABIType {
    constructor(size, denominator) {
      super();
      if (size % 8 !== 0 || size < 8 || size > 512) {
        throw new Error(`unsupported ufixed type bitSize: ${size}`);
      }
      if (denominator > 160 || denominator < 1) {
        throw new Error(`unsupported ufixed type precision: ${denominator}`);
      }
      this.bitSize = size;
      this.precision = denominator;
    }
    toString() {
      return `ufixed${this.bitSize}x${this.precision}`;
    }
    equals(other) {
      return other instanceof ABIUfixedType && this.bitSize === other.bitSize && this.precision === other.precision;
    }
    isDynamic() {
      return false;
    }
    byteLen() {
      return this.bitSize / 8;
    }
    encode(value) {
      if (typeof value !== "bigint" && typeof value !== "number") {
        throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);
      }
      if (value >= BigInt(2 ** this.bitSize) || value < BigInt(0)) {
        throw new Error(`${value} is not a non-negative int or too big to fit in size ${this.toString()}`);
      }
      if (typeof value === "number" && !Number.isSafeInteger(value)) {
        throw new Error(`${value} should be converted into a BigInt before it is encoded`);
      }
      return bigIntToBytes(value, this.bitSize / 8);
    }
    decode(byteString) {
      if (byteString.length !== this.bitSize / 8) {
        throw new Error(`byte string must correspond to a ${this.toString()}`);
      }
      return bytesToBigInt(byteString);
    }
  };
  var ABIAddressType = class extends ABIType {
    toString() {
      return "address";
    }
    equals(other) {
      return other instanceof ABIAddressType;
    }
    isDynamic() {
      return false;
    }
    byteLen() {
      return ADDR_BYTE_SIZE;
    }
    encode(value) {
      if (typeof value !== "string" && !(value instanceof Uint8Array)) {
        throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);
      }
      if (typeof value === "string") {
        const decodedAddress = decodeAddress(value);
        return decodedAddress.publicKey;
      }
      if (value.byteLength !== 32) {
        throw new Error(`byte string must be 32 bytes long for an address`);
      }
      return value;
    }
    decode(byteString) {
      if (byteString.byteLength !== 32) {
        throw new Error(`byte string must be 32 bytes long for an address`);
      }
      return encodeAddress(byteString);
    }
  };
  var ABIBoolType = class extends ABIType {
    toString() {
      return "bool";
    }
    equals(other) {
      return other instanceof ABIBoolType;
    }
    isDynamic() {
      return false;
    }
    byteLen() {
      return SINGLE_BOOL_SIZE;
    }
    encode(value) {
      if (typeof value !== "boolean") {
        throw new Error(`Cannot encode value as bool: ${value}`);
      }
      if (value) {
        return new Uint8Array([128]);
      }
      return new Uint8Array([0]);
    }
    decode(byteString) {
      if (byteString.byteLength !== 1) {
        throw new Error(`bool string must be 1 byte long`);
      }
      const value = byteString[0];
      if (value === 128) {
        return true;
      }
      if (value === 0) {
        return false;
      }
      throw new Error(`boolean could not be decoded from the byte string`);
    }
  };
  var ABIByteType = class extends ABIType {
    toString() {
      return "byte";
    }
    equals(other) {
      return other instanceof ABIByteType;
    }
    isDynamic() {
      return false;
    }
    byteLen() {
      return SINGLE_BYTE_SIZE;
    }
    encode(value) {
      if (typeof value !== "number" && typeof value !== "bigint") {
        throw new Error(`Cannot encode value as byte: ${value}`);
      }
      if (typeof value === "bigint") {
        value = Number(value);
      }
      if (value < 0 || value > 255) {
        throw new Error(`${value} cannot be encoded into a byte`);
      }
      return new Uint8Array([value]);
    }
    decode(byteString) {
      if (byteString.byteLength !== 1) {
        throw new Error(`byte string must be 1 byte long`);
      }
      return byteString[0];
    }
  };
  var ABIStringType = class extends ABIType {
    toString() {
      return "string";
    }
    equals(other) {
      return other instanceof ABIStringType;
    }
    isDynamic() {
      return true;
    }
    byteLen() {
      throw new Error(`${this.toString()} is a dynamic type`);
    }
    encode(value) {
      if (typeof value !== "string" && !(value instanceof Uint8Array)) {
        throw new Error(`Cannot encode value as string: ${value}`);
      }
      const encodedBytes = Buffer.from(value);
      const encodedLength = bigIntToBytes(value.length, LENGTH_ENCODE_BYTE_SIZE);
      const mergedBytes = new Uint8Array(value.length + LENGTH_ENCODE_BYTE_SIZE);
      mergedBytes.set(encodedLength);
      mergedBytes.set(encodedBytes, LENGTH_ENCODE_BYTE_SIZE);
      return mergedBytes;
    }
    decode(byteString) {
      if (byteString.length < LENGTH_ENCODE_BYTE_SIZE) {
        throw new Error(`byte string is too short to be decoded. Actual length is ${byteString.length}, but expected at least ${LENGTH_ENCODE_BYTE_SIZE}`);
      }
      const buf = Buffer.from(byteString);
      const byteLength = buf.readUIntBE(0, LENGTH_ENCODE_BYTE_SIZE);
      const byteValue = byteString.slice(LENGTH_ENCODE_BYTE_SIZE, byteString.length);
      if (byteLength !== byteValue.length) {
        throw new Error(`string length bytes do not match the actual length of string. Expected ${byteLength}, got ${byteValue.length}`);
      }
      return Buffer.from(byteValue).toString("utf-8");
    }
  };
  var ABIArrayStaticType = class extends ABIType {
    constructor(argType, arrayLength) {
      super();
      if (arrayLength < 1) {
        throw new Error(`static array must have a length greater than 0: ${arrayLength}`);
      }
      this.childType = argType;
      this.staticLength = arrayLength;
    }
    toString() {
      return `${this.childType.toString()}[${this.staticLength}]`;
    }
    equals(other) {
      return other instanceof ABIArrayStaticType && this.staticLength === other.staticLength && this.childType.equals(other.childType);
    }
    isDynamic() {
      return this.childType.isDynamic();
    }
    byteLen() {
      if (this.childType.constructor === ABIBoolType) {
        return Math.ceil(this.staticLength / 8);
      }
      return this.staticLength * this.childType.byteLen();
    }
    encode(value) {
      if (!Array.isArray(value) && !(value instanceof Uint8Array)) {
        throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);
      }
      if (value.length !== this.staticLength) {
        throw new Error(`Value array does not match static array length. Expected ${this.staticLength}, got ${value.length}`);
      }
      const convertedTuple = this.toABITupleType();
      return convertedTuple.encode(value);
    }
    decode(byteString) {
      const convertedTuple = this.toABITupleType();
      return convertedTuple.decode(byteString);
    }
    toABITupleType() {
      return new ABITupleType(Array(this.staticLength).fill(this.childType));
    }
  };
  var ABIArrayDynamicType = class extends ABIType {
    constructor(argType) {
      super();
      this.childType = argType;
    }
    toString() {
      return `${this.childType.toString()}[]`;
    }
    equals(other) {
      return other instanceof ABIArrayDynamicType && this.childType.equals(other.childType);
    }
    isDynamic() {
      return true;
    }
    byteLen() {
      throw new Error(`${this.toString()} is a dynamic type`);
    }
    encode(value) {
      if (!Array.isArray(value) && !(value instanceof Uint8Array)) {
        throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);
      }
      const convertedTuple = this.toABITupleType(value.length);
      const encodedTuple = convertedTuple.encode(value);
      const encodedLength = bigIntToBytes(convertedTuple.childTypes.length, LENGTH_ENCODE_BYTE_SIZE);
      const mergedBytes = concatArrays(encodedLength, encodedTuple);
      return mergedBytes;
    }
    decode(byteString) {
      const buf = Buffer.from(byteString);
      const byteLength = buf.readUIntBE(0, LENGTH_ENCODE_BYTE_SIZE);
      const convertedTuple = this.toABITupleType(byteLength);
      return convertedTuple.decode(byteString.slice(LENGTH_ENCODE_BYTE_SIZE, byteString.length));
    }
    toABITupleType(length) {
      return new ABITupleType(Array(length).fill(this.childType));
    }
  };
  var ABITupleType = class extends ABIType {
    constructor(argTypes) {
      super();
      if (argTypes.length >= MAX_LEN) {
        throw new Error("tuple type child type number larger than maximum uint16 error");
      }
      this.childTypes = argTypes;
    }
    toString() {
      const typeStrings = [];
      for (let i = 0; i < this.childTypes.length; i++) {
        typeStrings[i] = this.childTypes[i].toString();
      }
      return `(${typeStrings.join(",")})`;
    }
    equals(other) {
      return other instanceof ABITupleType && this.childTypes.length === other.childTypes.length && this.childTypes.every((child, index) => child.equals(other.childTypes[index]));
    }
    isDynamic() {
      const isDynamic = (child) => child.isDynamic();
      return this.childTypes.some(isDynamic);
    }
    byteLen() {
      let size = 0;
      for (let i = 0; i < this.childTypes.length; i++) {
        if (this.childTypes[i].constructor === ABIBoolType) {
          const after = findBoolLR(this.childTypes, i, 1);
          const boolNum = after + 1;
          i += after;
          size += Math.trunc((boolNum + 7) / 8);
        } else {
          const childByteSize = this.childTypes[i].byteLen();
          size += childByteSize;
        }
      }
      return size;
    }
    encode(value) {
      if (!Array.isArray(value) && !(value instanceof Uint8Array)) {
        throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);
      }
      const values = Array.from(value);
      if (value.length > MAX_LEN) {
        throw new Error("length of tuple array should not exceed a uint16");
      }
      const tupleTypes = this.childTypes;
      const heads = [];
      const tails = [];
      const isDynamicIndex = /* @__PURE__ */ new Map();
      let i = 0;
      while (i < tupleTypes.length) {
        const tupleType = tupleTypes[i];
        if (tupleType.isDynamic()) {
          isDynamicIndex.set(heads.length, true);
          heads.push(new Uint8Array([0, 0]));
          tails.push(tupleType.encode(values[i]));
        } else {
          if (tupleType.constructor === ABIBoolType) {
            const before = findBoolLR(tupleTypes, i, -1);
            let after = findBoolLR(tupleTypes, i, 1);
            if (before % 8 !== 0) {
              throw new Error("expected before index should have number of bool mod 8 equal 0");
            }
            after = Math.min(7, after);
            const compressedInt = compressMultipleBool(values.slice(i, i + after + 1));
            heads.push(bigIntToBytes(compressedInt, 1));
            i += after;
          } else {
            const encodedTupleValue = tupleType.encode(values[i]);
            heads.push(encodedTupleValue);
          }
          isDynamicIndex.set(i, false);
          tails.push(new Uint8Array());
        }
        i += 1;
      }
      let headLength = 0;
      for (const headElement of heads) {
        headLength += headElement.length;
      }
      let tailLength = 0;
      for (let j = 0; j < heads.length; j++) {
        if (isDynamicIndex.get(j)) {
          const headValue = headLength + tailLength;
          if (headValue > MAX_LEN) {
            throw new Error(`byte length of ${headValue} should not exceed a uint16`);
          }
          heads[j] = bigIntToBytes(headValue, LENGTH_ENCODE_BYTE_SIZE);
        }
        tailLength += tails[j].length;
      }
      return concatArrays(...heads, ...tails);
    }
    decode(byteString) {
      const tupleTypes = this.childTypes;
      const dynamicSegments = [];
      const valuePartition = [];
      let i = 0;
      let iterIndex = 0;
      const buf = Buffer.from(byteString);
      while (i < tupleTypes.length) {
        const tupleType = tupleTypes[i];
        if (tupleType.isDynamic()) {
          if (byteString.slice(iterIndex, byteString.length).length < LENGTH_ENCODE_BYTE_SIZE) {
            throw new Error("dynamic type in tuple is too short to be decoded");
          }
          const dynamicIndex = buf.readUIntBE(iterIndex, LENGTH_ENCODE_BYTE_SIZE);
          if (dynamicSegments.length > 0) {
            dynamicSegments[dynamicSegments.length - 1].right = dynamicIndex;
            if (dynamicIndex < dynamicSegments[dynamicSegments.length - 1].left) {
              throw new Error("dynamic index segment miscalculation: left is greater than right index");
            }
          }
          const seg = {
            left: dynamicIndex,
            right: -1
          };
          dynamicSegments.push(seg);
          valuePartition.push(null);
          iterIndex += LENGTH_ENCODE_BYTE_SIZE;
        } else {
          if (tupleType.constructor === ABIBoolType) {
            const before = findBoolLR(this.childTypes, i, -1);
            let after = findBoolLR(this.childTypes, i, 1);
            if (before % 8 !== 0) {
              throw new Error("expected before bool number mod 8 === 0");
            }
            after = Math.min(7, after);
            for (let boolIndex = 0; boolIndex <= after; boolIndex++) {
              const boolMask = 128 >> boolIndex;
              if ((byteString[iterIndex] & boolMask) > 0) {
                valuePartition.push(new Uint8Array([128]));
              } else {
                valuePartition.push(new Uint8Array([0]));
              }
            }
            i += after;
            iterIndex += 1;
          } else {
            const currLen = tupleType.byteLen();
            valuePartition.push(byteString.slice(iterIndex, iterIndex + currLen));
            iterIndex += currLen;
          }
        }
        if (i !== tupleTypes.length - 1 && iterIndex >= byteString.length) {
          throw new Error("input byte not enough to decode");
        }
        i += 1;
      }
      if (dynamicSegments.length > 0) {
        dynamicSegments[dynamicSegments.length - 1].right = byteString.length;
        iterIndex = byteString.length;
      }
      if (iterIndex < byteString.length) {
        throw new Error("input byte not fully consumed");
      }
      for (let j = 0; j < dynamicSegments.length; j++) {
        const seg = dynamicSegments[j];
        if (seg.left > seg.right) {
          throw new Error("dynamic segment should display a [l, r] space with l <= r");
        }
        if (j !== dynamicSegments.length - 1 && seg.right !== dynamicSegments[j + 1].left) {
          throw new Error("dynamic segment should be consecutive");
        }
      }
      let segIndex = 0;
      for (let j = 0; j < tupleTypes.length; j++) {
        if (tupleTypes[j].isDynamic()) {
          valuePartition[j] = byteString.slice(dynamicSegments[segIndex].left, dynamicSegments[segIndex].right);
          segIndex += 1;
        }
      }
      const returnValues = [];
      for (let j = 0; j < tupleTypes.length; j++) {
        const valueTi = tupleTypes[j].decode(valuePartition[j]);
        returnValues.push(valueTi);
      }
      return returnValues;
    }
    static parseTupleContent(str) {
      if (str.length === 0) {
        return [];
      }
      if (str.endsWith(",") || str.startsWith(",")) {
        throw new Error("tuple string should not start with comma");
      }
      if (str.includes(",,")) {
        throw new Error("tuple string should not have consecutive commas");
      }
      const tupleStrings = [];
      let depth = 0;
      let word = "";
      for (const char of str) {
        word += char;
        if (char === "(") {
          depth += 1;
        } else if (char === ")") {
          depth -= 1;
        } else if (char === ",") {
          if (depth === 0) {
            tupleStrings.push(word.slice(0, word.length - 1));
            word = "";
          }
        }
      }
      if (word.length !== 0) {
        tupleStrings.push(word);
      }
      if (depth !== 0) {
        throw new Error("tuple string has mismatched parentheses");
      }
      return tupleStrings;
    }
  };
  function compressMultipleBool(valueList) {
    let res = 0;
    if (valueList.length > 8) {
      throw new Error("value list passed in should be no greater than length 8");
    }
    for (let i = 0; i < valueList.length; i++) {
      const boolVal = valueList[i];
      if (typeof boolVal !== "boolean") {
        throw new Error("non-boolean values cannot be compressed into a byte");
      }
      if (boolVal) {
        res |= 1 << 7 - i;
      }
    }
    return res;
  }
  function findBoolLR(typeList, index, delta) {
    let until = 0;
    while (true) {
      const curr = index + delta * until;
      if (typeList[curr].constructor === ABIBoolType) {
        if (curr !== typeList.length - 1 && delta === 1) {
          until += 1;
        } else if (curr > 0 && delta === -1) {
          until += 1;
        } else {
          break;
        }
      } else {
        until -= 1;
        break;
      }
    }
    return until;
  }

  // node_modules/algosdk/dist/esm/src/abi/method.js
  init_naclWrappers();

  // node_modules/algosdk/dist/esm/src/abi/transaction.js
  var ABITransactionType;
  (function(ABITransactionType2) {
    ABITransactionType2["any"] = "txn";
    ABITransactionType2["pay"] = "pay";
    ABITransactionType2["keyreg"] = "keyreg";
    ABITransactionType2["acfg"] = "acfg";
    ABITransactionType2["axfer"] = "axfer";
    ABITransactionType2["afrz"] = "afrz";
    ABITransactionType2["appl"] = "appl";
  })(ABITransactionType || (ABITransactionType = {}));
  function abiTypeIsTransaction(type) {
    return type === ABITransactionType.any || type === ABITransactionType.pay || type === ABITransactionType.keyreg || type === ABITransactionType.acfg || type === ABITransactionType.axfer || type === ABITransactionType.afrz || type === ABITransactionType.appl;
  }
  function abiCheckTransactionType(type, txn) {
    if (type === ABITransactionType.any) {
      return true;
    }
    return txn.type && txn.type.toString() === type.toString();
  }

  // node_modules/algosdk/dist/esm/src/abi/reference.js
  var ABIReferenceType;
  (function(ABIReferenceType2) {
    ABIReferenceType2["account"] = "account";
    ABIReferenceType2["application"] = "application";
    ABIReferenceType2["asset"] = "asset";
  })(ABIReferenceType || (ABIReferenceType = {}));
  function abiTypeIsReference(type) {
    return type === ABIReferenceType.account || type === ABIReferenceType.application || type === ABIReferenceType.asset;
  }

  // node_modules/algosdk/dist/esm/src/abi/method.js
  function parseMethodSignature(signature) {
    const argsStart = signature.indexOf("(");
    if (argsStart === -1) {
      throw new Error(`Invalid method signature: ${signature}`);
    }
    let argsEnd = -1;
    let depth = 0;
    for (let i = argsStart; i < signature.length; i++) {
      const char = signature[i];
      if (char === "(") {
        depth += 1;
      } else if (char === ")") {
        if (depth === 0) {
          break;
        }
        depth -= 1;
        if (depth === 0) {
          argsEnd = i;
          break;
        }
      }
    }
    if (argsEnd === -1) {
      throw new Error(`Invalid method signature: ${signature}`);
    }
    return {
      name: signature.slice(0, argsStart),
      args: ABITupleType.parseTupleContent(signature.slice(argsStart + 1, argsEnd)),
      returns: signature.slice(argsEnd + 1)
    };
  }
  var ABIMethod = class {
    constructor(params) {
      if (typeof params.name !== "string" || typeof params.returns !== "object" || !Array.isArray(params.args)) {
        throw new Error("Invalid ABIMethod parameters");
      }
      this.name = params.name;
      this.description = params.desc;
      this.args = params.args.map(({ type, name, desc }) => {
        if (abiTypeIsTransaction(type) || abiTypeIsReference(type)) {
          return {
            type,
            name,
            description: desc
          };
        }
        return {
          type: ABIType.from(type),
          name,
          description: desc
        };
      });
      this.returns = {
        type: params.returns.type === "void" ? params.returns.type : ABIType.from(params.returns.type),
        description: params.returns.desc
      };
    }
    getSignature() {
      const args = this.args.map((arg) => arg.type.toString()).join(",");
      const returns = this.returns.type.toString();
      return `${this.name}(${args})${returns}`;
    }
    getSelector() {
      const hash = genericHash(this.getSignature());
      return new Uint8Array(hash.slice(0, 4));
    }
    txnCount() {
      let count = 1;
      for (const arg of this.args) {
        if (typeof arg.type === "string" && abiTypeIsTransaction(arg.type)) {
          count += 1;
        }
      }
      return count;
    }
    toJSON() {
      return {
        name: this.name,
        desc: this.description,
        args: this.args.map(({ type, name, description }) => ({
          type: type.toString(),
          name,
          desc: description
        })),
        returns: {
          type: this.returns.type.toString(),
          desc: this.returns.description
        }
      };
    }
    static fromSignature(signature) {
      const { name, args, returns } = parseMethodSignature(signature);
      return new ABIMethod({
        name,
        args: args.map((arg) => ({ type: arg })),
        returns: { type: returns }
      });
    }
  };

  // node_modules/algosdk/dist/esm/src/abi/contract.js
  var ABIContract = class {
    constructor(params) {
      if (typeof params.name !== "string" || !Array.isArray(params.methods) || params.networks && typeof params.networks !== "object") {
        throw new Error("Invalid ABIContract parameters");
      }
      this.name = params.name;
      this.description = params.desc;
      this.networks = params.networks ? __spreadValues({}, params.networks) : {};
      this.methods = params.methods.map((method2) => new ABIMethod(method2));
    }
    toJSON() {
      return {
        name: this.name,
        desc: this.description,
        networks: this.networks,
        methods: this.methods.map((method2) => method2.toJSON())
      };
    }
  };

  // node_modules/algosdk/dist/esm/src/abi/interface.js
  var ABIInterface = class {
    constructor(params) {
      if (typeof params.name !== "string" || !Array.isArray(params.methods)) {
        throw new Error("Invalid ABIInterface parameters");
      }
      this.name = params.name;
      this.description = params.desc;
      this.methods = params.methods.map((method2) => new ABIMethod(method2));
    }
    toJSON() {
      return {
        name: this.name,
        desc: this.description,
        methods: this.methods.map((method2) => method2.toJSON())
      };
    }
  };

  // node_modules/algosdk/dist/esm/src/composer.js
  init_transaction();
  init_makeTxn();
  init_group();
  init_base();
  var RETURN_PREFIX = Buffer.from([21, 31, 124, 117]);
  var MAX_APP_ARGS = 16;
  var AtomicTransactionComposerStatus;
  (function(AtomicTransactionComposerStatus2) {
    AtomicTransactionComposerStatus2[AtomicTransactionComposerStatus2["BUILDING"] = 0] = "BUILDING";
    AtomicTransactionComposerStatus2[AtomicTransactionComposerStatus2["BUILT"] = 1] = "BUILT";
    AtomicTransactionComposerStatus2[AtomicTransactionComposerStatus2["SIGNED"] = 2] = "SIGNED";
    AtomicTransactionComposerStatus2[AtomicTransactionComposerStatus2["SUBMITTED"] = 3] = "SUBMITTED";
    AtomicTransactionComposerStatus2[AtomicTransactionComposerStatus2["COMMITTED"] = 4] = "COMMITTED";
  })(AtomicTransactionComposerStatus || (AtomicTransactionComposerStatus = {}));
  function populateForeignArray(valueToAdd, array, zeroValue) {
    if (zeroValue != null && valueToAdd === zeroValue) {
      return 0;
    }
    const offset = zeroValue == null ? 0 : 1;
    for (let i = 0; i < array.length; i++) {
      if (valueToAdd === array[i]) {
        return i + offset;
      }
    }
    array.push(valueToAdd);
    return array.length - 1 + offset;
  }
  var AtomicTransactionComposer = class {
    constructor() {
      this.status = AtomicTransactionComposerStatus.BUILDING;
      this.transactions = [];
      this.methodCalls = /* @__PURE__ */ new Map();
      this.signedTxns = [];
      this.txIDs = [];
    }
    getStatus() {
      return this.status;
    }
    count() {
      return this.transactions.length;
    }
    clone() {
      const theClone = new AtomicTransactionComposer();
      theClone.transactions = this.transactions.map(({ txn, signer }) => ({
        txn: Transaction.from_obj_for_encoding(__spreadProps(__spreadValues({}, txn.get_obj_for_encoding()), {
          grp: void 0
        })),
        signer
      }));
      theClone.methodCalls = new Map(this.methodCalls);
      return theClone;
    }
    addTransaction(txnAndSigner) {
      if (this.status !== AtomicTransactionComposerStatus.BUILDING) {
        throw new Error("Cannot add transactions when composer status is not BUILDING");
      }
      if (this.transactions.length === AtomicTransactionComposer.MAX_GROUP_SIZE) {
        throw new Error(`Adding an additional transaction exceeds the maximum atomic group size of ${AtomicTransactionComposer.MAX_GROUP_SIZE}`);
      }
      if (txnAndSigner.txn.group && txnAndSigner.txn.group.some((v) => v !== 0)) {
        throw new Error("Cannot add a transaction with nonzero group ID");
      }
      this.transactions.push(txnAndSigner);
    }
    addMethodCall({ appID, method: method2, methodArgs, sender, suggestedParams, onComplete, approvalProgram, clearProgram, numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices, extraPages, note, lease, rekeyTo, signer }) {
      if (this.status !== AtomicTransactionComposerStatus.BUILDING) {
        throw new Error("Cannot add transactions when composer status is not BUILDING");
      }
      if (this.transactions.length + method2.txnCount() > AtomicTransactionComposer.MAX_GROUP_SIZE) {
        throw new Error(`Adding additional transactions exceeds the maximum atomic group size of ${AtomicTransactionComposer.MAX_GROUP_SIZE}`);
      }
      if (appID === 0) {
        if (approvalProgram == null || clearProgram == null || numGlobalInts == null || numGlobalByteSlices == null || numLocalInts == null || numLocalByteSlices == null) {
          throw new Error("One of the following required parameters for application creation is missing: approvalProgram, clearProgram, numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices");
        }
      } else if (onComplete === OnApplicationComplete.UpdateApplicationOC) {
        if (approvalProgram == null || clearProgram == null) {
          throw new Error("One of the following required parameters for OnApplicationComplete.UpdateApplicationOC is missing: approvalProgram, clearProgram");
        }
        if (numGlobalInts != null || numGlobalByteSlices != null || numLocalInts != null || numLocalByteSlices != null || extraPages != null) {
          throw new Error("One of the following application creation parameters were set on a non-creation call: numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices, extraPages");
        }
      } else if (approvalProgram != null || clearProgram != null || numGlobalInts != null || numGlobalByteSlices != null || numLocalInts != null || numLocalByteSlices != null || extraPages != null) {
        throw new Error("One of the following application creation parameters were set on a non-creation call: approvalProgram, clearProgram, numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices, extraPages");
      }
      if (methodArgs == null) {
        methodArgs = [];
      }
      if (methodArgs.length !== method2.args.length) {
        throw new Error(`Incorrect number of method arguments. Expected ${method2.args.length}, got ${methodArgs.length}`);
      }
      let basicArgTypes = [];
      let basicArgValues = [];
      const txnArgs = [];
      const refArgTypes = [];
      const refArgValues = [];
      const refArgIndexToBasicArgIndex = /* @__PURE__ */ new Map();
      for (let i = 0; i < methodArgs.length; i++) {
        let argType = method2.args[i].type;
        const argValue = methodArgs[i];
        if (abiTypeIsTransaction(argType)) {
          if (!isTransactionWithSigner(argValue) || !abiCheckTransactionType(argType, argValue.txn)) {
            throw new Error(`Expected ${argType} transaction for argument at index ${i}`);
          }
          if (argValue.txn.group && argValue.txn.group.some((v) => v !== 0)) {
            throw new Error("Cannot add a transaction with nonzero group ID");
          }
          txnArgs.push(argValue);
          continue;
        }
        if (isTransactionWithSigner(argValue)) {
          throw new Error(`Expected non-transaction value for argument at index ${i}`);
        }
        if (abiTypeIsReference(argType)) {
          refArgIndexToBasicArgIndex.set(refArgTypes.length, basicArgTypes.length);
          refArgTypes.push(argType);
          refArgValues.push(argValue);
          argType = new ABIUintType(8);
        }
        if (typeof argType === "string") {
          throw new Error(`Unknown ABI type: ${argType}`);
        }
        basicArgTypes.push(argType);
        basicArgValues.push(argValue);
      }
      const resolvedRefIndexes = [];
      const foreignAccounts = [];
      const foreignApps = [];
      const foreignAssets = [];
      for (let i = 0; i < refArgTypes.length; i++) {
        const refType = refArgTypes[i];
        const refValue = refArgValues[i];
        let resolved = 0;
        switch (refType) {
          case ABIReferenceType.account: {
            const addressType = new ABIAddressType();
            const address = addressType.decode(addressType.encode(refValue));
            resolved = populateForeignArray(address, foreignAccounts, sender);
            break;
          }
          case ABIReferenceType.application: {
            const uint64Type = new ABIUintType(64);
            const refAppID = uint64Type.decode(uint64Type.encode(refValue));
            if (refAppID > Number.MAX_SAFE_INTEGER) {
              throw new Error(`Expected safe integer for application value, got ${refAppID}`);
            }
            resolved = populateForeignArray(Number(refAppID), foreignApps, appID);
            break;
          }
          case ABIReferenceType.asset: {
            const uint64Type = new ABIUintType(64);
            const refAssetID = uint64Type.decode(uint64Type.encode(refValue));
            if (refAssetID > Number.MAX_SAFE_INTEGER) {
              throw new Error(`Expected safe integer for asset value, got ${refAssetID}`);
            }
            resolved = populateForeignArray(Number(refAssetID), foreignAssets);
            break;
          }
          default:
            throw new Error(`Unknown reference type: ${refType}`);
        }
        resolvedRefIndexes.push(resolved);
      }
      for (let i = 0; i < resolvedRefIndexes.length; i++) {
        const basicArgIndex = refArgIndexToBasicArgIndex.get(i);
        basicArgValues[basicArgIndex] = resolvedRefIndexes[i];
      }
      if (basicArgTypes.length > MAX_APP_ARGS - 1) {
        const lastArgTupleTypes = basicArgTypes.slice(MAX_APP_ARGS - 2);
        const lastArgTupleValues = basicArgValues.slice(MAX_APP_ARGS - 2);
        basicArgTypes = basicArgTypes.slice(0, MAX_APP_ARGS - 2);
        basicArgValues = basicArgValues.slice(0, MAX_APP_ARGS - 2);
        basicArgTypes.push(new ABITupleType(lastArgTupleTypes));
        basicArgValues.push(lastArgTupleValues);
      }
      const appArgsEncoded = [method2.getSelector()];
      for (let i = 0; i < basicArgTypes.length; i++) {
        appArgsEncoded.push(basicArgTypes[i].encode(basicArgValues[i]));
      }
      const appCall = {
        txn: makeApplicationCallTxnFromObject({
          from: sender,
          appIndex: appID,
          appArgs: appArgsEncoded,
          accounts: foreignAccounts,
          foreignApps,
          foreignAssets,
          onComplete: onComplete == null ? OnApplicationComplete.NoOpOC : onComplete,
          approvalProgram,
          clearProgram,
          numGlobalInts,
          numGlobalByteSlices,
          numLocalInts,
          numLocalByteSlices,
          extraPages,
          lease,
          note,
          rekeyTo,
          suggestedParams
        }),
        signer
      };
      this.transactions.push(...txnArgs, appCall);
      this.methodCalls.set(this.transactions.length - 1, method2);
    }
    buildGroup() {
      if (this.status === AtomicTransactionComposerStatus.BUILDING) {
        if (this.transactions.length === 0) {
          throw new Error("Cannot build a group with 0 transactions");
        }
        if (this.transactions.length > 1) {
          assignGroupID(this.transactions.map((txnWithSigner) => txnWithSigner.txn));
        }
        this.status = AtomicTransactionComposerStatus.BUILT;
      }
      return this.transactions;
    }
    async gatherSignatures() {
      if (this.status >= AtomicTransactionComposerStatus.SIGNED) {
        return this.signedTxns;
      }
      const txnsWithSigners = this.buildGroup();
      const txnGroup = txnsWithSigners.map((txnWithSigner) => txnWithSigner.txn);
      const indexesPerSigner = /* @__PURE__ */ new Map();
      for (let i = 0; i < txnsWithSigners.length; i++) {
        const { signer } = txnsWithSigners[i];
        if (!indexesPerSigner.has(signer)) {
          indexesPerSigner.set(signer, []);
        }
        indexesPerSigner.get(signer).push(i);
      }
      const orderedSigners = Array.from(indexesPerSigner);
      const batchedSigs = await Promise.all(orderedSigners.map(([signer, indexes]) => signer(txnGroup, indexes)));
      const signedTxns = txnsWithSigners.map(() => null);
      for (let signerIndex = 0; signerIndex < orderedSigners.length; signerIndex++) {
        const indexes = orderedSigners[signerIndex][1];
        const sigs = batchedSigs[signerIndex];
        for (let i = 0; i < indexes.length; i++) {
          signedTxns[indexes[i]] = sigs[i];
        }
      }
      if (!signedTxns.every((sig) => sig != null)) {
        throw new Error(`Missing signatures. Got ${signedTxns}`);
      }
      const txIDs = signedTxns.map((stxn, index) => {
        try {
          return decodeSignedTransaction(stxn).txn.txID();
        } catch (err) {
          throw new Error(`Cannot decode signed transaction at index ${index}. ${err}`);
        }
      });
      this.signedTxns = signedTxns;
      this.txIDs = txIDs;
      this.status = AtomicTransactionComposerStatus.SIGNED;
      return signedTxns;
    }
    async submit(client) {
      if (this.status > AtomicTransactionComposerStatus.SUBMITTED) {
        throw new Error("Transaction group cannot be resubmitted");
      }
      const stxns = await this.gatherSignatures();
      await client.sendRawTransaction(stxns).do();
      this.status = AtomicTransactionComposerStatus.SUBMITTED;
      return this.txIDs;
    }
    async execute(client, waitRounds) {
      if (this.status === AtomicTransactionComposerStatus.COMMITTED) {
        throw new Error("Transaction group has already been executed successfully");
      }
      const txIDs = await this.submit(client);
      this.status = AtomicTransactionComposerStatus.SUBMITTED;
      const firstMethodCallIndex = this.transactions.findIndex((_, index) => this.methodCalls.has(index));
      const indexToWaitFor = firstMethodCallIndex === -1 ? 0 : firstMethodCallIndex;
      const confirmedTxnInfo = await waitForConfirmation(client, txIDs[indexToWaitFor], waitRounds);
      this.status = AtomicTransactionComposerStatus.COMMITTED;
      const confirmedRound = confirmedTxnInfo["confirmed-round"];
      const methodResults = [];
      for (const [txnIndex, method2] of this.methodCalls) {
        const txID = txIDs[txnIndex];
        const methodResult = {
          txID,
          rawReturnValue: new Uint8Array()
        };
        try {
          if (method2.returns.type !== "void") {
            const pendingInfo = txnIndex === firstMethodCallIndex ? confirmedTxnInfo : await client.pendingTransactionInformation(txID).do();
            const logs = pendingInfo.logs || [];
            if (logs.length === 0) {
              throw new Error("App call transaction did not log a return value");
            }
            const lastLog = Buffer.from(logs[logs.length - 1], "base64");
            if (lastLog.byteLength < 4 || !lastLog.slice(0, 4).equals(RETURN_PREFIX)) {
              throw new Error("App call transaction did not log a return value");
            }
            methodResult.rawReturnValue = new Uint8Array(lastLog.slice(4));
            methodResult.returnValue = method2.returns.type.decode(methodResult.rawReturnValue);
          }
        } catch (err) {
          methodResult.decodeError = err;
        }
        methodResults.push(methodResult);
      }
      return {
        confirmedRound,
        txIDs,
        methodResults
      };
    }
  };
  AtomicTransactionComposer.MAX_GROUP_SIZE = 16;

  // node_modules/algosdk/dist/esm/src/types/index.js
  init_transactions();

  // node_modules/algosdk/dist/esm/src/main.js
  var SIGN_BYTES_PREFIX = Buffer.from([77, 88]);
  var MULTISIG_BAD_SENDER_ERROR_MSG = "The transaction sender address and multisig preimage do not match.";
  function signTransaction(txn, sk) {
    if (typeof txn.from === "undefined") {
      const key = keyPairFromSecretKey(sk);
      txn.from = encodeAddress(key.publicKey);
    }
    const algoTxn = instantiateTxnIfNeeded(txn);
    return {
      txID: algoTxn.txID().toString(),
      blob: algoTxn.signTxn(sk)
    };
  }
  function signBid(bid, sk) {
    const signedBid = new Bid(bid);
    return signedBid.signBid(sk);
  }
  function signBytes(bytes, sk) {
    const toBeSigned = Buffer.from(concatArrays(SIGN_BYTES_PREFIX, bytes));
    const sig = sign(toBeSigned, sk);
    return sig;
  }
  function verifyBytes(bytes, signature, addr) {
    const toBeVerified = Buffer.from(concatArrays(SIGN_BYTES_PREFIX, bytes));
    const pk = decodeAddress(addr).publicKey;
    return verify(toBeVerified, signature, pk);
  }
  function encodeObj(o) {
    return new Uint8Array(encode2(o));
  }
  function decodeObj(o) {
    return decode2(o);
  }
  var ERROR_MULTISIG_BAD_SENDER = new Error(MULTISIG_BAD_SENDER_ERROR_MSG);
  var ERROR_INVALID_MICROALGOS = new Error(INVALID_MICROALGOS_ERROR_MSG);
  var LogicTemplates = LogicTemplatesCommonJSExport.default;

  // node_modules/algosdk/dist/esm/index.js
  __reExport(esm_exports, main_exports);
  var esm_default = main_exports;

  // src/transactions.ts
  var import_constants = __toESM(require_constants2());
  var import_generateTeal = __toESM(require_generateTeal());
  var Transactions = class {
    algodClient;
    constructor(client) {
      this.algodClient = client;
    }
    async generateLsig(name) {
      let program = await this.algodClient.compile((0, import_generateTeal.generateTeal)(name)).do();
      program = new Uint8Array(Buffer.from(program.result, "base64"));
      return new esm_default.LogicSigAccount(program);
    }
    calculatePrice(name, period) {
      let amount = 0;
      if (name.length === 3) {
        amount = import_constants.REGISTRATION_PRICE.CHAR_3_AMOUNT * period;
      } else if (name.length === 4) {
        amount = import_constants.REGISTRATION_PRICE.CHAR_4_AMOUNT * period;
      } else if (name.length >= 5) {
        amount = import_constants.REGISTRATION_PRICE.CHAR_5_AMOUNT * period;
      }
      return amount;
    }
    async prepareNameRegistrationTransactions(name, address, period) {
      const algodClient = this.algodClient;
      let amount = 0;
      const lsig = await this.generateLsig(name);
      const params = await algodClient.getTransactionParams().do();
      params.fee = 1e3;
      params.flatFee = true;
      let receiver = esm_default.getApplicationAddress(import_constants.APP_ID);
      let sender = address;
      if (period === void 0) {
        period = 1;
      }
      amount = this.calculatePrice(name, period);
      const closeToRemaninder = void 0;
      const note = void 0;
      const txn1 = esm_default.makePaymentTxnWithSuggestedParams(sender, receiver, amount, closeToRemaninder, note, params);
      const groupTxns = [];
      groupTxns.push(txn1);
      sender = address;
      receiver = lsig.address();
      amount = 915e3;
      const txn2 = esm_default.makePaymentTxnWithSuggestedParams(sender, receiver, amount, closeToRemaninder, note, params);
      groupTxns.push(txn2);
      const txn3 = await esm_default.makeApplicationOptInTxnFromObject({
        from: lsig.address(),
        suggestedParams: params,
        appIndex: import_constants.APP_ID
      });
      groupTxns.push(txn3);
      sender = lsig.address();
      receiver = address;
      amount = 0;
      const method2 = "register_name";
      const appArgs = [];
      period++;
      appArgs.push(new Uint8Array(Buffer.from(method2)));
      appArgs.push(new Uint8Array(Buffer.from(name)));
      appArgs.push(esm_default.encodeUint64(period));
      const txn4 = await esm_default.makeApplicationNoOpTxn(address, params, import_constants.APP_ID, appArgs, [lsig.address()]);
      groupTxns.push(txn4);
      esm_default.assignGroupID(groupTxns);
      const signedOptinTxn = esm_default.signLogicSigTransaction(groupTxns[2], lsig);
      return {
        optinTxn: signedOptinTxn,
        txns: groupTxns,
        unsignedOptinTxn: groupTxns[2]
      };
    }
    async prepareUpdateNamePropertyTransactions(name, address, editedHandles) {
      const algodClient = this.algodClient;
      const lsig = await this.generateLsig(name);
      const params = await algodClient.getTransactionParams().do();
      params.fee = 1e3;
      params.flatFee = true;
      const method2 = "update_name";
      const groupTxns = [];
      for (const key in editedHandles) {
        const appArgs = [];
        const network = key;
        const handle = editedHandles[key];
        appArgs.push(new Uint8Array(Buffer.from(method2)));
        appArgs.push(new Uint8Array(Buffer.from(network)));
        appArgs.push(new Uint8Array(Buffer.from(handle)));
        const txn = await esm_default.makeApplicationNoOpTxn(address, params, import_constants.APP_ID, appArgs, [lsig.address()]);
        groupTxns.push(txn);
      }
      if (Object.keys(editedHandles).length > 1) {
        esm_default.assignGroupID(groupTxns);
      }
      return groupTxns;
    }
    async preparePaymentTxn(sender, receiver, amt, note) {
      const algodClient = this.algodClient;
      const params = await algodClient.getTransactionParams().do();
      amt = esm_default.algosToMicroalgos(amt);
      const enc = new TextEncoder();
      note = enc.encode(note);
      const closeToRemaninder = void 0;
      return esm_default.makePaymentTxnWithSuggestedParams(sender, receiver, amt, closeToRemaninder, note, params);
    }
    async prepareNameRenewalTxns(name, sender, years) {
      const algodClient = this.algodClient;
      const params = await algodClient.getTransactionParams().do();
      const receiver = esm_default.getApplicationAddress(import_constants.APP_ID);
      const closeToRemaninder = void 0;
      const note = void 0;
      const paymentTxn = esm_default.makePaymentTxnWithSuggestedParams(sender, receiver, this.calculatePrice(name, years), closeToRemaninder, note, params);
      const lsig = await this.generateLsig(name);
      const appArgs = [];
      appArgs.push(new Uint8Array(Buffer.from("renew_name")));
      appArgs.push(esm_default.encodeUint64(years));
      const applicationTxn = esm_default.makeApplicationNoOpTxn(sender, params, import_constants.APP_ID, appArgs, [lsig.address()]);
      esm_default.assignGroupID([paymentTxn, applicationTxn]);
      return [paymentTxn, applicationTxn];
    }
    async prepareInitiateNameTransferTransaction(name, sender, newOwner, price) {
      const algodClient = this.algodClient;
      price = esm_default.algosToMicroalgos(price);
      const params = await algodClient.getTransactionParams().do();
      const lsig = await this.generateLsig(name);
      const appArgs = [];
      appArgs.push(new Uint8Array(Buffer.from("initiate_transfer")));
      appArgs.push(esm_default.encodeUint64(price));
      return esm_default.makeApplicationNoOpTxn(sender, params, import_constants.APP_ID, appArgs, [
        lsig.address(),
        newOwner
      ]);
    }
    async prepareAcceptNameTransferTransactions(name, sender, receiver, amt) {
      amt = esm_default.algosToMicroalgos(amt);
      const algodClient = this.algodClient;
      const params = await algodClient.getTransactionParams().do();
      const closeToRemaninder = void 0;
      const note = void 0;
      const paymentToOwnerTxn = esm_default.makePaymentTxnWithSuggestedParams(sender, receiver, amt, closeToRemaninder, note, params);
      receiver = esm_default.getApplicationAddress(import_constants.APP_ID);
      const paymentToSmartContractTxn = esm_default.makePaymentTxnWithSuggestedParams(sender, receiver, import_constants.TRANSFER_FEE, closeToRemaninder, note, params);
      const lsig = await this.generateLsig(name);
      const appArgs = [];
      appArgs.push(new Uint8Array(Buffer.from("accept_transfer")));
      const applicationTxn = esm_default.makeApplicationNoOpTxn(sender, params, import_constants.APP_ID, appArgs, [lsig.address()]);
      esm_default.assignGroupID([
        paymentToOwnerTxn,
        paymentToSmartContractTxn,
        applicationTxn
      ]);
      return [paymentToOwnerTxn, paymentToSmartContractTxn, applicationTxn];
    }
  };
})();
/*
 * [hi-base32]{@link https://github.com/emn178/hi-base32}
 *
 * @version 0.5.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */
/*
 * [js-sha512]{@link https://github.com/emn178/js-sha512}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2014-2018
 * @license MIT
 */
/*!
 * methods
 * Copyright(c) 2013-2014 TJ Holowaychuk
 * Copyright(c) 2015-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * MIT Licensed
 */
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/**
 * [js-sha256]{@link https://github.com/emn178/js-sha256}
 *
 * @version 0.9.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2014-2017
 * @license MIT
 */
/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */
//# sourceMappingURL=transactions.global.js.map